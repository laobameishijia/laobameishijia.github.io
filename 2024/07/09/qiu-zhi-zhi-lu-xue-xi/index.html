<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="求职之路-学习, 老叭美食家">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>求职之路-学习 | 老叭美食家</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="老叭美食家" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/static/image/header/home.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">老叭美食家</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>联系</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">老叭美食家</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			联系
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/QQ截图20240721095809.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">求职之路-学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tag/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/">
                                <span class="chip bg-color">常见知识</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/category/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-07-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-04-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    25k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    92 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="求职之路-—-学习总结"><a href="#求职之路-—-学习总结" class="headerlink" title="求职之路 — 学习总结"></a>求职之路 — 学习总结</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-在进程切换的时候会发生什么？"><a href="#1-在进程切换的时候会发生什么？" class="headerlink" title="1. 在进程切换的时候会发生什么？"></a>1. 在进程切换的时候会发生什么？</h3><p>在操作系统中，进程切换（也称为上下文切换）是指将 CPU 从一个进程切换到另一个进程的过程。这个过程由操作系统内核负责管理，并确保系统资源能够在多个进程之间公平和有效地分配。以下是进程切换过程中发生的一些关键步骤：</p>
<p><strong>进程切换的主要步骤</strong></p>
<ol>
<li>保存当前进程的状态：</li>
</ol>
<ul>
<li>CPU寄存器：当前进程的所有CPU寄存器（如程序计数器、堆栈指针、通用寄存器等）被保存到进程的控制块（Process Control Block，PCB）中。</li>
<li>内存管理信息：当前进程的内存管理信息（如页表或段表）也被保存。</li>
</ul>
<ol start="2">
<li>更新进程状态：</li>
</ol>
<ul>
<li>当前进程的状态在其PCB中被标记为“等待”或“就绪”状态，以反映它不再占用CPU。</li>
</ul>
<ol start="3">
<li>选择下一个进程：</li>
</ol>
<ul>
<li>操作系统的调度器选择下一个要运行的进程。选择算法可能是基于优先级、时间片轮转、最短剩余时间优先等调度策略。</li>
</ul>
<ol start="4">
<li>恢复下一个进程的状态：</li>
</ol>
<ul>
<li>CPU寄存器：从下一个进程的PCB中恢复所有的CPU寄存器。</li>
<li>内存管理信息：加载下一个进程的内存管理信息，以确保CPU能够正确访问进程的内存。</li>
</ul>
<ol start="5">
<li>更新内存映射：</li>
</ol>
<ul>
<li>如果使用虚拟内存，操作系统可能需要更新内存映射（如页表）以确保CPU访问的是当前进程的内存。</li>
</ul>
<ol start="6">
<li>更新进程状态：</li>
</ol>
<ul>
<li>被选中的进程状态在其PCB中被标记为“运行”状态，表示它正在占用CPU。</li>
</ul>
<ol start="7">
<li>切换上下文：<br>最后一步，CPU的上下文被切换到新的进程，这包括跳转到新的程序计数器地址，并开始执行该进程的代码。</li>
</ol>
<p>示例：进程切换的汇编代码<br>以下是一个简化的进程切换示例，以x86-64汇编代码展示了保存和恢复寄存器的基本步骤：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">复制代码
; 保存当前进程的上下文
save_context:
    ; 保存通用寄存器
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push r8
    push r9
    push r10
    push r11
    push r12
    push r13
    push r14
    push r15

    ; 保存指令指针和标志寄存器
    pushfq
    mov [current_process_rsp], rsp  ; 保存当前进程的堆栈指针

    ; 切换到下一个进程
    mov rsp, [next_process_rsp]     ; 恢复下一个进程的堆栈指针

; 恢复下一个进程的上下文
restore_context:
    popfq
    pop r15
    pop r14
    pop r13
    pop r12
    pop r11
    pop r10
    pop r9
    pop r8
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax

    ret  ; 返回并继续执行下一个进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>操作系统级别的进程切换</strong></p>
<p>在实际操作系统中，进程切换涉及更多的复杂性，包括但不限于：</p>
<ul>
<li>中断处理：中断（如时钟中断）通常是触发进程切换的事件。</li>
<li>内存保护和隔离：确保一个进程不能访问或修改另一个进程的内存。</li>
<li>多处理器支持：在多核系统中，可能需要处理多处理器间的同步和上下文切换。</li>
</ul>
<p><strong>总结</strong><br>进程切换是操作系统中的一个关键机制，它允许多个进程共享CPU资源。通过保存当前进程的状态并恢复下一个进程的状态，操作系统确保了进程的正确执行。虽然在底层实现上涉及复杂的硬件和软件交互，但其基本概念是保存和恢复进程的CPU状态及其内存管理信息。</p>
<ol>
<li>虚拟内存：<br>现代操作系统使用虚拟内存技术，为每个进程提供一个独立的虚拟地址空间。<br>虚拟地址空间通常包括代码段、数据段、堆段和堆栈段等。</li>
<li>页表：<br>每个进程都有自己的页表，用于映射虚拟地址到物理地址。<br>页表确保进程只能访问自己的虚拟地址空间，堆栈段也被映射到独立的物理内存区域。</li>
<li>内存管理单元 (MMU)：<br>MMU 负责将虚拟地址转换为物理地址，并根据页表设置进行访问权限检查。<br>操作系统内核设置每个进程的页表，并通过 MMU 确保进程间的内存隔离。</li>
</ol>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------------+        +----------------------+
| 进程 A 的虚拟内存空间 |        | 进程 B 的虚拟内存空间 |
+----------------------+        +----------------------+
|                      |        |                      |
|   代码段 (text)      |        |   代码段 (text)      |
|                      |        |                      |
+----------------------+        +----------------------+
|                      |        |                      |
|   数据段 (data)      |        |   数据段 (data)      |
|                      |        |                      |
+----------------------+        +----------------------+
|                      |        |                      |
|   堆段 (heap)        |        |   堆段 (heap)        |
|                      |        |                      |
+----------------------+        +----------------------+
|                      |        |                      |
|   堆栈段 (stack)     |        |   堆栈段 (stack)     |
|                      |        |                      |
+----------------------+        +----------------------+
|   内核空间           |        |   内核空间           |
+----------------------+        +----------------------+

进程 A 的页表                 进程 B 的页表
+----------------------+        +----------------------+
| 代码段映射           |        | 代码段映射           |
+----------------------+        +----------------------+
| 数据段映射           |        | 数据段映射           |
+----------------------+        +----------------------+
| 堆段映射             |        | 堆段映射             |
+----------------------+        +----------------------+
| 堆栈段映射           |        | 堆栈段映射           |
+----------------------+        +----------------------+
| 内核空间映射         |        | 内核空间映射         |
+----------------------+        +----------------------+



进程 A 的上下文                       进程 B 的上下文
+----------------------+            +----------------------+
| 寄存器值             |            | 寄存器值             |
|   RSP -> 堆栈指针     |            |   RSP -> 堆栈指针     |
|   RIP -> 指令指针     |            |   RIP -> 指令指针     |
+----------------------+            +----------------------+
| 页表基地址           |            | 页表基地址           |
+----------------------+            +----------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-页表"><a href="#2-页表" class="headerlink" title="2. 页表"></a>2. 页表</h3><p>页表是存储在内存中的。页表是虚拟内存管理的一个关键组件，用于将虚拟地址映射到物理地址。操作系统和硬件协同工作，通过内存管理单元（MMU）使用页表来执行地址转换和内存保护。</p>
<p><strong>页表的结构</strong><br>页表通常是多级结构，以减少内存消耗并提高查找效率。以下是典型的 x86-64 架构的四级页表结构：</p>
<ol>
<li>页全局目录 (PGD)：</li>
</ol>
<ul>
<li>最上级页表，包含指向页上级目录的指针。</li>
</ul>
<ol start="2">
<li>页上级目录 (PUD)：</li>
</ol>
<ul>
<li>第二级页表，包含指向页中间目录的指针。</li>
</ul>
<ol start="3">
<li>页中间目录 (PMD)：</li>
</ol>
<ul>
<li>第三级页表，包含指向页表的指针。</li>
</ul>
<ol start="4">
<li>页表 (PT)：</li>
</ol>
<ul>
<li>最低级页表，包含指向实际物理页的指针。</li>
</ul>
<p>每一级页表都包含页表项（PTE），每个页表项都指向下一级页表或实际物理内存页。</p>
<p><strong>页表的存储和访问</strong><br>页表本身存储在内存中。当进程运行时，CPU 使用内存管理单元（MMU）和控制寄存器来访问页表并进行地址转换。</p>
<p><strong>CPU 寄存器</strong></p>
<ul>
<li>CR3 寄存器：在 x86-64 架构中，CR3 寄存器包含当前活动页表（通常是页全局目录）的物理地址。当进行上下文切换时，操作系统会更新 CR3 寄存器以指向新进程的页表。</li>
</ul>
<p><strong>地址转换过程</strong></p>
<ol>
<li>虚拟地址分解：虚拟地址分为多个部分，每个部分对应于页表结构中的不同级别。</li>
<li>查找页表项：MMU 使用虚拟地址的各个部分逐级查找页表项，从 PGD 开始，直到找到最终的物理页地址。</li>
<li>访问物理内存：根据最终找到的物理页地址，访问实际的物理内存。</li>
</ol>
<p><strong>示例：四级页表地址转换</strong></p>
<p>假设虚拟地址为 0x123456789ABC：</p>
<ol>
<li>虚拟地址分解：</li>
</ol>
<ul>
<li>PGD 索引：0x1</li>
<li>PUD 索引：0x2</li>
<li>PMD 索引：0x3</li>
<li>PT 索引：0x4</li>
<li>页内偏移：0x56789ABC</li>
</ul>
<ol start="2">
<li>地址转换：</li>
</ol>
<ul>
<li>从 CR3 寄存器中获取 PGD 基地址。</li>
<li>使用 PGD 索引查找 PUD 的基地址。</li>
<li>使用 PUD 索引查找 PMD 的基地址。</li>
<li>使用 PMD 索引查找 PT 的基地址。</li>
<li>使用 PT 索引查找物理页的基地址。</li>
<li>加上页内偏移，得到最终的物理地址。</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">+-----------------------+
|      CR3 寄存器       |
| (PGD 基地址)          |
+-----------+-----------+
            |
            v
+-----------------------+      +-----------------------+
| 页全局目录 (PGD)      |      | 页表项 (PTE)          |
| +------+ +----------+ |      | +------+ +----------+ |
| | 索引 | | PUD 基地址| |      | | 索引 | | 物理页地址 | |
| +------+ +----------+ |      | +------+ +----------+ |
+-----------------------+      +-----------------------+
            |
            v
+-----------------------+
| 页上级目录 (PUD)      |
| +------+ +----------+ |
| | 索引 | | PMD 基地址| |
| +------+ +----------+ |
+-----------------------+
            |
            v
+-----------------------+
| 页中间目录 (PMD)      |
| +------+ +----------+ |
| | 索引 | | PT 基地址 | |
| +------+ +----------+ |
+-----------------------+
            |
            v
+-----------------------+
| 页表 (PT)             |
| +------+ +----------+ |
| | 索引 | | 物理页地址 | |
| +------+ +----------+ |
+-----------------------+
            |
            v
+-----------------------+
| 物理页                |
| +-------------------+ |
| | 页内偏移           | |
| +-------------------+ |
+-----------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-虚拟内存和物理内存的关系"><a href="#3-虚拟内存和物理内存的关系" class="headerlink" title="3. 虚拟内存和物理内存的关系"></a>3. 虚拟内存和物理内存的关系</h3><p>程序的堆栈段、代码段、数据段等最终都映射到物理内存上。虚拟内存管理通过页表将进程的虚拟地址空间映射到实际的物理内存地址，从而实现进程对内存的访问。</p>
<p>虚拟内存是操作系统提供的一种抽象，使每个进程看起来拥有独立的、连续的内存地址空间。实际上，这些虚拟地址通过页表映射到物理内存中的不同位置。</p>
<p><strong>虚拟内存的分段</strong><br>典型的进程虚拟地址空间包括以下几个主要段：</p>
<ol>
<li>代码段 (text segment)：</li>
</ol>
<ul>
<li>存储程序的可执行代码。</li>
<li>映射到物理内存中的只读区域，通常由操作系统和加载器负责加载。</li>
</ul>
<ol start="2">
<li>数据段 (data segment)：</li>
</ol>
<ul>
<li>存储全局变量和静态变量。</li>
<li>包括已初始化数据段和未初始化数据段（BSS）。</li>
</ul>
<ol start="3">
<li>堆段 (heap segment)：</li>
</ol>
<ul>
<li>用于动态内存分配，例如通过 malloc 等函数。</li>
<li>堆段的大小可以在程序运行时动态增长。</li>
</ul>
<ol start="4">
<li>堆栈段 (stack segment)：</li>
</ol>
<ul>
<li>用于函数调用和局部变量。</li>
<li>堆栈从高地址向低地址增长。</li>
</ul>
<p>每个进程有自己的页表，操作系统通过页表管理虚拟地址到物理地址的映射</p>
<p>页表 (Page Table)：</p>
<ul>
<li>页表是存储在物理内存中的数据结构，每个进程有自己独立的页表。</li>
<li>页表条目（PTE）包含虚拟页面和物理页面的映射信息，包括页的物理地址和访问权限。</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">进程的虚拟地址空间                    物理内存
+----------------------+            +----------------------+
| 高地址               |            |                      |
| ...                  |            |                      |
| 堆栈段 (stack)       |            |   物理页             |
| ...                  |            |   ...                |
|                      |            |   ...                |
| 堆段 (heap)          |            |                      |
| ...                  |            |   物理页             |
|                      |            |                      |
| 数据段 (data)        |            |   物理页             |
|                      |            |                      |
| 代码段 (text)        |            |   物理页             |
|                      |            |                      |
| 低地址               |            |                      |
+----------------------+            +----------------------+


虚拟地址空间                         页表                          物理内存
+-------------------+              +-------------+                +-----------------+
|                   |              | 页表项 (PTE) |                | 物理页框 (PF)   |
| 代码段 (text)     |              | +---------+ |                | +-------------+ |
| +0x0000           | --+--------> | | 物理地址 | |  +------->    | | 代码段       | |
|                   |   |          | +---------+ |  |             | +-------------+ |
+-------------------+   |          +-------------+  |             +-----------------+
|                   |   |                            |
| 数据段 (data)     |   |          +-------------+  |             +-----------------+
| +0x1000           | --+--------> | 页表项 (PTE) |  +------->    | 物理页框 (PF)   |
|                   |              | +---------+ |                | +-------------+ |
+-------------------+              | | 物理地址 | |                | | 数据段       | |
|                   |              | +---------+ |                | +-------------+ |
| 堆段 (heap)       |              +-------------+                +-----------------+
| +0x2000           |                                       |
|                   |                                       |      +-----------------+
+-------------------+              +-------------+          |      | 物理页框 (PF)   |
|                   |              | 页表项 (PTE) |          |      | +-------------+ |
| 堆栈段 (stack)    | --+--------> | +---------+ |  +------>+------>| | 堆栈段       | |
| +0x3000           |   |          | | 物理地址 | |                | +-------------+ |
|                   |   |          | +---------+ |                +-----------------+
|                   |   |          +-------------+
+-------------------+   |
                        |
+-------------------+   |
| 页表基地址       |    |
| +-------------+ |    |
| | CR3         | | --+
| +-------------+ |
+-------------------+

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-银行家调度算法"><a href="#4-银行家调度算法" class="headerlink" title="4. 银行家调度算法"></a>4. 银行家调度算法</h3><p>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/11929508.html)[https://www.cnblogs.com/wkfvawl/p/11929508.html]">https://www.cnblogs.com/wkfvawl/p/11929508.html)[https://www.cnblogs.com/wkfvawl/p/11929508.html]</a></p>
<p>（1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。<br>（2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。</p>
<p>做题的时候，列好3个矩阵。<code>max矩阵</code>即进程最大需要的资源矩阵，<code>allocation矩阵</code>即已经分配给进程的资源矩阵，<code>need矩阵</code>进程目前还需要的资源矩阵。<code>available</code>即目前还拥有的资源数量。然后就是假设分配给某个进程资源后，是否存在一个安全序列。如果存在，则系统安全。不存在，则系统 <code>可能死锁</code>。</p>
<h3 id="5-乐观锁和悲观锁"><a href="#5-乐观锁和悲观锁" class="headerlink" title="5. 乐观锁和悲观锁"></a>5. 乐观锁和悲观锁</h3><p>乐观锁和悲观锁是两种常见的并发控制机制，用于解决多线程或多进程环境下的资源竞争问题。它们在处理并发事务时的理念和实现方式有所不同。</p>
<ol>
<li>悲观锁（Pessimistic Lock）<br>悲观锁 的核心思想是对资源的并发访问持悲观态度，假设每次数据访问都会发生冲突，因此在操作数据前，必须先加锁，以防止其他事务对该数据进行修改。</li>
</ol>
<p>特点：</p>
<ul>
<li>锁定资源: 在读取或修改数据之前，对数据加锁，确保其他事务在当前事务完成之前无法访问或修改该数据。</li>
<li>实现方式: 通常通过数据库的行锁、表锁或分布式锁来实现。对于数据库操作，悲观锁的典型实现是 SELECT FOR UPDATE，这会在查询数据的同时对查询的行加上排他锁。</li>
<li>适用场景: 适用于数据争用非常激烈的场景，如同一份数据被多个事务频繁修改，锁可以避免脏读、不可重复读、幻读等问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能影响: 因为每次操作都要加锁和释放锁，可能会导致较高的性能开销，尤其是在锁定范围大、锁定时间长的情况下。<br>可能产生死锁: 如果多个事务之间的锁定顺序不当，可能会发生死锁。</li>
</ul>
<ol start="2">
<li>乐观锁（Optimistic Lock）<br>乐观锁 的核心思想是对资源的并发访问持乐观态度，假设大部分情况下不会发生冲突，因此在修改数据时不加锁，但在提交修改时会进行冲突检测。</li>
</ol>
<p>特点：</p>
<ul>
<li>无锁操作: 在读取数据时不加锁，允许其他事务并发修改数据，只有在提交时才进行冲突检测。</li>
<li>实现方式: 通常通过版本号（Version）或时间戳来实现。每次读取数据时获取当前版本号或时间戳，更新时再比较。如果提交时版本号或时间戳未发生变化，说明没有其他事务修改过数据，可以提交修改；否则，操作会失败，需要重新读取数据并尝试更新。</li>
<li>适用场景: 适用于数据争用不严重的场景，如大多数事务对同一份数据的修改概率较低的情况下，乐观锁的性能较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>处理冲突的成本: 如果事务冲突频繁，乐观锁可能导致大量重试操作，影响系统性能。</li>
<li>需要业务支持: 乐观锁通常需要业务逻辑配合，如设计表结构时引入版本号字段。</li>
</ul>
<p>总结对比</p>
<ul>
<li>锁定策略:<ul>
<li>悲观锁：假定会发生冲突，主动加锁防止其他事务修改数据。</li>
<li>乐观锁：假定不会发生冲突，不加锁，但在提交时检测冲突。</li>
</ul>
</li>
<li>适用场景:<ul>
<li>悲观锁：适用于并发写入频繁、数据冲突概率高的场景。</li>
<li>乐观锁：适用于并发写入较少、冲突概率低的场景。</li>
</ul>
</li>
<li>性能影响:<ul>
<li>悲观锁：可能带来较高的性能开销，尤其在高并发环境中。</li>
<li>乐观锁：在冲突较少的情况下性能更优，但在冲突频繁时重试会带来额外开销。</li>
</ul>
</li>
</ul>
<h3 id="6-系统调用与一般调用之间的区别"><a href="#6-系统调用与一般调用之间的区别" class="headerlink" title="6. 系统调用与一般调用之间的区别"></a>6. 系统调用与一般调用之间的区别</h3><p>系统调用（system call）与一般函数调用（function call）在计算机系统中有着不同的作用和执行方式。以下是它们的主要区别：</p>
<h4 id="1-定义与作用"><a href="#1-定义与作用" class="headerlink" title="1. 定义与作用"></a>1. <strong>定义与作用</strong></h4><ul>
<li><strong>系统调用</strong>：<ul>
<li><strong>定义</strong>：系统调用是操作系统提供的接口，通过它，用户程序可以请求操作系统执行特定的服务，例如文件操作、进程管理、内存分配、网络通信等。</li>
<li><strong>作用</strong>：系统调用使得用户空间的程序可以访问和使用操作系统内核提供的资源和服务，例如读取文件、发送网络请求、分配内存等。</li>
</ul>
</li>
<li><strong>一般调用</strong>：<ul>
<li><strong>定义</strong>：一般函数调用是在程序内部或库中调用函数，不涉及操作系统内核，只在用户空间中执行。</li>
<li><strong>作用</strong>：一般函数调用主要用于程序内部的逻辑处理和功能实现，比如数学计算、字符串操作、数据处理等。</li>
</ul>
</li>
</ul>
<h4 id="2-执行环境"><a href="#2-执行环境" class="headerlink" title="2. 执行环境"></a>2. <strong>执行环境</strong></h4><ul>
<li><strong>系统调用</strong>：<ul>
<li><strong>执行环境</strong>：系统调用需要从用户空间切换到内核空间执行。用户程序通过系统调用将请求传递给操作系统内核，操作系统内核在内核态下执行这些操作。</li>
<li><strong>权限级别</strong>：系统调用执行在更高权限的内核态（Ring 0）下，因为它需要访问硬件资源和操作系统核心功能。</li>
</ul>
</li>
<li><strong>一般调用</strong>：<ul>
<li><strong>执行环境</strong>：一般函数调用在用户空间执行，不涉及操作系统内核，不需要进行用户态到内核态的切换。</li>
<li><strong>权限级别</strong>：一般函数调用在用户态（Ring 3）下执行，只能访问用户空间的资源。</li>
</ul>
</li>
</ul>
<h4 id="3-开销"><a href="#3-开销" class="headerlink" title="3. 开销"></a>3. <strong>开销</strong></h4><ul>
<li><strong>系统调用</strong>：<ul>
<li><strong>开销</strong>：由于系统调用涉及从用户态到内核态的切换，这种上下文切换需要一定的时间和资源，因此系统调用的开销较大。</li>
<li><strong>原因</strong>：切换过程需要保存当前用户态的状态，进入内核态后执行操作，再切换回用户态，恢复状态。这一过程增加了执行时间。</li>
</ul>
</li>
<li><strong>一般调用</strong>：<ul>
<li><strong>开销</strong>：一般函数调用在同一执行上下文中进行，不涉及上下文切换，开销较小。</li>
<li><strong>原因</strong>：函数调用只需要在当前栈上保存状态（如函数参数、返回地址），然后跳转到函数的执行代码，执行完毕后返回即可。</li>
</ul>
</li>
</ul>
<h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. <strong>使用场景</strong></h4><ul>
<li><strong>系统调用</strong>：<ul>
<li><strong>使用场景</strong>：系统调用用于需要操作系统服务或资源的场景，如文件读写、进程创建与管理、网络通信等。</li>
<li><strong>示例</strong>：<code>read()</code>, <code>write()</code>, <code>fork()</code>, <code>execve()</code>, <code>open()</code>, <code>close()</code> 等。</li>
</ul>
</li>
<li><strong>一般调用</strong>：<ul>
<li><strong>使用场景</strong>：一般函数调用用于普通的程序逻辑处理，不涉及系统级资源管理。</li>
<li><strong>示例</strong>：<code>strlen()</code>, <code>printf()</code>, <code>sort()</code>, <code>math.sqrt()</code> 等。</li>
</ul>
</li>
</ul>
<h4 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. <strong>错误处理</strong></h4><ul>
<li><strong>系统调用</strong>：<ul>
<li><strong>错误处理</strong>：系统调用由于涉及硬件资源和操作系统服务，可能出现各种系统级错误，通常通过返回负值或设置 <code>errno</code> 来表示错误，需要特殊处理。</li>
</ul>
</li>
<li><strong>一般调用</strong>：<ul>
<li><strong>错误处理</strong>：一般函数调用的错误通常是程序逻辑错误或输入错误，处理方式多样，视具体情况而定。</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>系统调用</strong> 是用户程序与操作系统之间的接口，用于请求操作系统服务，涉及用户态到内核态的切换，开销较大，但允许访问和操作系统资源。</li>
<li><strong>一般函数调用</strong> 仅在用户空间执行，用于程序内部的逻辑处理和功能实现，开销较小，不涉及操作系统内核。</li>
</ul>
<p>理解系统调用和一般函数调用的区别，有助于开发者更好地优化程序性能，并正确选择和使用操作系统提供的服务。</p>
<p>系统调用可以嵌套，但需要理解嵌套调用的具体含义和实际情况。</p>
<h4 id="1-嵌套系统调用的概念"><a href="#1-嵌套系统调用的概念" class="headerlink" title="1. 嵌套系统调用的概念"></a>1. <strong>嵌套系统调用的概念</strong></h4><p><strong>嵌套系统调用</strong>指的是在一个系统调用的执行过程中，另一个系统调用被调用。例如，系统调用 A 在执行过程中，又触发了系统调用 B。</p>
<h4 id="2-实际情况"><a href="#2-实际情况" class="headerlink" title="2. 实际情况"></a>2. <strong>实际情况</strong></h4><ul>
<li><strong>内核态的嵌套</strong>：<ul>
<li>在某些复杂的操作中，操作系统内核本身可能在执行一个系统调用时，需要调用其他内核功能，这可能会触发其他系统调用。虽然从用户程序的角度看，这些调用是独立的，但内核可能会嵌套地执行它们。例如，在文件系统的实现中，打开文件（<code>open()</code>）的系统调用可能会在内核态触发其他与文件系统相关的系统调用。</li>
</ul>
</li>
<li><strong>用户态到内核态的嵌套</strong>：<ul>
<li>在典型的操作系统设计中，用户态程序可以多次调用系统调用，而这些调用可能看起来是嵌套的。但从内核的角度看，每次调用都是一个独立的上下文切换，即从用户态切换到内核态，完成调用后再返回用户态。因此，虽然用户程序中可能出现看似嵌套的系统调用，但它们在内核中通常是依次处理的。</li>
</ul>
</li>
</ul>
<h4 id="3-嵌套调用的处理方式"><a href="#3-嵌套调用的处理方式" class="headerlink" title="3. 嵌套调用的处理方式"></a>3. <strong>嵌套调用的处理方式</strong></h4><ul>
<li><strong>上下文切换</strong>：每次系统调用都会导致从用户态到内核态的上下文切换，即使是在一个系统调用内部调用另一个系统调用，这个过程也需要重新保存和恢复上下文。操作系统内核是设计来处理这样的场景的。</li>
<li><strong>重入与线程安全</strong>：大多数现代操作系统内核是重入的，这意味着多个系统调用可以同时在不同的上下文（例如不同的线程或进程）中执行，即使它们是嵌套调用。内核通过锁、原子操作等机制来确保这些调用的线程安全。</li>
</ul>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. <strong>示例</strong></h4><ul>
<li><strong>实际示例</strong>：假设你在用户程序中执行 <code>write()</code> 系统调用，这个调用会在内核中进行文件写操作。如果这个文件是网络文件系统上的一个文件，那么在 <code>write()</code> 的过程中，内核可能会进行网络数据传输，这可能需要调用另一个与网络栈相关的系统调用。</li>
</ul>
<h3 id="7-为什么页号最多占一页的容量"><a href="#7-为什么页号最多占一页的容量" class="headerlink" title="7. 为什么页号最多占一页的容量"></a>7. 为什么页号最多占一页的容量</h3><p>如果页表的大小超过了一页的容量，则无法通过一个页表索引直接访问完整的页表，这会导致分页机制失去简洁性和有效性。在这种情况下，内存管理变得复杂，页表需要额外的管理机制来处理其超过一页容量的部分，这样会降低分页系统的效率。</p>
<p>因此，页号对应的页表最多只能占一页的容量，这是为了确保分页系统的页表能够被有效地管理和分配。如果页表超过一页的容量，可能需要更复杂的多级页表或其他机制来处理，这违背了分页简化内存管理的初衷。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-跨域的问题是出于浏览器的同源策略限制"><a href="#1-跨域的问题是出于浏览器的同源策略限制" class="headerlink" title="1. 跨域的问题是出于浏览器的同源策略限制"></a>1. 跨域的问题是出于浏览器的同源策略限制</h3><p>跨域问题主要是由于<strong>浏览器的同源策略（Same-Origin Policy, SOP）</strong>导致的。同源策略是一种重要的安全机制，用来防止恶意网站通过脚本对另一个网站的数据进行未经授权的访问。</p>
<p><strong>什么是同源策略？</strong><br>同源策略规定，只有当两个 URL 具有相同的协议、域名和端口号时，它们才被认为是同源的。具体来说，同源策略的三要素是：</p>
<ul>
<li>协议：如 HTTP、HTTPS。</li>
<li>域名：如 example.com。</li>
<li>端口号：如 80（HTTP 默认端口）或 443（HTTPS 默认端口）。<br>如果两个 URL 的协议、域名和端口号都相同，它们就是同源的，否则就是跨域的。</li>
</ul>
<p><strong>跨域问题的表现</strong><br>当 Web 应用程序尝试从一个不同源的服务器请求资源时，浏览器会阻止这些请求，表现为跨域问题。例如，来自 <a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a> 的网页试图通过 JavaScript 发起一个到 <a target="_blank" rel="noopener" href="https://api.anotherdomain.com/">https://api.anotherdomain.com</a> 的请求，就会因为同源策略而被阻止。</p>
<p><strong>常见的跨域操作包括：</strong></p>
<ul>
<li>AJAX 请求：使用 XMLHttpRequest 或 fetch API 向不同源的服务器发起请求。</li>
<li>嵌入第三方资源：如在页面中嵌入来自不同源的 <code>&lt;iframe&gt;</code>、图片、脚本等。</li>
<li>访问第三方的 cookies、localStorage 等。</li>
</ul>
<p><strong>解决跨域问题的方法</strong><br>由于跨域问题是由同源策略引起的，因此解决跨域问题的核心是让浏览器信任不同源的请求。常见的解决方案包括：</p>
<ul>
<li>CORS（Cross-Origin Resource Sharing）：<br>CORS 是一种机制，允许服务器通过设置特定的 HTTP 头，来告诉浏览器允许来自其他源的请求。常见的 CORS 头包括：<ul>
<li>Access-Control-Allow-Origin: 指定允许访问资源的域名，可以是 * 表示允许所有域名访问。</li>
<li>Access-Control-Allow-Methods: 指定允许的 HTTP 方法，如 GET、POST 等。</li>
<li>Access-Control-Allow-Headers: 指定允许的 HTTP 请求头。</li>
</ul>
</li>
<li>JSONP（JSON with Padding）：<br>JSONP 是一种跨域请求的早期解决方案，通常用于 GET 请求。它通过动态创建一个 <code>&lt;script&gt; </code>标签，并将请求参数放在 URL 中。由于 <code> &lt;script&gt;</code> 标签不受同源策略的限制，因此可以绕过跨域问题。不过，JSONP 仅支持 GET 请求，且存在安全性问题，因此不推荐用于现代应用。</li>
<li>代理服务器：<br>可以通过在同源服务器上设置代理，将跨域请求转发到目标服务器。客户端向同源服务器发送请求，服务器再代为请求目标资源。这种方式能够很好地绕过浏览器的同源策略，但需要额外配置服务器。</li>
<li>服务器端渲染：<br>对于某些请求，可以在服务器端完成所有数据请求，并将结果直接渲染给客户端，从而避免浏览器端的跨域问题。</li>
</ul>
<p><strong>总结</strong><br>跨域问题源于浏览器的同源策略，旨在保护用户免受跨站点脚本攻击。通过使用 CORS、JSONP、代理服务器等技术，可以解决跨域问题，允许安全的跨域数据访问。</p>
<p><strong>只要不通过浏览器访问，就不会触发同源策略？</strong></p>
<p>同源策略（Same-Origin Policy, SOP） 是一种专门针对浏览器的安全机制。因此，只有在通过浏览器进行访问时，同源策略才会生效，限制跨源请求。如果不通过浏览器访问，比如服务器端脚本、命令行工具、移动应用、后端服务之间的通信等，则不受同源策略的限制。</p>
<p><strong>具体来说：</strong></p>
<ol>
<li>浏览器访问：</li>
</ol>
<ul>
<li>当你在浏览器中访问网页，并且该网页中的脚本尝试从不同源获取资源时，浏览器的同源策略会生效，限制这些跨域请求。</li>
<li>例如，使用 JavaScript 发起 AJAX 请求、嵌入跨域的 <code>&lt;iframe&gt;</code>、通过 JavaScript 访问 cookies 等，都会受到同源策略的限制。<br>非浏览器环境：</li>
</ul>
<ol start="2">
<li>服务器端代码：如在服务器端的 Python、Node.js、Java、PHP 等编程语言中发起的 HTTP 请求，不受同源策略的限制。服务器可以自由地与任何源通信，无需考虑同源策略。</li>
</ol>
<ul>
<li>命令行工具：如 curl、wget 等工具可以用来发起 HTTP 请求，不受同源策略限制。</li>
<li>移动应用：移动应用在请求 API 或资源时，也不受同源策略的限制，应用开发者可以自由地与不同源的服务器进行通信。</li>
</ul>
<p><strong>举个例子：</strong></p>
<ul>
<li>浏览器环境：你在 <a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a> 上运行的 JavaScript 代码尝试向 <a target="_blank" rel="noopener" href="https://api.anotherdomain.com/">https://api.anotherdomain.com</a> 发起 AJAX 请求。由于不同源，浏览器的同源策略会阻止这个请求，除非目标服务器通过 CORS 头允许该请求。</li>
<li>服务器环境：假设你在服务器端（如 Node.js）写了一段代码，通过 https.request 向 <a target="_blank" rel="noopener" href="https://api.anotherdomain.com/">https://api.anotherdomain.com</a> 发起请求。这时，这个请求不会受到同源策略的限制，可以直接进行。</li>
<li>服务器通过其他安全措施来保护资源和数据的安全，例如身份验证、授权机制、防火墙等。服务器端的安全依赖于开发者对访问控制和数据保护的管理，而不是依赖于同源策略。</li>
</ul>
<p><strong>总结</strong><br>同源策略只在浏览器环境中生效，用来保护用户的数据安全，防止跨站脚本攻击。而在非浏览器环境中，如服务器端代码、命令行工具、移动应用等，同源策略不适用，可以自由地发起跨源请求。因此，如果你的应用不涉及浏览器访问，就不需要考虑同源策略的限制。</p>
<h3 id="2-数据链路层中，哪种方法可以用于差错检测"><a href="#2-数据链路层中，哪种方法可以用于差错检测" class="headerlink" title="2. 数据链路层中，哪种方法可以用于差错检测"></a>2. 数据链路层中，哪种方法可以用于差错检测</h3><ul>
<li>奇偶检验（Parity Check）</li>
<li>循环冗余校验（Cyclic Redundancy Check, CRC）</li>
<li>校验和(CheckSum)</li>
<li>汉明码（Hamming Code）</li>
</ul>
<h3 id="3-跨域的解决方案，Nginx反向代理"><a href="#3-跨域的解决方案，Nginx反向代理" class="headerlink" title="3. 跨域的解决方案，Nginx反向代理"></a>3. 跨域的解决方案，Nginx反向代理</h3><p>正向代理是你正在用的VPN模式，即客户端通过代理访问服务器。</p>
<p>反向代理是代理服务器，也就是客户端所有的请求都会发送到Nginx服务器上，再由Nginx服务器对过来的请求进行分发。此时，所有的请求都将是同域的，因为所请求的协议+ip+端口Nginx配置的。</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
 listen       9001;
 server_name  192.168.17.129;

 location ~ &#x2F;edu&#x2F; &#123;
  proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8080
 &#125;

 location ~ &#x2F;vod&#x2F; &#123;
  proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8081
 &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="4-http的状态码有哪些"><a href="#4-http的状态码有哪些" class="headerlink" title="4. http的状态码有哪些"></a>4. http的状态码有哪些</h3><p>HTTP 状态码分为 5 类，用来表示服务器响应的不同状态。这些状态码帮助客户端了解服务器的响应结果。以下是 HTTP 状态码的分类及常见的状态码：</p>
<h5 id="1xx：信息性响应"><a href="#1xx：信息性响应" class="headerlink" title="1xx：信息性响应"></a>1xx：信息性响应</h5><p>表示请求已接收，服务器正在处理。</p>
<ul>
<li><strong>100 Continue</strong>：请求部分已成功，客户端可以继续请求。</li>
<li><strong>101 Switching Protocols</strong>：服务器同意切换协议。</li>
<li><strong>102 Processing</strong>：服务器已收到并正在处理请求，但没有响应可用。</li>
</ul>
<h5 id="2xx：成功"><a href="#2xx：成功" class="headerlink" title="2xx：成功"></a>2xx：成功</h5><p>表示请求已成功被服务器接收、理解并处理。</p>
<ul>
<li><strong>200 OK</strong>：请求成功，响应的具体内容由方法决定（如GET请求返回资源，POST请求返回结果）。</li>
<li><strong>201 Created</strong>：请求成功并导致了资源的创建。</li>
<li><strong>202 Accepted</strong>：请求已被接受，但尚未处理完。</li>
<li><strong>203 Non-Authoritative Information</strong>：请求成功，但返回的信息不是来自原始服务器，而是经过第三方。</li>
<li><strong>204 No Content</strong>：请求成功，但不返回任何内容（如删除资源操作）。</li>
<li><strong>205 Reset Content</strong>：请求成功，请求者应重置视图。</li>
<li><strong>206 Partial Content</strong>：服务器仅返回了部分资源内容（常用于断点续传或多部分下载）。</li>
</ul>
<h5 id="3xx：重定向"><a href="#3xx：重定向" class="headerlink" title="3xx：重定向"></a>3xx：重定向</h5><p>表示客户端需要进一步操作才能完成请求。</p>
<ul>
<li><strong>300 Multiple Choices</strong>：请求有多个可选的响应，客户端可以选择。</li>
<li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置。</li>
<li><strong>302 Found</strong>：临时重定向，请求的资源临时位于其他位置。</li>
<li><strong>303 See Other</strong>：请求的资源可以在另一 URI 获取，建议使用 GET 访问。</li>
<li><strong>304 Not Modified</strong>：资源未修改，客户端可以使用缓存副本。</li>
<li><strong>307 Temporary Redirect</strong>：资源临时重定向，客户端应该继续使用原来的请求方法。</li>
<li><strong>308 Permanent Redirect</strong>：资源已永久移动，和 301 类似，但客户端必须使用原请求方法。</li>
</ul>
<h5 id="4xx：客户端错误"><a href="#4xx：客户端错误" class="headerlink" title="4xx：客户端错误"></a>4xx：客户端错误</h5><p>表示请求有错误，服务器无法处理。</p>
<ul>
<li><strong>400 Bad Request</strong>：请求有语法问题，服务器无法理解。</li>
<li><strong>401 Unauthorized</strong>：请求未经授权，客户端需要提供认证。</li>
<li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行。</li>
<li><strong>404 Not Found</strong>：服务器找不到请求的资源。</li>
<li><strong>405 Method Not Allowed</strong>：请求方法不被允许（如用 POST 请求一个只能 GET 的资源）。</li>
<li><strong>406 Not Acceptable</strong>：请求的内容特性不符合客户端的请求。</li>
<li><strong>408 Request Timeout</strong>：请求超时，服务器等待客户端发送请求时间过长。</li>
<li><strong>409 Conflict</strong>：请求与资源的当前状态发生冲突。</li>
<li><strong>410 Gone</strong>：请求的资源已被永久删除，且没有转发地址。</li>
<li><strong>411 Length Required</strong>：请求缺少 <code>Content-Length</code> 头，服务器拒绝接受没有指定长度的请求。</li>
<li><strong>413 Payload Too Large</strong>：请求实体过大，服务器无法处理。</li>
<li><strong>414 URI Too Long</strong>：请求的 URI 过长，服务器无法处理。</li>
<li><strong>415 Unsupported Media Type</strong>：服务器不支持请求的媒体格式。</li>
<li><strong>429 Too Many Requests</strong>：客户端发送了太多请求，被限制。</li>
</ul>
<h5 id="5xx：服务器错误"><a href="#5xx：服务器错误" class="headerlink" title="5xx：服务器错误"></a>5xx：服务器错误</h5><p>表示服务器在处理请求时出现了错误。</p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器遇到未预料的情况，无法完成请求。</li>
<li><strong>501 Not Implemented</strong>：服务器不支持请求的方法或功能。</li>
<li><strong>502 Bad Gateway</strong>：网关或代理服务器从上游服务器收到无效响应。</li>
<li><strong>503 Service Unavailable</strong>：服务器目前无法处理请求（超负载或维护）。</li>
<li><strong>504 Gateway Timeout</strong>：网关或代理服务器未能及时从上游服务器获取响应。</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求使用的 HTTP 协议版本。</li>
</ul>
<p>每个状态码都由三位数字组成，第一位数字标识了状态的类别，后两位提供了具体的状态信息。</p>
<h3 id="5-UDP具体的使用场景"><a href="#5-UDP具体的使用场景" class="headerlink" title="5. UDP具体的使用场景"></a>5. UDP具体的使用场景</h3><p>UDP（User Datagram Protocol）是一种无连接、轻量级的传输层协议，常用于对速度和效率要求较高、但不需要严格保证数据可靠性的应用。以下是 UDP 的具体使用场景：</p>
<h4 id="1-实时-通信"><a href="#1-实时-通信" class="headerlink" title="1. 实时 通信"></a>1. <strong>实时 通信</strong></h4><p>UDP 非常适合用于需要低延迟的实时通信场景，在这些应用中，丢失一些数据包不会影响整体的用户体验。常见的应用包括：</p>
<ul>
<li><strong>VoIP（Voice over IP）</strong>：语音通话，例如 Skype、Zoom。实时语音传输需要低延迟，即使少量语音数据丢失也不会明显影响对话。</li>
<li><strong>视频通话</strong>：视频通话也对延迟敏感，少量的丢包或抖动不会严重影响用户体验。</li>
</ul>
<h4 id="2-实时视频流传输"><a href="#2-实时视频流传输" class="headerlink" title="2. 实时视频流传输"></a>2. <strong>实时视频流传输</strong></h4><p>在视频流媒体传输中，例如在线直播、IPTV、游戏直播等，实时性至关重要。UDP 可以快速传输视频帧，而不会像 TCP 那样因为丢包导致整体传输延迟。典型的协议有：</p>
<ul>
<li><strong>RTSP（Real-Time Streaming Protocol）</strong>：常用于实时视频流传输，底层通常使用 UDP 来减少延迟。</li>
<li><strong>RTP（Real-Time Transport Protocol）</strong>：视频和音频流媒体传输协议，通常使用 UDP 来实现低延迟传输。</li>
</ul>
<h4 id="3-在线游戏"><a href="#3-在线游戏" class="headerlink" title="3. 在线游戏"></a>3. <strong>在线游戏</strong></h4><ul>
<li>在多人在线游戏中，快速响应比数据完整性更重要。UDP 能够提供低延迟的通信，游戏服务器可以周期性地发送更新（如玩家的位置、状态等）。即使丢失某些数据包，游戏客户端也能通过后续的更新恢复正常状态。例如：<ul>
<li><strong>射击游戏（FPS）</strong></li>
<li><strong>竞技类游戏（MOBA）</strong></li>
</ul>
</li>
<li>这些游戏中，掉帧或者丢失少量状态信息不会影响游戏进程，UDP 的传输效率更能满足快速更新的需求。</li>
</ul>
<h4 id="4-广播和多播"><a href="#4-广播和多播" class="headerlink" title="4. 广播和多播"></a>4. <strong>广播和多播</strong></h4><p>UDP 支持多播（Multicast）和广播（Broadcast），非常适合应用在需要同时向多个终端发送相同数据的场景，例如：</p>
<ul>
<li><strong>IPTV</strong>：通过多播向多个用户发送电视信号流。</li>
<li><strong>局域网内的服务发现</strong>：设备在局域网内通过广播发送查询请求，如常见的 DHCP、UPnP 等协议使用 UDP 来在局域网内快速发现可用服务。</li>
<li><strong>在线教学</strong>：教师向多个学生广播数据流（如音视频）。</li>
</ul>
<h4 id="5-DNS-查询"><a href="#5-DNS-查询" class="headerlink" title="5. DNS 查询"></a>5. <strong>DNS 查询</strong></h4><ul>
<li><strong>DNS（Domain Name System）</strong>：互联网中的域名解析通常使用 UDP 进行 DNS 查询，因为大多数查询和响应的数据量较小，使用 UDP 可以降低延迟。对于超过 512 字节的查询，DNS 可以使用 TCP，但通常的域名解析都是通过 UDP 实现的。</li>
</ul>
<h4 id="6-简单的请求-响应协议"><a href="#6-简单的请求-响应协议" class="headerlink" title="6. 简单的请求-响应协议"></a>6. <strong>简单的请求-响应协议</strong></h4><ul>
<li>例如 <strong>TFTP（Trivial File Transfer Protocol）</strong>，是一种简单的文件传输协议，常用于网络设备的固件升级、系统配置文件传输等。它的实现基于 UDP，牺牲了一些可靠性来提升传输效率。</li>
</ul>
<h4 id="7-物联网（IoT）设备通信"><a href="#7-物联网（IoT）设备通信" class="headerlink" title="7. 物联网（IoT）设备通信"></a>7. <strong>物联网（IoT）设备通信</strong></h4><ul>
<li>物联网设备通常受限于网络带宽、计算能力和电源限制。UDP 协议可以通过减少开销来提高传输效率。某些轻量级的通信协议，如 <strong>CoAP（Constrained Application Protocol）</strong>，使用 UDP 来提供低资源占用的通信方式，常用于传感器、嵌入式设备等物联网设备的通信。</li>
</ul>
<h4 id="8-局域网（LAN）通信"><a href="#8-局域网（LAN）通信" class="headerlink" title="8. 局域网（LAN）通信"></a>8. <strong>局域网（LAN）通信</strong></h4><ul>
<li>在局域网内传输数据时，由于网络环境较为可靠，UDP 可以实现高速的数据交换。例如局域网内的文件共享、打印机的状态更新等，UDP 可以减少传输延迟和开销。</li>
</ul>
<h4 id="9-DHCP（动态主机配置协议）"><a href="#9-DHCP（动态主机配置协议）" class="headerlink" title="9. DHCP（动态主机配置协议）"></a>9. <strong>DHCP（动态主机配置协议）</strong></h4><ul>
<li><strong>DHCP（Dynamic Host Configuration Protocol）</strong> 通过 UDP 协议向网络设备分配 IP 地址。DHCP 使用 UDP 是因为它需要通过广播方式找到网络中的设备，并与它们交换数据，而 TCP 的连接建立方式不适合这种应用场景。</li>
</ul>
<h4 id="10-SNMP（简单网络管理协议）"><a href="#10-SNMP（简单网络管理协议）" class="headerlink" title="10. SNMP（简单网络管理协议）"></a>10. <strong>SNMP（简单网络管理协议）</strong></h4><ul>
<li><strong>SNMP（Simple Network Management Protocol）</strong> 是网络管理中常用的协议，通常使用 UDP 作为传输层协议。SNMP 需要快速地获取网络设备的状态或进行配置更新，因此 UDP 的轻量特性很适合这种快速、低开销的操作。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>UDP 的特点是 <strong>无连接、低延迟、低开销</strong>，但它不提供可靠性保证，因此适合需要实时性或广播、多播传输的场景。典型的应用场景包括 <strong>实时通信（如语音、视频通话）</strong>、<strong>在线游戏</strong>、<strong>视频流</strong>、<strong>物联网</strong>等。UDP 的设计使其能够快速传输数据，即使在丢包情况下，也不会像 TCP 那样影响整体传输速度，因此它广泛用于对数据完整性要求较低、但对速度和实时性要求较高的网络通信中。</p>
<h3 id="6-http为什么是无状态的，说说你的理解"><a href="#6-http为什么是无状态的，说说你的理解" class="headerlink" title="6. http为什么是无状态的，说说你的理解"></a>6. http为什么是无状态的，说说你的理解</h3><p>HTTP（Hypertext Transfer Protocol）被称为<strong>无状态协议</strong>，这意味着它在每次请求之间<strong>不会保留任何关于客户端的状态</strong>。服务器和客户端之间的每个请求都是独立的，与之前或之后的请求无关。</p>
<h4 id="我的理解："><a href="#我的理解：" class="headerlink" title="我的理解："></a>我的理解：</h4><ol>
<li><strong>无状态的本质</strong>： 每个 HTTP 请求都是<strong>独立的事务</strong>，服务器在处理每个请求时，不会自动记住之前发生的任何事情。换句话说，服务器不会记住用户在上一个请求中提交了什么数据，也不会跟踪会话信息。</li>
<li><strong>为什么 HTTP 是无状态的？</strong><ul>
<li><strong>简化设计</strong>：无状态协议的设计更简单，不需要服务器维护大量的会话数据，这大大简化了服务器的实现。</li>
<li><strong>更好的扩展性</strong>：由于服务器不需要保存每个客户端的状态，多个服务器可以在集群中分布式处理请求，提升扩展性。这使得 HTTP 特别适合于互联网的大规模应用。</li>
<li><strong>灵活性</strong>：每个请求可以被不同的服务器处理，客户端和服务器之间的连接是短暂的。它允许通过代理、缓存等方式更高效地分发和处理请求。</li>
</ul>
</li>
<li><strong>无状态的挑战与解决方案</strong>：<ul>
<li><strong>状态管理的需求</strong>：尽管 HTTP 是无状态的，但很多 web 应用（如购物车、登录会话等）需要管理用户的状态。为了解决这个问题，引入了 <strong>cookie</strong>、<strong>session</strong>、<strong>token</strong> 等机制。这些机制使得服务器和客户端能够在多个请求之间共享状态信息。</li>
<li><strong>Cookie</strong>：服务器通过在响应中发送一个 <code>Set-Cookie</code> 头，将状态信息存储在客户端浏览器中，客户端在后续的请求中会自动带上这个 cookie，服务器可以通过它识别客户端。</li>
<li><strong>Session</strong>：服务器可以在每次请求后生成一个唯一的会话标识符（如 <code>session_id</code>），并通过 <code>cookie</code> 或 <code>URL</code> 将它传递给客户端。客户端每次请求时会带上这个 ID，服务器就可以通过它来恢复客户端的状态。</li>
<li><strong>Token</strong>：常见于 REST API 和现代认证机制（如 JWT）。服务器通过签发一个加密的 token，客户端会在后续的请求中通过 HTTP 头（如 <code>Authorization</code>）传递 token，服务器通过解密这个 token 获取用户状态。</li>
</ul>
</li>
</ol>
<h4 id="实际场景下的无状态："><a href="#实际场景下的无状态：" class="headerlink" title="实际场景下的无状态："></a>实际场景下的无状态：</h4><ul>
<li>每次访问网页或资源时，浏览器会发送一个请求到服务器。服务器处理完请求后，返回响应，然后结束与客户端的交互。下次用户再访问同一个页面时，服务器不会“记住”之前访问的内容，必须依赖客户端发送的信息，如 cookie 或 session ID，来保持一些持久化的状态。</li>
<li>例如，用户打开一个电商网站，向购物车中添加商品时，服务器并不会自动记住用户之前的商品添加情况。购物车的状态需要依赖某种机制（如 session 或 cookie）来管理。</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>HTTP 无状态的设计让它能够在网络上实现更简洁、灵活、扩展性强的通信模型，但为了满足实际应用中状态管理的需求，使用了 cookie、session、token 等机制来弥补这一特性。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1. KMP算法"></a>1. KMP算法</h3><p>这个我觉得讲的最清楚。<br>(<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)[https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html]">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)[https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html]</a></p>
<h3 id="2-二叉排序树"><a href="#2-二叉排序树" class="headerlink" title="2. 二叉排序树"></a>2. 二叉排序树</h3><p>二叉排序树（Binary Search Tree, BST），也称为二叉查找树，是一种特殊的二叉树结构，它具有以下性质：</p>
<p><strong>二叉排序树的性质</strong></p>
<ul>
<li>节点的左子树：对于树中的任意一个节点，其左子树中所有节点的值都小于该节点的值。</li>
<li>节点的右子树：对于树中的任意一个节点，其右子树中所有节点的值都大于该节点的值。</li>
<li>每个子树都是二叉排序树：左子树和右子树本身也是二叉排序树，这使得整个树递归地满足二叉排序树的性质。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-JOIN"><a href="#1-JOIN" class="headerlink" title="1. JOIN"></a>1. JOIN</h3><p>我们可以通过两个简单的表来演示不同类型的 SQL JOIN。</p>
<p>假设有两个表 <code>Customers</code> 和 <code>Orders</code>：</p>
<p><strong>Customers 表：</strong></p>
<table>
<thead>
<tr>
<th>CustomerID</th>
<th>CustomerName</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
</tr>
<tr>
<td>3</td>
<td>Charlie</td>
</tr>
</tbody></table>
<p><strong>Orders 表：</strong></p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>CustomerID</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>1</td>
<td>Book</td>
</tr>
<tr>
<td>102</td>
<td>2</td>
<td>Pen</td>
</tr>
<tr>
<td>103</td>
<td>4</td>
<td>Notebook</td>
</tr>
</tbody></table>
<h5 id="1-INNER-JOIN-示例"><a href="#1-INNER-JOIN-示例" class="headerlink" title="1. INNER JOIN 示例"></a>1. INNER JOIN 示例</h5><pre class="line-numbers language-none"><code class="language-none">SELECT Customers.CustomerID, Customers.CustomerName, Orders.Product
FROM Customers
INNER JOIN Orders ON Customers.CustomerID &#x3D; Orders.CustomerID;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>CustomerID</th>
<th>CustomerName</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>Book</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>Pen</td>
</tr>
</tbody></table>
<p><strong>解释：</strong> INNER JOIN 只返回两个表中都有匹配行的记录。因为 <code>CustomerID = 3</code> 的 Charlie 没有对应的订单，<code>CustomerID = 4</code> 的订单也没有对应的客户，所以这些行不会出现在结果中。</p>
<h5 id="2-LEFT-JOIN-示例"><a href="#2-LEFT-JOIN-示例" class="headerlink" title="2. LEFT JOIN 示例"></a>2. LEFT JOIN 示例</h5><pre class="line-numbers language-none"><code class="language-none">SELECT Customers.CustomerID, Customers.CustomerName, Orders.Product
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID &#x3D; Orders.CustomerID;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>CustomerID</th>
<th>CustomerName</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>Book</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>Pen</td>
</tr>
<tr>
<td>3</td>
<td>Charlie</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong>解释：</strong> LEFT JOIN 返回左表中的所有记录，即使右表中没有匹配的记录。因为 Charlie 没有订单，所以他的 <code>Product</code> 列为 <code>NULL</code>。</p>
<h5 id="3-RIGHT-JOIN-示例"><a href="#3-RIGHT-JOIN-示例" class="headerlink" title="3. RIGHT JOIN 示例"></a>3. RIGHT JOIN 示例</h5><pre class="line-numbers language-none"><code class="language-none">SELECT Customers.CustomerID, Customers.CustomerName, Orders.Product
FROM Customers
RIGHT JOIN Orders ON Customers.CustomerID &#x3D; Orders.CustomerID;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>CustomerID</th>
<th>CustomerName</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>Book</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>Pen</td>
</tr>
<tr>
<td>4</td>
<td>NULL</td>
<td>Notebook</td>
</tr>
</tbody></table>
<p><strong>解释：</strong> RIGHT JOIN 返回右表中的所有记录，即使左表中没有匹配的记录。因为 <code>OrderID = 4</code> 的订单没有对应的客户，所以 <code>CustomerName</code> 列为 <code>NULL</code>。</p>
<h5 id="4-FULL-JOIN-示例"><a href="#4-FULL-JOIN-示例" class="headerlink" title="4. FULL JOIN 示例"></a>4. FULL JOIN 示例</h5><pre class="line-numbers language-none"><code class="language-none">SELECT Customers.CustomerID, Customers.CustomerName, Orders.Product
FROM Customers
FULL JOIN Orders ON Customers.CustomerID &#x3D; Orders.CustomerID;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>CustomerID</th>
<th>CustomerName</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>Book</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>Pen</td>
</tr>
<tr>
<td>3</td>
<td>Charlie</td>
<td>NULL</td>
</tr>
<tr>
<td>4</td>
<td>NULL</td>
<td>Notebook</td>
</tr>
</tbody></table>
<p><strong>解释：</strong> FULL JOIN 返回两个表中的所有记录。对于没有匹配的记录，会显示 <code>NULL</code>。所以，Charlie 没有订单，Order 101 没有对应的客户，结果中都显示 <code>NULL</code>。</p>
<h3 id="2-索引的作用"><a href="#2-索引的作用" class="headerlink" title="2. 索引的作用"></a>2. 索引的作用</h3><h4 id="示例场景："><a href="#示例场景：" class="headerlink" title="示例场景："></a>示例场景：</h4><p>假设我们有一个名为 <code>employees</code> 的表，用于存储公司员工的信息，表结构如下：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10, 2)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，<code>employee_id</code> 是主键，代表每个员工的唯一标识。</p>
<h4 id="没有索引的查询："><a href="#没有索引的查询：" class="headerlink" title="没有索引的查询："></a>没有索引的查询：</h4><p>假设这个表里有一百万条记录，现在你想查询所有姓为 “Smith” 的员工：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM employees WHERE last_name &#x3D; &#39;Smith&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>没有索引的情况下</strong>，数据库必须对整个 <code>employees</code> 表进行全表扫描（Full Table Scan），也就是从第一条记录一直到最后一条记录，逐条检查 <code>last_name</code> 是否等于 “Smith”。</p>
<ul>
<li><strong>全表扫描的代价</strong>：对于一百万条记录，可能需要遍历所有的记录，时间复杂度为 O(n)，查询速度会非常慢，特别是在大表中。</li>
</ul>
<h4 id="建立索引："><a href="#建立索引：" class="headerlink" title="建立索引："></a>建立索引：</h4><p>为了加速这个查询，我们可以在 <code>last_name</code> 列上创建一个索引：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE INDEX idx_last_name ON employees(last_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>索引创建之后</strong>，数据库会在后台构建一个数据结构（例如 B-树），以 <code>last_name</code> 作为键来排序和存储记录的位置指针。</p>
<h4 id="有索引的查询："><a href="#有索引的查询：" class="headerlink" title="有索引的查询："></a>有索引的查询：</h4><p>再执行相同的查询：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM employees WHERE last_name &#x3D; &#39;Smith&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>有索引的情况下</strong>，查询过程如下：</p>
<ol>
<li><strong>查询索引</strong>：数据库首先查询 <code>idx_last_name</code> 索引，利用索引的排序特性，快速定位到所有 <code>last_name</code> 为 “Smith” 的记录。对于 B-树结构，查找的时间复杂度为 O(log n)。</li>
<li><strong>获取记录</strong>：找到符合条件的索引后，数据库通过索引中的指针直接访问对应的记录，而不需要扫描整个表。</li>
</ol>
<ul>
<li><strong>结果</strong>：通过索引，数据库可以极大地减少需要扫描的记录数，查询速度大幅提升，特别是在大表中。</li>
</ul>
<h4 id="索引的实际作用："><a href="#索引的实际作用：" class="headerlink" title="索引的实际作用："></a>索引的实际作用：</h4><p>为了更好理解，我们假设 <code>employees</code> 表的 <code>last_name</code> 列包含以下示例数据：</p>
<pre class="line-numbers language-none"><code class="language-none">| employee_id | first_name | last_name | department | salary  |
|-------------|------------|-----------|------------|---------|
| 1           | John       | Smith     | HR         | 50000.00|
| 2           | Alice      | Johnson   | IT         | 60000.00|
| 3           | Bob        | Smith     | Finance    | 55000.00|
| ...         | ...        | ...       | ...        | ...     |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>没有索引时</strong>：数据库从头开始扫描每一条记录，即使找到了匹配的记录（如 John Smith），它仍然必须继续扫描所有记录以确保找到所有匹配项。</li>
<li><strong>有索引时</strong>：数据库直接跳转到 <code>Smith</code> 这个位置开始检索，并且因为索引是排序的，能够快速定位所有 <code>Smith</code> 的记录。</li>
</ul>
<h4 id="其他类型的索引："><a href="#其他类型的索引：" class="headerlink" title="其他类型的索引："></a>其他类型的索引：</h4><h4 id="1-主键索引："><a href="#1-主键索引：" class="headerlink" title="1. 主键索引："></a>1. <strong>主键索引</strong>：</h4><ul>
<li><strong>自动创建</strong>：当你为表创建一个主键时，数据库会自动为这个主键创建一个唯一索引。例如，<code>employee_id</code> 列上默认有主键索引，所有基于 <code>employee_id</code> 的查询都会非常快。</li>
</ul>
<h4 id="2-联合索引（复合索引）："><a href="#2-联合索引（复合索引）：" class="headerlink" title="2. 联合索引（复合索引）："></a>2. <strong>联合索引（复合索引）</strong>：</h4><ul>
<li><p>示例：如果经常查询包含department和last_name的条件，可以创建一个联合索引：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE INDEX idx_dept_last_name ON employees(department, last_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>效果：这个索引会优化查询，例如：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM employees WHERE department &#x3D; &#39;IT&#39; AND last_name &#x3D; &#39;Smith&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><strong>原理</strong>：数据库会先根据 <code>department</code> 查找，再根据 <code>last_name</code> 进一步过滤，查询效率更高。</p>
</li>
</ul>
<h4 id="索引的代价："><a href="#索引的代价：" class="headerlink" title="索引的代价："></a>索引的代价：</h4><p>虽然索引提高了查询效率，但也有一定的代价：</p>
<ol>
<li><strong>存储开销</strong>：索引占用额外的存储空间。如果表中的数据量非常大，索引也会占用大量磁盘空间。</li>
<li><strong>维护开销</strong>：在插入、更新或删除记录时，数据库不仅需要修改表中的数据，还需要更新相关的索引。这会增加写操作的时间成本。</li>
</ol>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><strong>索引的优势</strong>：主要在于提高查询速度，特别是在大数据集上，可以显著减少查询时间。</li>
<li><strong>索引的选择</strong>：应基于查询的频率和类型来决定在哪些列上建立索引。通常，在经常用于查询条件的列（如 <code>WHERE</code>、<code>JOIN</code> 等操作的列）上建立索引，可以带来明显的性能提升。</li>
</ul>
<p>通过这个例子，可以清楚地看到索引在提高数据库查询效率方面的作用，以及它的工作原理。</p>
<h3 id="3-一条查询语句在MySql服务端的执行过程"><a href="#3-一条查询语句在MySql服务端的执行过程" class="headerlink" title="3. 一条查询语句在MySql服务端的执行过程"></a>3. 一条查询语句在MySql服务端的执行过程</h3><p><img src="https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/20240818100418.png" alt="20240818100418"></p>
<h3 id="4-TPS-Transactions-Per-Second"><a href="#4-TPS-Transactions-Per-Second" class="headerlink" title="4. TPS Transactions Per Second"></a>4. TPS Transactions Per Second</h3><p>在数据库系统中，TPS 是 Transactions Per Second 的缩写，指的是系统每秒能够处理的事务数。它是衡量数据库系统性能的重要指标，特别是在高并发场景下。</p>
<p>什么是事务（Transaction）？<br>事务是数据库操作的一个逻辑单元，它通常包括一组数据库操作（如读取、写入、更新、删除），这些操作要么全部成功，要么全部失败。事务通常遵循 ACID 特性：</p>
<ul>
<li>Atomicity（原子性）: 事务的所有操作要么全部完成，要么全部回滚。</li>
<li>Consistency（一致性）: 事务完成后，数据库必须从一个一致性状态转换到另一个一致性状态。</li>
<li>Isolation（隔离性）: 事务之间互不干扰，一个事务的执行不会影响其他事务。</li>
<li>Durability（持久性）: 事务一旦提交，数据的变更是永久性的，即使系统崩溃也不会丢失。</li>
</ul>
<p>TPS 的含义：</p>
<ul>
<li>TPS 表示每秒可以执行的事务数量，通常用于评估数据库系统在高并发环境下的性能。</li>
<li>TPS 值越高，意味着系统在相同时间内能够处理的事务数量越多，表明系统的处理能力更强。</li>
<li>TPS 是数据库性能测试中的关键指标，通常与系统的响应时间、延迟、吞吐量等指标一起使用，全面反映数据库的运行效率。</li>
</ul>
<h3 id="5-数据库的聚簇索引和非聚簇索引的区别"><a href="#5-数据库的聚簇索引和非聚簇索引的区别" class="headerlink" title="5. 数据库的聚簇索引和非聚簇索引的区别"></a>5. 数据库的聚簇索引和非聚簇索引的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>聚簇索引（Clustered Index）</th>
<th>非聚簇索引（Non-clustered Index）</th>
</tr>
</thead>
<tbody><tr>
<td>数据物理存储顺序</td>
<td>数据按照索引键值排序存储</td>
<td>数据存储顺序与索引无关</td>
</tr>
<tr>
<td>索引结构</td>
<td>索引的叶子节点是数据行</td>
<td>索引的叶子节点是指向数据的指针</td>
</tr>
<tr>
<td>数据检索效率</td>
<td>检索速度更快（不需要回表）</td>
<td>检索较慢，需要回表</td>
</tr>
<tr>
<td>适用场景</td>
<td>范围查询或排序</td>
<td>精确查找或多字段查询</td>
</tr>
<tr>
<td>插入和更新性能</td>
<td>较低（数据可能需要重排）</td>
<td>较高</td>
</tr>
<tr>
<td>一个表的数量限制</td>
<td>一个表只能有一个聚簇索引</td>
<td>一个表可以有多个非聚簇索引</td>
</tr>
</tbody></table>
<p>数据库在查询某一行数据时，不会逐个字段进行匹配，而是通过<strong>索引</strong>加速查找。如果没有索引，则会使用全表扫描来逐行检查，这种情况下才会逐个字段进行匹配操作。</p>
<p>你在一个电子商务平台的数据库里有一张 <code>Orders</code> 表，用于存储订单信息。表结构如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Orders <span class="token punctuation">(</span>
    OrderID <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    CustomerID <span class="token keyword">INT</span><span class="token punctuation">,</span>
    OrderDate <span class="token keyword">DATE</span><span class="token punctuation">,</span>
    TotalAmount <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>OrderID</code> 是每个订单的唯一标识，<code>OrderDate</code> 是订单的日期，<code>CustomerID</code> 是客户的编号，<code>TotalAmount</code> 是订单的总金额。</p>
<h4 id="聚簇索引的情况"><a href="#聚簇索引的情况" class="headerlink" title="聚簇索引的情况"></a>聚簇索引的情况</h4><p>我们可以为 <code>OrderID</code> 字段创建一个 <strong>聚簇索引</strong>，因为每个订单都有唯一的 <code>OrderID</code>，并且可以根据这个字段经常进行查找。由于 <code>OrderID</code> 是主键，数据库系统一般会自动为主键创建一个聚簇索引：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Orders <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>OrderID<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p><strong>物理存储</strong>：创建了聚簇索引后，<code>Orders</code> 表中的数据将按照 <code>OrderID</code> 的顺序在磁盘上物理存储。如果你查看硬盘上的数据文件，你会看到订单数据是按照 <code>OrderID</code> 排序存储的。</p>
</li>
<li><p><strong>查询效率</strong>：当你使用 <code>OrderID</code> 进行查询时，比如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Orders <span class="token keyword">WHERE</span> OrderID <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为 <code>OrderID</code> 是聚簇索引，数据库可以直接通过索引找到相应的数据行，不需要额外步骤。数据行就是索引的叶子节点，查询速度非常快。</p>
</li>
<li><p><strong>缺点</strong>：如果你频繁按 <code>OrderID</code> 顺序插入新订单，数据库需要不断地重新排列存储数据，可能会影响插入性能。</p>
</li>
</ul>
<h4 id="非聚簇索引的情况"><a href="#非聚簇索引的情况" class="headerlink" title="非聚簇索引的情况"></a>非聚簇索引的情况</h4><p>现在你发现你经常需要按 <code>OrderDate</code> 查询订单，比如按日期范围查询过去某一天的订单。因此你为 <code>OrderDate</code> 创建了一个 <strong>非聚簇索引</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_order_date <span class="token keyword">ON</span> Orders <span class="token punctuation">(</span>OrderDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p><strong>物理存储</strong>：在创建非聚簇索引后，数据库并不会改变数据的物理存储顺序（它依然按 <code>OrderID</code> 存储）。但是，数据库会为 <code>OrderDate</code> 创建一个额外的索引结构。这个索引结构中包含 <code>OrderDate</code> 和 <code>OrderID</code>（指向数据行的地址），并且是按 <code>OrderDate</code> 排序的。</p>
</li>
<li><p><strong>查询效率</strong>：当你使用 <code>OrderDate</code> 进行查询时，比如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Orders <span class="token keyword">WHERE</span> OrderDate <span class="token operator">=</span> <span class="token string">'2024-10-03'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>数据库会先在 <code>OrderDate</code> 的非聚簇索引中查找符合条件的 <code>OrderDate</code> 值，然后通过 <code>OrderID</code> 指针找到实际的数据行。这种查找过程会涉及两步：先通过索引找到指针，再通过指针找到数据行，这就是“回表”的过程。</p>
</li>
<li><p><strong>缺点</strong>：相比聚簇索引，非聚簇索引的查询性能稍差，因为它需要回表操作。</p>
</li>
<li></li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><h2 id="Linux系统使用"><a href="#Linux系统使用" class="headerlink" title="Linux系统使用"></a>Linux系统使用</h2><h3 id="1-文件权限"><a href="#1-文件权限" class="headerlink" title="1. 文件权限"></a>1. 文件权限</h3><p>在 Linux 和类 Unix 操作系统中，每个文件和目录都有一组权限，用来控制谁可以读取、写入或执行该文件或目录。这些权限可以帮助系统管理员确保只有授权的用户能够访问或修改系统中的文件和目录。</p>
<h4 id="文件权限的基本概念"><a href="#文件权限的基本概念" class="headerlink" title="文件权限的基本概念"></a>文件权限的基本概念</h4><p>文件权限分为三种类型，分别对应三类用户：</p>
<ol>
<li><strong>用户（User / Owner）</strong>: 文件的所有者。</li>
<li><strong>组（Group）</strong>: 拥有访问权限的用户组，文件所有者可以指定文件所属的用户组。</li>
<li><strong>其他用户（Others）</strong>: 既不属于文件所有者，也不属于文件所属的组的所有其他用户。</li>
</ol>
<h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><p>对于每种用户类型，有三种基本权限：</p>
<ol>
<li><strong>读取（Read, <code>r</code>）</strong>: 允许查看文件内容或列出目录内容。</li>
<li><strong>写入（Write, <code>w</code>）</strong>: 允许修改文件内容或在目录中创建、删除文件。</li>
<li><strong>执行（Execute, <code>x</code>）</strong>: 允许执行文件（如果是可执行程序或脚本），或者进入目录。</li>
</ol>
<h4 id="权限表示法"><a href="#权限表示法" class="headerlink" title="权限表示法"></a>权限表示法</h4><p>权限可以通过两种方式表示：符号表示法和八进制表示法。</p>
<h5 id="1-符号表示法"><a href="#1-符号表示法" class="headerlink" title="1. 符号表示法"></a>1. 符号表示法</h5><p>权限通常用 <code>r</code>, <code>w</code>, <code>x</code> 来表示，例如：</p>
<ul>
<li>```<br>rwxr-xr–<pre class="line-numbers language-none"><code class="language-none">
  - &#96;rwx&#96;: 用户（Owner）拥有读取、写入和执行权限。
  - &#96;r-x&#96;: 组（Group）拥有读取和执行权限。
  - &#96;r--&#96;: 其他用户（Others）只有读取权限。

这个表示法分为三组，每组三个字符，分别对应用户、组和其他用户的权限。

##### 2. 八进制表示法

权限也可以用一个三位的八进制数来表示，其中每位代表一组权限：

- &#96;4&#96; 代表 &#96;r&#96; (读取权限)
- &#96;2&#96; 代表 &#96;w&#96; (写入权限)
- &#96;1&#96; 代表 &#96;x&#96; (执行权限)

例如，&#96;rwxr-xr--&#96; 可以用八进制表示为 &#96;755&#96;：

- 用户（Owner）：&#96;rwx&#96; &#x3D; 4 + 2 + 1 &#x3D; 7
- 组（Group）：&#96;r-x&#96; &#x3D; 4 + 0 + 1 &#x3D; 5
- 其他用户（Others）：&#96;r--&#96; &#x3D; 4 + 0 + 0 &#x3D; 4

所以 &#96;rwxr-xr--&#96; 对应的八进制权限是 &#96;755&#96;。

**查找某个目录下没有执行权限的js文件**

&#96;&#96;&#96;bash
find &#x2F;path&#x2F;to&#x2F;directory -name &quot;*.js&quot; ! -perm &#x2F;u&#x3D;x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="2-限制某个用户使用cpu的时长"><a href="#2-限制某个用户使用cpu的时长" class="headerlink" title="2. 限制某个用户使用cpu的时长"></a>2. 限制某个用户使用cpu的时长</h3><p><code> ulimit -t 3600</code></p>
<h3 id="3-显示test-c中包含main的行"><a href="#3-显示test-c中包含main的行" class="headerlink" title="3. 显示test.c中包含main的行"></a>3. 显示test.c中包含main的行</h3><p><code>grep &#39;main&#39; test.c</code></p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="1-pipe管道"><a href="#1-pipe管道" class="headerlink" title="1. pipe管道"></a>1. pipe管道</h4><p><code>buf[n] = &quot;\0&quot;; </code>这里要注意，你写入 <code>buf[n]</code>的数据是一个指向 <code>&quot;\0&quot;</code>的指针。而不是你想要的 <code>\0</code>，所以在标准输入台输出的时候，会显示乱码。需要换成 <code>buf[n] = &#39;\0&#39;</code>这样才能算作是字符串的结束标志。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pipe_fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//子进程</span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//close write of pipe_fd</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            buf<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"\0"</span><span class="token punctuation">;</span> <span class="token comment">// 这里要注意</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"subprocess read data:%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close read of pipe_fd</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> msg <span class="token operator">=</span> <span class="token string">"Hello from parent process!"</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipe_fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-socketpair"><a href="#2-socketpair" class="headerlink" title="2. socketpair"></a>2. socketpair</h4><p><code>socketpair</code> 是一种用于在两个进程（例如父进程和子进程）之间创建<strong>双向通信通道</strong>的技术。它创建了一对相互连接的套接字（socket），使得两个进程可以通过文件描述符来进行数据读写，类似于管道（pipe），但 <code>socketpair</code> 提供了<strong>全双工</strong>的通信，即两个进程可以同时读写，而不仅仅是单向的。</p>
<h5 id="socketpair-的技术要点："><a href="#socketpair-的技术要点：" class="headerlink" title="socketpair 的技术要点："></a><code>socketpair</code> 的技术要点：</h5><ul>
<li><strong>通信协议</strong>：<code>socketpair</code> 使用 UNIX 域套接字 (<code>AF_UNIX</code>) 进行本地进程间通信。这种通信机制适用于同一台机器上的进程间通信，而不是基于网络的进程通信。</li>
<li><strong>双向通信</strong>：<code>socketpair</code> 与 <code>pipe</code> 不同，管道通常是单向的，而 <code>socketpair</code> 是双向的。每个文件描述符都可以读写数据，两个进程之间能够相互通信。</li>
<li><strong>阻塞与非阻塞</strong>：<code>socketpair</code> 可以工作在阻塞或非阻塞模式下。默认情况下，它是阻塞的，也就是说，如果某一端没有准备好读取数据，写入数据的进程可能会被阻塞。</li>
</ul>
<h5 id="socketpair-的函数签名："><a href="#socketpair-的函数签名：" class="headerlink" title="socketpair 的函数签名："></a><code>socketpair</code> 的函数签名：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socketpair</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> sv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>domain</code>: 通信域，通常使用 <code>AF_UNIX</code>，即 UNIX 域套接字，用于本地进程间通信。</li>
<li><code>type</code>: 套接字类型，常见的有 <code>SOCK_STREAM</code>（流式套接字）和 <code>SOCK_DGRAM</code>（数据报套接字）。流式套接字提供面向连接的字节流通信，类似于 TCP。</li>
<li><code>protocol</code>: 通常设置为 0，表示使用默认协议。</li>
<li><code>sv[2]</code>: 一个数组，用来存放返回的两个文件描述符，<code>sv[0]</code> 和 <code>sv[1]</code> 分别代表父进程和子进程的套接字。</li>
</ul>
<h5 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> file_descriptors<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">socketpair</span><span class="token punctuation">(</span>AF_UNIX<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> file_descriptors<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> parent_socket <span class="token operator">=</span> file_descriptors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> child_socket <span class="token operator">=</span> file_descriptors<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码的作用是创建一对连接的套接字，通过 <code>socketpair(AF_UNIX, SOCK_STREAM, 0, file_descriptors)</code> 来生成两个文件描述符，分别用于父进程和子进程的通信。</p>
<ul>
<li><code>file_descriptors[0]</code> 是父进程使用的套接字文件描述符。</li>
<li><code>file_descriptors[1]</code> 是子进程使用的套接字文件描述符。</li>
</ul>
<p>接下来，父进程和子进程可以通过 <code>parent_socket</code> 和 <code>child_socket</code> 进行数据的交换。<strong>数据写入父进程的文件描述符后，子进程可以通过它的文件描述符读取该数据，反之亦然。</strong></p>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>在你提供的代码中，<code>socketpair</code> 用于在父进程和子进程（进入“监狱”的进程）之间通信。子进程无法直接访问系统资源（如文件系统或网络），因此它必须依赖父进程来获取数据或进行操作。在这种情况下，<code>socketpair</code> 是非常适合的技术，因为它提供了一条安全的通信通道。</p>
<pre class="line-numbers language-none"><code class="language-none">c复制代码puts(&quot;Creating a &#96;socketpair&#96; that the child and parent will use to communicate. This is a pair of file descriptors that are&quot;);
puts(&quot;connected: data written to one can be read from the other, and vice-versa.\n&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这说明了 <code>socketpair</code> 的核心功能：数据可以在父子进程之间双向传递。子进程受限于 “jail” 环境，只有通过这种套接字与父进程通信，可能需要从父进程获取关键信息（如 flag）。</p>
<h5 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h5><ol>
<li><strong>创建进程</strong>：父进程首先通过 <code>fork()</code> 创建子进程。父进程保留一个文件描述符，子进程保留另一个。</li>
<li><strong>双向通信</strong>：父进程和子进程可以通过套接字互相发送和接收数据。任何写入 <code>parent_socket</code> 的数据可以被 <code>child_socket</code> 读取，反之亦然。</li>
<li><strong>监狱环境</strong>：子进程被限制在 “jail” 中，它无法直接访问外部资源，依赖父进程通过 <code>socketpair</code> 提供服务。挑战中提到的 “convince the parent process to give it to you”（让父进程提供 flag），意味着子进程必须通过精心构建的通信来请求父进程，才能拿到 flag。</li>
</ol>
<h5 id="socketpair-的优势："><a href="#socketpair-的优势：" class="headerlink" title="socketpair 的优势："></a><code>socketpair</code> 的优势：</h5><ul>
<li><strong>本地进程间通信的高效性</strong>：<code>socketpair</code> 不需要经过网络堆栈，适合高效的本地进程间通信。</li>
<li><strong>双向通信</strong>：可以实现数据的双向传输，方便父子进程或任意两个进程之间的交互。</li>
<li><strong>隔离和安全</strong>：父进程和子进程通过套接字隔离，它们只能通过套接字通信，子进程在受限的 jail 环境下不会直接访问系统资源。</li>
</ul>
<h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><p><code>socketpair</code> 是一种强大且简洁的进程间通信机制，适用于本地的父子进程间的双向通信。在你提供的例子中，父子进程通过 <code>socketpair</code> 进行信息传递，子进程在受限环境下试图从父进程获取 <code>flag</code>，是一个经典的 CTF 场景。</p>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="2-python多线程"><a href="#2-python多线程" class="headerlink" title="2. python多线程"></a>2. python多线程</h4><p><strong>问题描述</strong>：同学遇到了一个问题，即在开启多线程处理数据时，并使用 <code>tqdm.tqdm(p.imap_unordered(worker, t_args), total=len(t_args))</code>进行统计时，总是会在最后卡住。</p>
<p><strong>原始代码</strong>:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> multiprocessing
<span class="token keyword">import</span> time
<span class="token keyword">import</span> os
<span class="token keyword">import</span> tqdm
<span class="token keyword">import</span> signal

<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">:</span>
    singer <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    song <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> singer<span class="token operator">%</span><span class="token number">5</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> singer<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>kill<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> signal<span class="token punctuation">.</span>SIGKILL<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'running ,'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>singer<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">' pid: '</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    t_args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> maxtasksperchild<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> tqdm<span class="token punctuation">.</span>tqdm<span class="token punctuation">(</span>p<span class="token punctuation">.</span>imap_unordered<span class="token punctuation">(</span>sing<span class="token punctuation">,</span> t_args<span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>t_args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    <span class="token comment"># p.imap_unordered(sing, t_args)</span>
    p<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里无论是否使用tqdm统计p.imap_unorder的完成，都会卡住。</p>
<p><strong>原因分析</strong></p>
<p>在sing函数中使用 <code>os.kill(os.getpid(), signal.SIGKILL)</code>结束子进程时，子进程直接结束了。父进程的进程池无法收到子进程结束的状态，所以他会一直等待子进程返回状态，但是子进程已经结束了。进程池需要通过 <code>SIGCHLD</code> 信号了解子进程的终止状态。如果子进程被强制终止（如 <code>SIGKILL</code> 信号–），进程池不会收到 <code>SIGCHLD</code> 信号，因此会一直等待子进程完成。</p>
<p>当进程正常退出时，当一个进程正常退出时（例如，通过 <code>exit()</code> 或 <code>return</code>），它会向其父进程发送 <code>SIGCHLD</code> 信号。父进程（在这种情况下是进程池）会捕获到这个信号，并更新其内部状态以反映子进程已经终止。而 <code>SIGKILL</code> 是一个无法被捕获或忽略的信号。它会立即终止进程而不进行任何清理工作，也不会向父进程发送终止通知。因此，进程池无法知道子进程已经终止，可能会导致资源泄漏或进程池状态不一致。</p>
<p>所以我们需要在子进程中加入异常信号处理函数，在子进程接受到信号量以后，发送相应的信号量到父进程。</p>
<p><strong>正常版本</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> multiprocessing
<span class="token keyword">import</span> time
<span class="token keyword">import</span> os
<span class="token keyword">import</span> tqdm
<span class="token keyword">import</span> signal
<span class="token comment"># 进程使用以及传参</span>
<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">:</span>
    singer <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    song <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> singer<span class="token operator">%</span><span class="token number">5</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> singer<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' pid: '</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        os<span class="token punctuation">.</span>kill<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> signal<span class="token punctuation">.</span>SIGTERM<span class="token punctuation">)</span>
    <span class="token comment"># print('running ,',str(singer),' pid: ',os.getpid(),'pgid: ', os.getpgid(os.getpid()))</span>
    <span class="token comment"># print('running ,',str(singer),' pid: ',os.getpid())</span>
    <span class="token comment"># print('sing:',os.getppid(), multiprocessing.current_process().name)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>singer<span class="token punctuation">&#125;</span></span><span class="token string">唱</span><span class="token interpolation"><span class="token punctuation">&#123;</span>song<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">handle_signal</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Process </span><span class="token interpolation"><span class="token punctuation">&#123;</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string"> received signal </span><span class="token interpolation"><span class="token punctuation">&#123;</span>signum<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token keyword">raise</span> SystemExit<span class="token punctuation">(</span><span class="token string">'Terminated'</span><span class="token punctuation">)</span>
  
<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">:</span>
    signal<span class="token punctuation">.</span>signal<span class="token punctuation">(</span>signal<span class="token punctuation">.</span>SIGTERM<span class="token punctuation">,</span> handle_signal<span class="token punctuation">)</span> <span class="token comment"># 创建信号处理函数，这样通过os向子进程发送信号以后，子进程可以向父进程发送信号。</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        sing<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Unexpected error in process </span><span class="token interpolation"><span class="token punctuation">&#123;</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>      

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    t_args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> maxtasksperchild<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> tqdm<span class="token punctuation">.</span>tqdm<span class="token punctuation">(</span>p<span class="token punctuation">.</span>imap_unordered<span class="token punctuation">(</span>worker<span class="token punctuation">,</span> t_args<span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>t_args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    <span class="token comment"># p.imap_unordered(sing, t_args)</span>
    p<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>输出</strong></p>
<p>可以观察到，子进程的 <code>try/catch</code>语句并没有打印相应的报错信息。但是信号处理函数中的打印语句是打印出来的。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">186677
12
  0%|                                                                                                        | 0/30 [00:00&lt;?, ?it/s]0唱1
1唱1
3唱1
2唱1
 pid:  186678
Process 186678 received signal 15
Process 186678 exiting: Terminated
4唱1
6唱1
7唱1
8唱1
9唱1
 pid:  186687
12唱1
Process 186687 received signal 15
Process 186687 exiting: Terminated
11唱1
13唱1
 pid:  186688
Process 186688 received signal 15
Process 186688 exiting: Terminated
14唱1
16唱1
18唱1
17唱1
19唱1
21唱1
 pid:  186686
24唱1
Process 186686 received signal 15
Process 186686 exiting: Terminated
23唱1
22唱1
26唱1
27唱1
 pid:  186682
Process 186682 received signal 15
28唱1
Process 186682 exiting: Terminated
29唱1
100%|█████████████████████████████████████████████████████████████████████████████████████████████| 30/30 [00:00&lt;00:00, 3469.43it/s]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>分析</strong></p>
<p>在代码中，当子进程接收到 <code>SIGTERM</code> 信号时，信号处理函数 <code>handle_signal</code> 会立即执行，通常会中断当前正在进行的操作。这意味着信号处理函数的执行优先级是高于 <code>try</code>/<code>catch</code> 块中的代码的。所以当 <code>handle_signal</code>引发异常以后，子进程中 <code>try/catch</code>语句中的报错是无法打印出来的。</p>
<h5 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h5><h5 id="1-进程id-pid、父进程id-ppid，进程组id-pgid之间的关系"><a href="#1-进程id-pid、父进程id-ppid，进程组id-pgid之间的关系" class="headerlink" title="1. 进程id pid、父进程id ppid，进程组id pgid之间的关系"></a>1. 进程id pid、父进程id ppid，进程组id pgid之间的关系</h5><ol>
<li>进程ID (PID)：</li>
</ol>
<ul>
<li>每个进程在创建时会被分配一个唯一的进程ID。</li>
</ul>
<ol start="2">
<li>父进程ID (PPID)：</li>
</ol>
<ul>
<li>每个进程都有一个父进程，父进程的进程ID称为父进程ID (PPID)。</li>
</ul>
<ol start="3">
<li>进程组ID (PGID)：</li>
</ol>
<ul>
<li>默认情况下，进程组ID等于创建它的父进程的进程ID。即使一个进程创建了新的进程，这些新进程将继承父进程的进程组ID。</li>
<li>进程组允许将多个相关的进程组织在一起，通常由第一个创建进程的PID作为PGID。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> multiprocessing

<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    pid <span class="token operator">=</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ppid <span class="token operator">=</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pgid <span class="token operator">=</span> os<span class="token punctuation">.</span>getpgid<span class="token punctuation">(</span>pid<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Process ID (PID): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>pid<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Parent Process ID (PPID): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>ppid<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Process Group ID (PGID): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>pgid<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建一个新的进程</span>
    p <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>worker<span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 主进程的信息</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Main Process ID (PID): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Main Process Group ID (PGID): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>os<span class="token punctuation">.</span>getpgid<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出为</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">Main Process ID <span class="token punctuation">(</span>PID<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">178045</span>
Main Process Group ID <span class="token punctuation">(</span>PGID<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">178045</span>
Process ID <span class="token punctuation">(</span>PID<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">178046</span>
Parent Process ID <span class="token punctuation">(</span>PPID<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">178045</span>
Process Group ID <span class="token punctuation">(</span>PGID<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">178045</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中：</p>
<ul>
<li>主进程的PID是 178045，并且它的PGID也是 178045。</li>
<li>当主进程创建了一个新的子进程时，子进程的PID变成了 178046。</li>
<li>子进程的PPID是创建它的主进程的PID，即 178045。</li>
<li>默认情况下，子进程继承了父进程的PGID，所以子进程的PGID仍然是 178045。</li>
</ul>
<h5 id="2-os-kill发送信号"><a href="#2-os-kill发送信号" class="headerlink" title="2. os.kill发送信号"></a>2. os.kill发送信号</h5><p>使用 <code>os.kill</code> 函数向某个进程发送信号，实际上是由操作系统的内核负责产生信号并将其发送到指定进程。调用 <code>os.kill</code> 向进程发送信号时，如果进程注册了信号处理函数，该函数会优先执行。如果处理函数未终止进程，默认的信号处理行为将不会执行，进程会继续运行。这确保了用户可以通过信号处理函数实现自定义行为，而不是立即终止进程或触发其他默认行为。</p>
<h6 id="信号的产生和发送过程"><a href="#信号的产生和发送过程" class="headerlink" title="信号的产生和发送过程"></a>信号的产生和发送过程</h6><ol>
<li><strong>调用 <code>os.kill</code> 函数</strong>：<ul>
<li>当你在代码中调用 <code>os.kill(pid, signal.SIGTERM)</code> 时，Python 会将这个请求传递给操作系统的内核。这里，<code>pid</code> 是目标进程的进程ID，<code>signal.SIGTERM</code> 是要发送的信号。</li>
</ul>
</li>
<li><strong>内核处理信号请求</strong>：<ul>
<li>操作系统的内核接收到 <code>os.kill</code> 的请求后，会验证请求的合法性，包括检查发送信号的进程是否有权限向目标进程发送该信号。</li>
<li>如果请求合法，内核会产生对应的信号。</li>
</ul>
</li>
<li><strong>信号的传递</strong>：<ul>
<li>内核将生成的信号传递给目标进程。信号是一种异步通知机制，可以中断进程的正常执行，并引发预定义的信号处理程序。</li>
</ul>
</li>
<li><strong>信号的处理</strong>：<ul>
<li>目标进程接收到信号后，如果注册了相应的信号处理程序（如使用 <code>signal.signal(signal.SIGTERM, handle_signal)</code> 注册的处理函数），处理程序会被调用。</li>
<li>如果没有注册处理程序，默认的信号处理行为将被执行。对于 <code>SIGTERM</code>，默认行为是终止进程。</li>
</ul>
</li>
</ol>
<h5 id="3-信号处理函数、try-except-语句和系统默认行为的优先级关系"><a href="#3-信号处理函数、try-except-语句和系统默认行为的优先级关系" class="headerlink" title="3. 信号处理函数、try/except 语句和系统默认行为的优先级关系"></a>3. 信号处理函数、<code>try</code>/<code>except</code> 语句和系统默认行为的优先级关系</h5><p><strong>信号处理函数</strong>：</p>
<ul>
<li>当进程接收到信号时，如果该信号有用户定义的处理函数，操作系统会立即调用这个处理函数。</li>
<li>信号处理函数的调用是异步的，可以中断进程正在执行的任何代码，包括 <code>try</code> 块中的代码。</li>
<li>信号处理函数具有最高优先级，因为它可以在任何时候中断进程的执行。</li>
</ul>
<p><strong><code>try</code>/<code>except</code> 语句</strong>：</p>
<ul>
<li><code>try</code>/<code>except</code> 块用于捕获和处理异常。在信号处理函数中引发的异常可以被 <code>try</code>/<code>except</code> 块捕获。</li>
<li>当信号处理函数引发异常时，这个异常会中断当前代码的执行，并跳转到最近的 <code>try</code>/<code>except</code> 块。</li>
<li><code>try</code>/<code>except</code> 块的优先级低于信号处理函数，但高于默认信号处理行为。</li>
</ul>
<p><strong>系统默认行为</strong>：</p>
<ul>
<li>如果进程没有定义信号处理函数，或者信号处理函数没有引发异常，操作系统会执行该信号的默认处理行为。</li>
<li>默认处理行为的优先级最低，只有在没有用户定义的信号处理函数或信号处理函数没有覆盖默认行为时才会执行。</li>
</ul>
<h5 id="4-为什么try-except语句引发的异常，进程池无法接受到？"><a href="#4-为什么try-except语句引发的异常，进程池无法接受到？" class="headerlink" title="4. 为什么try/except语句引发的异常，进程池无法接受到？"></a>4. 为什么try/except语句引发的异常，进程池无法接受到？</h5><p>让我们深入探讨为什么进程池可以正确处理通过信号处理函数引发的 <code>SystemExit</code> 异常，但通过 <code>try</code>/<code>except</code> 语句引发的 <code>SystemExit</code> 异常却不能正确处理。</p>
<h4 id="3-信号处理函数和-try-except-语句的差异"><a href="#3-信号处理函数和-try-except-语句的差异" class="headerlink" title="3. 信号处理函数和 try/except 语句的差异"></a>3. 信号处理函数和 <code>try</code>/<code>except</code> 语句的差异</h4><ol>
<li><strong>信号处理函数的行为</strong>：<ul>
<li>当一个进程接收到信号（如 <code>SIGTERM</code>）时，操作系统会立即调用相应的信号处理函数。这中断了当前进程的执行，并处理信号。</li>
<li>在信号处理函数中引发 <code>SystemExit</code> 异常，会立即导致进程退出，并且操作系统会通知父进程（即进程池）该子进程已终止。</li>
<li>这种行为是操作系统级别的处理，确保了父进程能够捕获到子进程的终止状态。</li>
</ul>
</li>
<li><strong><code>try</code>/<code>except</code> 语句的行为</strong>：<ul>
<li><code>try</code>/<code>except</code> 语句是在用户代码层面进行异常处理。当在 <code>except</code> 块中引发 <code>SystemExit</code> 异常时，Python 解释器会认为这是一个正常退出过程。</li>
<li>但在某些情况下，尤其是在多进程环境下，这种由用户代码引发的 <code>SystemExit</code> 可能不会被进程池正确感知到。这可能与 Python 多进程模块内部的异常传播机制有关。</li>
</ul>
</li>
</ol>
<h4 id="4-pwntool，在不使用p-recvall-的情况下，p-poll-轮询将无法获得进程的退出码"><a href="#4-pwntool，在不使用p-recvall-的情况下，p-poll-轮询将无法获得进程的退出码" class="headerlink" title="4.  pwntool，在不使用p.recvall()的情况下，p.poll()轮询将无法获得进程的退出码"></a>4.  pwntool，在不使用p.recvall()的情况下，p.poll()轮询将无法获得进程的退出码</h4><p>在你的代码中，<code>p.poll()</code> 用于轮询进程的退出状态，<code>p.recvall()</code> 则是用来从进程的标准输出中读取数据。当你调用 <code>p.poll()</code> 时，它检查进程是否已经终止，并返回进程的退出码。如果进程还在运行，它返回 <code>None</code>。</p>
<h5 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h5><p>如果你不调用 <code>p.recvall()</code> 或其他类似的读取操作，进程可能不会像预期一样结束。这背后的原因与 <strong>缓冲区</strong> 和 <strong>管道</strong> 的工作原理有关。</p>
<h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p>当你启动 <code>process</code> 时，标准输出（stdout）和标准输入（stdin）通常会通过管道进行通信。这些管道有一个固定的缓冲区。如果缓冲区满了而没有被读取，那么进程可能会阻塞，等待缓冲区被清空。这意味着如果你没有调用 <code>p.recvall()</code> 或其他读取方法来读取输出数据，进程可能会因为缓冲区满了而一直处于等待状态，从而无法结束。</p>
<p>具体的工作流程是这样的：</p>
<ol>
<li>你在进程中执行了 <code>sendline(shellcode)</code>，将 shellcode 发送给目标进程。</li>
<li>目标进程可能会产生一些输出，比如标准输出或错误输出，写入到它的管道中。</li>
<li>如果你没有读取这些输出，管道的缓冲区会逐渐填满。</li>
<li>一旦管道缓冲区满了，目标进程在试图向输出流中写入更多数据时会被阻塞，导致进程不能正常结束。</li>
<li>在这种情况下，<code>p.poll()</code> 将无法返回一个有效的退出码，因为目标进程仍在等待缓冲区被读取。</li>
</ol>
<h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>为了避免这种情况，你需要确保从进程的标准输出或错误输出中读取数据，以防止缓冲区阻塞进程的正常退出。调用 <code>p.recvall()</code> 可以读取进程的所有输出，并且在进程终止后，读取过程会自动结束。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="1-为什么java不能实现真正意义上的泛型？类似于C-的模板。"><a href="#1-为什么java不能实现真正意义上的泛型？类似于C-的模板。" class="headerlink" title="1. 为什么java不能实现真正意义上的泛型？类似于C++的模板。"></a>1. 为什么java不能实现真正意义上的泛型？类似于C++的模板。</h4><p>为了说明为什么 Java 如果采用类似 C++ 的模板机制就不能实现向后兼容性，我们可以通过以下例子来进行解释。</p>
<h5 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h5><p>Java 的设计理念之一是<strong>向后兼容性</strong>，即新版本的 Java 能够运行老版本编写的程序。这意味着即便 Java 引入了泛型特性，已经存在的老代码（未使用泛型）也应该能够继续运行。</p>
<h5 id="C-模板和-Java-泛型的区别"><a href="#C-模板和-Java-泛型的区别" class="headerlink" title="C++ 模板和 Java 泛型的区别"></a>C++ 模板和 Java 泛型的区别</h5><ul>
<li><strong>C++ 模板</strong>：在编译期生成针对每种类型的独立代码。编译器会为每个模板实例生成不同的函数或类。</li>
<li><strong>Java 泛型</strong>：通过<strong>类型擦除</strong>来实现泛型，确保在运行时只有一套字节码。</li>
</ul>
<h5 id="例子：C-模板如何导致向后不兼容"><a href="#例子：C-模板如何导致向后不兼容" class="headerlink" title="例子：C++ 模板如何导致向后不兼容"></a>例子：C++ 模板如何导致向后不兼容</h5><p>假设我们在 C++ 中有如下模板代码：</p>
<h5 id="C-模板例子"><a href="#C-模板例子" class="headerlink" title="C++ 模板例子"></a>C++ 模板例子</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    T value<span class="token punctuation">;</span>
    <span class="token function">Box</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Box contains: "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">displayOld</span><span class="token punctuation">(</span>Box<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> box<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Old version: Box contains: "</span> <span class="token operator">&lt;&lt;</span> box<span class="token punctuation">.</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Box<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">intBox</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intBox<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Box contains: 123</span>
    
    <span class="token function">displayOld</span><span class="token punctuation">(</span>intBox<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Old version works fine</span>

    Box<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> <span class="token function">strBox</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    strBox<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Box contains: Hello</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>Box&lt;int&gt;</code> 和 <code>Box&lt;std::string&gt;</code> 是两个完全不同的类，编译器为 <code>int</code> 和 <code>std::string</code> 生成了两个不同的类实例。如果我们将现有的程序扩展为使用 <code>Box&lt;std::string&gt;</code>，之前编译的函数 <code>displayOld</code>（仅处理 <code>Box&lt;int&gt;</code>）将无法处理 <code>Box&lt;std::string&gt;</code>，因为它们是不同的类型。这在向后兼容性上就会出现问题：<strong>新增的模板类型与老版本生成的代码无法协作</strong>。</p>
<h5 id="Java-泛型向后兼容的方式"><a href="#Java-泛型向后兼容的方式" class="headerlink" title="Java 泛型向后兼容的方式"></a>Java 泛型向后兼容的方式</h5><p>为了避免这种问题，Java 采用了<strong>类型擦除</strong>机制，使得泛型类在编译时只生成一套字节码，这样老代码（没有泛型）依然可以与泛型代码协同工作。</p>
<h5 id="Java-泛型例子"><a href="#Java-泛型例子" class="headerlink" title="Java 泛型例子"></a>Java 泛型例子</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">displayOld</span><span class="token punctuation">(</span>strList<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 老代码仍然可以工作</span>
        
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">displayOld</span><span class="token punctuation">(</span>intList<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 仍然兼容老代码</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 老版本的函数，不使用泛型</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayOld</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Old version: "</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>类型擦除</strong>后，<code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 在运行时实际上是同一个类，即 <code>ArrayList&lt;Object&gt;</code>。因此，旧版的 <code>displayOld</code> 方法仍然可以处理新版本中传入的泛型参数，无论是 <code>ArrayList&lt;String&gt;</code> 还是 <code>ArrayList&lt;Integer&gt;</code>，因为它们都被视为 <code>ArrayList&lt;Object&gt;</code>。</p>
<h5 id="为什么-C-模板无法做到向后兼容"><a href="#为什么-C-模板无法做到向后兼容" class="headerlink" title="为什么 C++ 模板无法做到向后兼容"></a>为什么 C++ 模板无法做到向后兼容</h5><ol>
<li><strong>独立的类实例</strong>：C++ 模板在编译时为每个不同类型生成独立的代码。如果老代码只知道如何处理 <code>Box&lt;int&gt;</code>，它就无法处理 <code>Box&lt;std::string&gt;</code>，因为在编译时，这些是完全不同的类。</li>
<li><strong>模板代码膨胀</strong>：由于 C++ 为每个类型实例生成不同的代码，二进制文件大小会膨胀。而如果在新版本中引入了更多类型的实例，旧版本的代码和新版本的模板实例可能无法共存。</li>
<li><strong>无法统一处理所有类型</strong>：由于 C++ 模板为每种类型生成独立代码，旧的二进制代码无法处理新的类型实例。这就导致如果添加了新类型支持，必须重新编译所有代码。</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>如果 Java 采用了 C++ 模板机制，那么：</p>
<ul>
<li>老代码和新代码将无法互操作，因为编译期会为每个泛型实例生成独立的代码，老版本的代码不会知道如何处理新版本的泛型类。</li>
<li>为了让旧代码处理新的泛型类型，必须重新编译旧代码，这会导致向后兼容性问题。</li>
</ul>
<p>通过<strong>类型擦除</strong>，Java 确保了泛型的类型信息在编译时检查，运行时类型被擦除，使得编译后的字节码对所有泛型类型都一样，从而保证了新旧代码的兼容性。</p>
<h4 id="2-java-到底是值传递还是引用传递"><a href="#2-java-到底是值传递还是引用传递" class="headerlink" title="2. java 到底是值传递还是引用传递"></a>2. java 到底是值传递还是引用传递</h4><ul>
<li>值传递：当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量，<ul>
<li>Java 中的参数传递是按值传递的。</li>
<li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。</li>
<li>如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝。</li>
</ul>
</li>
<li>引用传递： 当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/basic-extra-meal/pass-by-value.html">https://javabetter.cn/basic-extra-meal/pass-by-value.html</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ReferenceTypeDemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"二哥"</span><span class="token punctuation">;</span>
        <span class="token function">modify</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token class-name">String</span> name1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        name1 <span class="token operator">=</span> <span class="token string">"三妹"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/20240916120935.png" alt="20240916120935" style="zoom:50%;" />



<h4 id="3-java-深拷贝和浅拷贝"><a href="#3-java-深拷贝和浅拷贝" class="headerlink" title="3. java 深拷贝和浅拷贝"></a>3. java 深拷贝和浅拷贝</h4><p>“深拷贝和浅拷贝不同的，深拷贝中的引用类型字段也会克隆一份，当改变任何一个对象，另外一个对象不会随之改变。”浅拷贝不会拷贝引用类型字段，引用类型的变量还是指向的同一个对象。</p>
<h4 id="4-hashCode-与-equals（为什么重写equals方法后，hashCode方法也必须重写"><a href="#4-hashCode-与-equals（为什么重写equals方法后，hashCode方法也必须重写" class="headerlink" title="4. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写)"></a>4. hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写)</h4><p>在Java中，<code>hashCode()</code>和<code>equals()</code>方法有着密切的关系，特别是在使用哈希集合类（如<code>HashSet</code>、<code>HashMap</code>等）时。如果只重写了<code>equals()</code>方法，而不重写<code>hashCode()</code>，可能会导致程序行为不符合预期。</p>
<p><code>Object</code>类的<code>hashCode()</code>方法的默认实现是基于<strong>对象的内存地址</strong>来计算哈希值。这意味着每个对象的内存地址不同，因此它们的哈希值通常是不同的。</p>
<h5 id="equals-和hashCode-的作用："><a href="#equals-和hashCode-的作用：" class="headerlink" title="equals()和hashCode()的作用："></a><code>equals()</code>和<code>hashCode()</code>的作用：</h5><ol>
<li><strong><code>equals()</code><strong>：用来比较两个对象是否”相等”。默认情况下，<code>equals()</code>方法比较的是对象的</strong>引用</strong>（地址），但通常我们会根据对象的<strong>属性</strong>来判断两个对象是否相等，所以需要重写<code>equals()</code>方法。</li>
<li><strong><code>hashCode()</code><strong>：返回一个对象的</strong>哈希码</strong>，它是对象的一个整数表示，主要用于哈希表中的<strong>快速查找</strong>。在默认实现中，<code>hashCode()</code>方法基于对象的内存地址生成。</li>
</ol>
<h5 id="为什么重写equals-方法后，必须重写hashCode-方法？"><a href="#为什么重写equals-方法后，必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()方法后，必须重写hashCode()方法？"></a>为什么重写<code>equals()</code>方法后，必须重写<code>hashCode()</code>方法？</h5><h5 id="Java的基本约定："><a href="#Java的基本约定：" class="headerlink" title="Java的基本约定："></a>Java的基本约定：</h5><p>Java规定了<code>equals()</code>与<code>hashCode()</code>之间的约定，以保证哈希集合类的正常运行：</p>
<ul>
<li><strong>如果两个对象通过<code>equals()</code>方法比较相等（即<code>obj1.equals(obj2)</code>返回<code>true</code>），那么它们的<code>hashCode()</code>也必须相等</strong>。这确保了在哈希表结构中，<code>obj1</code>和<code>obj2</code>会被放到相同的桶中。</li>
<li><strong>如果两个对象通过<code>equals()</code>方法不相等，那么它们的<code>hashCode()</code>可以相同</strong>（虽然这不影响正确性，但会降低性能），这称为哈希冲突。</li>
</ul>
<h5 id="如果不遵守这个约定，会发生什么？"><a href="#如果不遵守这个约定，会发生什么？" class="headerlink" title="如果不遵守这个约定，会发生什么？"></a>如果不遵守这个约定，会发生什么？</h5><p>如果只重写了<code>equals()</code>而没有重写<code>hashCode()</code>，就可能违反上述约定，导致以下问题：</p>
<ol>
<li><strong>哈希集合无法正确存储对象</strong>： 比如在<code>HashSet</code>中，如果两个对象被认为是相等的（通过<code>equals()</code>），但它们的<code>hashCode()</code>不同，那么在添加这些对象到<code>HashSet</code>时，它们会被放入不同的桶中，<code>HashSet</code>会错误地认为它们是不同的对象，导致集合中有重复对象。</li>
<li><strong>哈希表无法正确查找对象</strong>： 在<code>HashMap</code>中，如果存储了一个对象<code>obj1</code>，而要查找另一个”相等”的对象<code>obj2</code>（即<code>obj1.equals(obj2)</code>为<code>true</code>），如果<code>obj1</code>和<code>obj2</code>的<code>hashCode()</code>不同，<code>HashMap</code>会去不同的桶中查找，可能找不到对象，即使<code>equals()</code>表明它们相等。</li>
</ol>
<p>在Java中，<code>hashCode()</code>和<code>equals()</code>方法有着密切的关系，特别是在使用哈希集合类（如<code>HashSet</code>、<code>HashMap</code>等）时。如果只重写了<code>equals()</code>方法，而不重写<code>hashCode()</code>，可能会导致程序行为不符合预期。</p>
<h5 id="equals-和hashCode-的作用：-1"><a href="#equals-和hashCode-的作用：-1" class="headerlink" title="equals()和hashCode()的作用："></a><code>equals()</code>和<code>hashCode()</code>的作用：</h5><ol>
<li><strong><code>equals()</code><strong>：用来比较两个对象是否”相等”。默认情况下，<code>equals()</code>方法比较的是对象的</strong>引用</strong>（地址），但通常我们会根据对象的<strong>属性</strong>来判断两个对象是否相等，所以需要重写<code>equals()</code>方法。</li>
<li><strong><code>hashCode()</code><strong>：返回一个对象的</strong>哈希码</strong>，它是对象的一个整数表示，主要用于哈希表中的<strong>快速查找</strong>。在默认实现中，<code>hashCode()</code>方法基于对象的内存地址生成。</li>
</ol>
<h5 id="为什么重写equals-方法后，必须重写hashCode-方法？-1"><a href="#为什么重写equals-方法后，必须重写hashCode-方法？-1" class="headerlink" title="为什么重写equals()方法后，必须重写hashCode()方法？"></a>为什么重写<code>equals()</code>方法后，必须重写<code>hashCode()</code>方法？</h5><h5 id="Java的基本约定：-1"><a href="#Java的基本约定：-1" class="headerlink" title="Java的基本约定："></a>Java的基本约定：</h5><p>Java规定了<code>equals()</code>与<code>hashCode()</code>之间的约定，以保证哈希集合类的正常运行：</p>
<ul>
<li><strong>如果两个对象通过<code>equals()</code>方法比较相等（即<code>obj1.equals(obj2)</code>返回<code>true</code>），那么它们的<code>hashCode()</code>也必须相等</strong>。这确保了在哈希表结构中，<code>obj1</code>和<code>obj2</code>会被放到相同的桶中。</li>
<li><strong>如果两个对象通过<code>equals()</code>方法不相等，那么它们的<code>hashCode()</code>可以相同</strong>（虽然这不影响正确性，但会降低性能），这称为哈希冲突。</li>
</ul>
<h5 id="如果不遵守这个约定，会发生什么？-1"><a href="#如果不遵守这个约定，会发生什么？-1" class="headerlink" title="如果不遵守这个约定，会发生什么？"></a>如果不遵守这个约定，会发生什么？</h5><p>如果只重写了<code>equals()</code>而没有重写<code>hashCode()</code>，就可能违反上述约定，导致以下问题：</p>
<ol>
<li><strong>哈希集合无法正确存储对象</strong>： 比如在<code>HashSet</code>中，如果两个对象被认为是相等的（通过<code>equals()</code>），但它们的<code>hashCode()</code>不同，那么在添加这些对象到<code>HashSet</code>时，它们会被放入不同的桶中，<code>HashSet</code>会错误地认为它们是不同的对象，导致集合中有重复对象。</li>
<li><strong>哈希表无法正确查找对象</strong>： 在<code>HashMap</code>中，如果存储了一个对象<code>obj1</code>，而要查找另一个”相等”的对象<code>obj2</code>（即<code>obj1.equals(obj2)</code>为<code>true</code>），如果<code>obj1</code>和<code>obj2</code>的<code>hashCode()</code>不同，<code>HashMap</code>会去不同的桶中查找，可能找不到对象，即使<code>equals()</code>表明它们相等。</li>
</ol>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>假设我们有一个简单的类<code>Person</code>，只根据名字和年龄来判断相等性：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> age <span class="token operator">==</span> person<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 假设没有重写 hashCode()</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中，<code>equals()</code>已经重写，两个<code>Person</code>对象如果名字和年龄相同会被认为是相等的。但如果没有重写<code>hashCode()</code>，比如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 期望p1和p2相等，但实际上它们被认为是不同的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于没有重写<code>hashCode()</code>，即使<code>p1.equals(p2)</code>为<code>true</code>，它们的<code>hashCode()</code>可能不同，导致<code>HashSet</code>认为它们是不同的对象，<code>set</code>会错误地存储两个相等的对象。</p>
<h5 id="正确的做法："><a href="#正确的做法：" class="headerlink" title="正确的做法："></a>正确的做法：</h5><p>为了避免这个问题，重写<code>equals()</code>时，必须同时重写<code>hashCode()</code>。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样，两个对象如果通过<code>equals()</code>相等，它们的<code>hashCode()</code>也会相等。</p>
<h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ul>
<li><strong><code>equals()</code>决定两个对象是否相等</strong>。</li>
<li><strong><code>hashCode()</code>决定两个对象是否可以放入同一个哈希桶</strong>。</li>
<li>如果只重写<code>equals()</code>而不重写<code>hashCode()</code>，会破坏哈希集合的行为，导致错误的存储和查找结</li>
</ul>
<h4 id="5-list的add和remove操作"><a href="#5-list的add和remove操作" class="headerlink" title="5. list的add和remove操作"></a>5. list的add和remove操作</h4><p>在 Java 中，<code>List</code> 接口常用于处理有序的集合，提供了一些常用的操作方法，比如 <code>add</code> 和 <code>remove</code>。它的常见实现类有 <code>ArrayList</code> 和 <code>LinkedList</code>，它们的 <code>add</code> 和 <code>remove</code> 方法的性能可能会有所不同。</p>
<h5 id="add-操作"><a href="#add-操作" class="headerlink" title="add 操作"></a><code>add</code> 操作</h5><p><code>List</code> 的 <code>add</code> 方法有两个重载版本：</p>
<ol>
<li><p>**<code>boolean add(E e)</code>**：在列表的末尾追加一个元素。</p>
<ul>
<li><p>时间复杂度：</p>
<ul>
<li>对于 <code>ArrayList</code>，如果没有扩容，时间复杂度为 **O(1)**；如果扩容，则为 **O(n)**，因为需要重新分配内存并复制现有元素。</li>
<li>对于 <code>LinkedList</code>，时间复杂度为 **O(1)**，因为它只是在链表末尾添加一个节点。</li>
</ul>
</li>
<li><p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>**<code>void add(int index, E element)</code>**：在指定位置插入一个元素。</p>
<ul>
<li><p>时间复杂度：</p>
<ul>
<li>对于 <code>ArrayList</code>，时间复杂度为 **O(n)**，因为需要移动插入点后面的所有元素。</li>
<li>对于 <code>LinkedList</code>，时间复杂度为 **O(n)**，因为需要遍历到指定索引处，找到插入位置。</li>
</ul>
</li>
<li><p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 插入到索引 0 位置</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入到索引 1 位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<h5 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove 操作"></a><code>remove</code> 操作</h5><p><code>List</code> 的 <code>remove</code> 方法也有两个重载版本：</p>
<ol>
<li><p>**<code>E remove(int index)</code>**：根据索引删除指定位置的元素。</p>
<ul>
<li><p>时间复杂度：</p>
<ul>
<li>对于 <code>ArrayList</code>，时间复杂度为 **O(n)**，因为需要移动被删除元素后面的所有元素。</li>
<li>对于 <code>LinkedList</code>，时间复杂度为 **O(n)**，因为需要遍历链表找到指定索引，并执行删除。</li>
</ul>
</li>
<li><p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除索引 1 位置的 "banana"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>**<code>boolean remove(Object o)</code>**：根据对象内容删除第一个匹配的元素。</p>
<ul>
<li><p>时间复杂度：</p>
<ul>
<li>对于 <code>ArrayList</code>，时间复杂度为 **O(n)**，因为需要遍历整个列表找到要删除的对象。</li>
<li>对于 <code>LinkedList</code>，时间复杂度为 **O(n)**，因为也需要遍历链表找到要删除的对象。</li>
</ul>
</li>
<li><p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除第一个匹配的 "apple"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><ul>
<li>add 和  remove 操作在  ArrayList 和 LinkedList 中的性能有差异，具体取决于它们的内部实现方式。<ul>
<li>**<code>ArrayList</code>**：在末尾添加元素通常是 **O(1)**，但在中间插入或删除则需要移动元素，时间复杂度为 **O(n)**。</li>
<li>**<code>LinkedList</code>**：在任意位置添加或删除元素不需要移动其他元素，但由于链表需要遍历，性能为 **O(n)**。</li>
</ul>
</li>
</ul>
<p>根据具体的需求，选择合适的 <code>List</code> 实现类会对程序性能产生影</p>
<h4 id="6-java的垃圾回收机制"><a href="#6-java的垃圾回收机制" class="headerlink" title="6. java的垃圾回收机制"></a>6. java的垃圾回收机制</h4><p>Java 的垃圾回收机制（Garbage Collection，简称 GC）是自动管理内存的功能，开发者不需要显式地释放对象的内存，垃圾回收器会自动检测和释放不再使用的对象，从而防止内存泄漏并优化内存使用。</p>
<h4 id="7-Java-垃圾回收机制的基本原理"><a href="#7-Java-垃圾回收机制的基本原理" class="headerlink" title="7. Java 垃圾回收机制的基本原理"></a>7. Java 垃圾回收机制的基本原理</h4><p>Java 使用 <strong>堆内存（Heap）</strong> 来存储对象。当程序创建新对象时，系统会在堆中分配内存，随着时间的推移，有些对象可能不会再被引用，这些对象就变成了 <strong>垃圾</strong>。垃圾回收机制的目标是：</p>
<ol>
<li>自动检测哪些对象已经不再被引用；</li>
<li>释放这些对象占用的内存；</li>
<li>使程序内存使用更加高效。</li>
</ol>
<h5 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h5><p>Java 垃圾回收机制的核心是使用不同的算法来自动管理堆内存。常见的垃圾回收算法包括：</p>
<h6 id="1-标记-清除算法（Mark-Sweep）"><a href="#1-标记-清除算法（Mark-Sweep）" class="headerlink" title="1. 标记-清除算法（Mark-Sweep）"></a>1. <strong>标记-清除算法（Mark-Sweep）</strong></h6><ul>
<li>步骤：<ol>
<li><strong>标记（Marking）</strong>：垃圾回收器会扫描所有活动对象，并将它们标记为存活。</li>
<li><strong>清除（Sweep）</strong>：未被标记的对象会被认为是垃圾，系统将清除它们，释放对应的内存。</li>
</ol>
</li>
<li><strong>问题</strong>：虽然能够回收垃圾对象，但可能会导致内存碎片化，因为清除后内存空间并不会被紧凑排列。</li>
</ul>
<h6 id="2-标记-整理算法（Mark-Compact）"><a href="#2-标记-整理算法（Mark-Compact）" class="headerlink" title="2. 标记-整理算法（Mark-Compact）"></a>2. <strong>标记-整理算法（Mark-Compact）</strong></h6><ul>
<li>步骤：<ol>
<li>先执行和标记-清除算法一样的标记过程。</li>
<li>然后通过整理步骤，将存活的对象移动到内存的一端，形成连续的内存块，消除碎片化问题。</li>
</ol>
</li>
<li><strong>优势</strong>：避免了内存碎片问题，内存分配效率更高。</li>
</ul>
<h6 id="3-复制算法（Copying）"><a href="#3-复制算法（Copying）" class="headerlink" title="3. 复制算法（Copying）"></a>3. <strong>复制算法（Copying）</strong></h6><ul>
<li>将内存区域划分为两部分（通常是新生代使用）：活动对象总是位于一部分，当这部分内存用完时，垃圾回收器会将存活的对象复制到另一块内存区域，之后清除原来的区域。</li>
<li><strong>优势</strong>：这种方式可以快速回收内存，不需要额外的清除或整理步骤。</li>
<li><strong>缺点</strong>：需要更多的内存，因为它依赖于内存区域划分为两部分。</li>
</ul>
<h5 id="内存划分及垃圾回收器"><a href="#内存划分及垃圾回收器" class="headerlink" title="内存划分及垃圾回收器"></a>内存划分及垃圾回收器</h5><p>Java 的堆内存分为 <strong>新生代（Young Generation）</strong> 和 <strong>老年代（Old Generation）</strong>。不同的垃圾回收器使用了这些划分来管理不同生命周期的对象。</p>
<ul>
<li><strong>新生代</strong>：用于存放刚刚创建的对象，分为三个区域：<strong>Eden</strong> 区、<strong>Survivor</strong> 区（S0、S1）。大部分对象会在新生代中创建并快速回收。新生代的回收称为 <strong>Minor GC</strong>。</li>
<li><strong>老年代</strong>：存放生命周期较长的对象，这些对象在多次 Minor GC 后仍存活下来，会被移动到老年代。老年代的回收称为 <strong>Major GC</strong> 或 <strong>Full GC</strong>。</li>
</ul>
<h5 id="常见垃圾回收器"><a href="#常见垃圾回收器" class="headerlink" title="常见垃圾回收器"></a>常见垃圾回收器</h5><ol>
<li><strong>Serial GC</strong>：单线程垃圾回收器，适用于单线程应用。</li>
<li><strong>Parallel GC</strong>：多线程垃圾回收器，使用多个线程并行处理垃圾回收，适用于多核 CPU 的服务器。</li>
<li><strong>CMS（Concurrent Mark-Sweep）GC</strong>：并发垃圾回收器，减少了应用暂停时间，适用于需要低延迟的应用。</li>
<li><strong>G1（Garbage First）GC</strong>：专为大内存、低延迟的应用设计，分区收集内存，提供更好的性能。</li>
</ol>
<h5 id="垃圾回收触发时机"><a href="#垃圾回收触发时机" class="headerlink" title="垃圾回收触发时机"></a>垃圾回收触发时机</h5><p>垃圾回收器在以下情况会被触发：</p>
<ol>
<li>新生代满了，触发 Minor GC；</li>
<li>老年代满了，触发 Major GC 或 Full GC；</li>
<li>手动调用 <code>System.gc()</code>，会建议垃圾回收器运行（但不是强制）。</li>
</ol>
<h5 id="垃圾回收优化"><a href="#垃圾回收优化" class="headerlink" title="垃圾回收优化"></a>垃圾回收优化</h5><p>通过调整堆大小、垃圾回收算法和线程，可以优化 Java 应用的性能：</p>
<ul>
<li>调整堆内存大小：<code>-Xms</code> 设置初始堆大小，<code>-Xmx</code> 设置最大堆大小。</li>
<li>调整新生代和老年代比例：通过参数如 <code>-XX:NewRatio</code> 调整比例。</li>
<li>选择合适的垃圾回收器：例如 <code>-XX:+UseG1GC</code> 使用 G1 GC。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>Java 的垃圾回收机制通过多种算法和回收器，实现了自动内存管理，极大地简化了开发者的内存操作负担。合理配置垃圾回收器可以提升程序的性能，尤其是针对大规模、高并发的应用。</p>
<h4 id="8-java是多继承吗"><a href="#8-java是多继承吗" class="headerlink" title="8. java是多继承吗"></a>8. java是多继承吗</h4><p>Java <strong>不是</strong>多继承的语言。它不允许一个类继承多个类，即 <strong>类的多继承</strong> 在 Java 中是不支持的。Java 只允许一个类通过 <code>extends</code> 关键字继承自一个父类，这样可以避免多继承中的 <strong>菱形继承问题</strong>（即多个父类有相同的方法，子类不确定调用哪个版本）。</p>
<h5 id="为什么-Java-不支持多继承？"><a href="#为什么-Java-不支持多继承？" class="headerlink" title="为什么 Java 不支持多继承？"></a>为什么 Java 不支持多继承？</h5><p>多继承容易引发复杂性，尤其是在以下两种情况下：</p>
<ol>
<li><p><strong>菱形继承问题</strong>：当两个父类有同名的字段或方法时，子类继承时会遇到冲突，可能不知道应该使用哪个父类的实现。</p>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Class A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Class B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 如果类 C 继承 A 和 B，会不知道调用哪个 display 方法。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>增加复杂性</strong>：维护代码会变得困难，因为子类需要同时处理多个父类的行为和状态。</p>
</li>
</ol>
<h5 id="Java-提供的替代方案：接口"><a href="#Java-提供的替代方案：接口" class="headerlink" title="Java 提供的替代方案：接口"></a>Java 提供的替代方案：接口</h5><p>虽然 Java 不支持类的多继承，但它允许一个类实现多个接口，这可以作为多继承的替代方案。</p>
<ul>
<li><strong>接口</strong>：接口定义了一组抽象方法，任何类都可以通过 <code>implements</code> 关键字实现多个接口，从而获取多种行为特性。接口没有方法的具体实现，不会带来多继承中方法冲突的问题。</li>
</ul>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Implementing display from A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Implementing show from B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">C</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出: Implementing display from A</span>
        obj<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 输出: Implementing show from B</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Java-8-的默认方法"><a href="#Java-8-的默认方法" class="headerlink" title="Java 8 的默认方法"></a>Java 8 的默认方法</h5><p>Java 8 引入了接口的 <strong>默认方法（default methods）</strong>，即接口中的方法可以有默认的实现。这意味着接口的实现类不需要重新实现这些默认方法，但如果实现类需要，可以覆盖它们。</p>
<p>如果一个类实现了多个接口，并且这些接口有相同的默认方法实现，那么子类必须<strong>明确指定</strong>使用哪个接口的方法实现，避免冲突。</p>
<p>总结：</p>
<ul>
<li>Java 不支持类的多继承，但支持接口的多继承。</li>
<li>通过接口和接口的默认方法，Java 提供了功能上类似多继承的能力，同时避免了多继承的复杂性。</li>
</ul>
<h4 id="9-spring-boot-项目如何启动"><a href="#9-spring-boot-项目如何启动" class="headerlink" title="9. spring boot 项目如何启动"></a>9. spring boot 项目如何启动</h4><p>在 <strong>Spring Boot</strong> 项目中，各个模块之间的启动和交互依赖于 <strong>Spring 框架</strong> 的核心特性，如 <strong>依赖注入</strong>、<strong>自动配置</strong> 和 <strong>组件扫描</strong>。下面是这些模块如何相互启动和协作的一个概述：</p>
<h5 id="1-启动类（BaselinecheckApplication-java）的启动流程"><a href="#1-启动类（BaselinecheckApplication-java）的启动流程" class="headerlink" title="1. 启动类（BaselinecheckApplication.java）的启动流程"></a>1. <strong>启动类（<code>BaselinecheckApplication.java</code>）的启动流程</strong></h5><ul>
<li><p>Spring Boot 项目的启动类通常带有 <code>@SpringBootApplication</code> 注解。</p>
</li>
<li><pre><code>@SpringBootApplication
</code></pre>
<p> 是一个复合注解，包含了以下重要功能：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 Spring Boot 的自动配置机制，会根据项目中的依赖自动配置相关的 bean。</li>
<li><code>@ComponentScan</code>：启用组件扫描，扫描当前包及其子包下的所有 Spring 组件（如 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Component</code> 等）。</li>
<li><code>@Configuration</code>：标记该类为一个配置类，等价于 <code>@Configuration</code>，使其能够定义 <code>@Bean</code>。</li>
</ul>
</li>
<li><p>当 <code>main()</code> 方法调用 <code>SpringApplication.run()</code> 时，Spring Boot 会启动应用，创建 Spring 应用上下文（<code>ApplicationContext</code>），并自动扫描、加载所有的 bean、配置类和组件。</p>
</li>
</ul>
<h5 id="2-组件的自动扫描和依赖注入"><a href="#2-组件的自动扫描和依赖注入" class="headerlink" title="2. 组件的自动扫描和依赖注入"></a>2. <strong>组件的自动扫描和依赖注入</strong></h5><ul>
<li><strong>组件扫描（<code>@ComponentScan</code>）</strong>：当启动类启动时，<code>@ComponentScan</code> 会扫描当前包及其子包下的所有类，找到标记了 Spring 注解的类（如 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Component</code>），并将这些类注册为 Spring 管理的 bean。</li>
<li>依赖注入（DI，Dependency Injection）：Spring 会通过依赖注入的方式，将需要的组件注入到其他组件中。例如，Controller 类中的 Service 实例，Service类中的 Repository实例，都是通过构造函数或字段注入的。<ul>
<li><strong><code>@Autowired</code> 注解</strong>：用于告诉 Spring 自动注入依赖。</li>
</ul>
</li>
</ul>
<h5 id="3-模块之间的启动与协作"><a href="#3-模块之间的启动与协作" class="headerlink" title="3. 模块之间的启动与协作"></a>3. <strong>模块之间的启动与协作</strong></h5><ul>
<li>Controller 层与 Service 层的交互：<ul>
<li><code>Controller</code> 是处理 HTTP 请求的入口，它接收客户端请求并返回响应。</li>
<li>在 <code>Controller</code> 中，通常通过依赖注入（如 <code>@Autowired</code>）的方式，调用业务逻辑层的 <code>Service</code> 类。例如，一个 <code>UserController</code> 可能会注入 <code>UserService</code>，调用其方法来处理与用户相关的业务逻辑。</li>
</ul>
</li>
<li>Service 层与 Mapper 层的交互：<ul>
<li><code>Service</code> 是业务逻辑的核心层，它处理具体的业务规则和流程。</li>
<li>如果需要访问数据库，<code>Service</code> 会通过依赖注入调用 <code>Mapper</code> 类（通常是接口，使用 <code>@Mapper</code> 注解）。<code>Mapper</code> 使用数据库访问框架（如 MyBatis、JPA）来进行增删改查操作，返回的数据会交给 <code>Service</code> 层处理后返回给 <code>Controller</code>。</li>
</ul>
</li>
<li>Service 层与其他 Service 层的交互：<ul>
<li>一个服务可能会依赖于其他服务。例如，订单服务 <code>OrderService</code> 可能需要调用用户服务 <code>UserService</code> 获取用户信息。这也是通过依赖注入完成的。</li>
</ul>
</li>
</ul>
<h5 id="4-数据处理流程"><a href="#4-数据处理流程" class="headerlink" title="4. 数据处理流程"></a>4. <strong>数据处理流程</strong></h5><ul>
<li>请求流程：<ul>
<li>当一个 HTTP 请求发出时，<code>DispatcherServlet</code> 作为 Spring MVC 的核心控制器，首先拦截请求，然后根据 URL 路径找到对应的 <code>Controller</code>，并将请求转发给相应的方法处理。</li>
<li><code>Controller</code> 方法会处理请求参数，并通过调用 <code>Service</code> 来执行具体的业务逻辑。</li>
</ul>
</li>
<li>业务逻辑处理：<ul>
<li><code>Service</code> 负责处理业务逻辑，通常通过注入 <code>Mapper</code> 类与数据库交互，获取或保存数据。</li>
</ul>
</li>
<li>数据返回：<ul>
<li><code>Service</code> 将处理后的数据返回给 <code>Controller</code>，<code>Controller</code> 再将数据封装成 JSON、XML 或视图等形式，返回给客户端。</li>
</ul>
</li>
</ul>
<h5 id="5-Spring-Security-或-Realm-的认证流程"><a href="#5-Spring-Security-或-Realm-的认证流程" class="headerlink" title="5. Spring Security 或 Realm 的认证流程"></a>5. <strong>Spring Security 或 Realm 的认证流程</strong></h5><ul>
<li>如果项目中包含安全模块（如 <code>realm</code> 目录），Spring Boot 可能会集成 Spring Security 或 Shiro 进行用户认证与授权。</li>
<li>当用户访问受保护的资源时，<code>Realm</code> 类（用于身份验证的组件）会被调用，通过查询数据库或其他用户数据源，验证用户身份，并检查权限。</li>
<li>验证通过后，Spring Security 会允许请求继续，进入 <code>Controller</code> 处理业务逻辑；否则，用户将被重定向到登录页面或显示未授权的错误信息。</li>
</ul>
<h5 id="6-配置类的作用"><a href="#6-配置类的作用" class="headerlink" title="6. 配置类的作用"></a>6. <strong>配置类的作用</strong></h5><ul>
<li><code>config</code> 目录下的配置类会在项目启动时由 Spring 自动加载，并根据项目的需求，配置必要的 bean。</li>
<li>例如，安全配置类可以定义哪些 URL 需要认证、哪些请求不需要认证；数据源配置类会定义数据库连接的细节；跨域配置类会设置哪些域名可以访问此应用的资源等。</li>
</ul>
<h5 id="7-测试的启动"><a href="#7-测试的启动" class="headerlink" title="7. 测试的启动"></a>7. <strong>测试的启动</strong></h5><ul>
<li>测试类通常位于 <code>test</code> 目录下。通过 <code>@SpringBootTest</code> 注解，测试类可以启动一个 Spring 上下文，用于进行集成测试，确保各个模块的正确交互和功能。</li>
</ul>
<h5 id="8-主线程与子线程"><a href="#8-主线程与子线程" class="headerlink" title="8. 主线程与子线程"></a>8. <strong>主线程与子线程</strong></h5><ul>
<li>Spring Boot 项目默认在主线程中启动。但如果项目中有异步任务、定时任务等，可能会启动多个子线程来并行处理。</li>
<li>例如，通过 <code>@Async</code> 注解，Spring 可以启用异步任务，在后台线程中执行不会阻塞主线程的操作。</li>
</ul>
<hr>
<h5 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h5><ol>
<li><strong>启动类</strong>：通过 <code>@SpringBootApplication</code> 自动扫描和启动项目。</li>
<li><strong>组件扫描</strong>：扫描并注册所有 Spring 管理的组件（Controller、Service、Repository 等）。</li>
<li><strong>依赖注入</strong>：不同层（Controller、Service、Mapper）之间通过依赖注入协作处理业务。</li>
<li><strong>请求处理</strong>：客户端请求经由 <code>Controller</code> 调用 <code>Service</code>，最终访问 <code>Mapper</code> 执行数据库操作。</li>
<li><strong>认证授权</strong>：通过 Spring Security 或 Shiro 进行安全控制。</li>
<li><strong>配置类与测试类</strong>：配置类定义应用的各种设置，测试类用于验证功能。</li>
</ol>
<p>项目启动的核心机制是 <strong>Spring Boot 的自动配置</strong> 和 <strong>依赖注入</strong>，它们确保了各个模块能够自动协作和启动。</p>
<h4 id="10-Java什么情况下会产生内存溢出"><a href="#10-Java什么情况下会产生内存溢出" class="headerlink" title="10. Java什么情况下会产生内存溢出"></a>10. Java什么情况下会产生内存溢出</h4><ul>
<li>堆溢出，不断的声明新的对象实例</li>
<li>虚拟机栈和本地方法栈溢出，线程请求的栈深度大于虚拟机所允许的最大深度、扩展栈容量无法申请到足够的内存。</li>
<li>方法区和运行时常量池溢出，一直创建字符串，使得字符串常量池溢出</li>
<li>本机的内存溢出，excel表中的数据太多，无法完全放到内存中，如果你要一起读出全部的数据，会发生内存溢出</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">美食家李老叭</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://laobameishijia.github.io/2024/07/09/qiu-zhi-zhi-lu-xue-xi/">https://laobameishijia.github.io/2024/07/09/qiu-zhi-zhi-lu-xue-xi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">美食家李老叭</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tag/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/">
                                    <span class="chip bg-color">常见知识</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'q5k1wXexowy7MeNN0CrLYpoK-gzGzoHsz',
        appKey: 'YmFtstASS0GUVRowdQQl4LPb',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/07/09/pwn-college-shellcode-injection-writeup/">
                    <div class="card-image">
                        
                        <img src="https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/20240709193107.png" class="responsive-img" alt="PWN-College-Shellcode-Injection-Writeup">
                        
                        <span class="card-title">PWN-College-Shellcode-Injection-Writeup</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            CTF
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-07-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/category/CTF/" class="post-category">
                                    CTF
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tag/%E9%80%86%E5%90%91/">
                        <span class="chip bg-color">逆向</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/07/09/qiu-zhi-zhi-lu-mian-jing/">
                    <div class="card-image">
                        
                        <img src="https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/QQ截图20240721095809.png" class="responsive-img" alt="求职之路-面经">
                        
                        <span class="card-title">求职之路-面经</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            求职
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-07-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/category/%E6%B1%82%E8%81%8C/" class="post-category">
                                    求职
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tag/%E9%9D%A2%E7%BB%8F/">
                        <span class="chip bg-color">面经</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('3'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2025</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">老叭美食家</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">256.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "5";
                        var startDate = "21";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/laobameishijia" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:994291043@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=994291043" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 994291043" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 05, 21, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/laobameishijia/laobameishijia.github.io@3.0/themes/hexo-theme-matery/source//libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
