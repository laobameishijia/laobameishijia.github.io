---
title: CTF-PWN-平衡栈帧
date: 2022-9-17 09:25:00
author: 美食家李老叭
img: https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220917162435.png
top: false
hide: false
cover: false
coverImg: 
password: 
toc: true
mathjax: false
summary: 平衡栈帧
categories: CTF
tags:
    - PWN
---

# 栈溢出

**先说明，以下讨论均在32位机器下进行讨论！**

这个栈溢出的例子,我是从b站up主Innks那里看到的。因为有些细节不理解，所以动手敲了一遍。

## 改进之前

改进之前由于没有平衡栈空间，导致栈空间被破坏，程序无法正确返回。

```c
#include <iostream>
#include <Windows.h>

#pragma optimize("",off)

void MsgBox()
{
    int ary[2];
    ary[4] = ary[3]; //相当于把ret返回地址复制了一遍
    ary[3] = (int)MessageBoxA;
    //ary[4] = ary[3]; //这条指令写到这个位置和写在上面一个位置是完全不一样的哟！
    ary[5] = 0;
    ary[6] = (int)"NO_CALL 恭喜你中毒了";
    ary[7] = (int)"NO_CALL 你中毒了";
    ary[8] = MB_OK;
}
int main()
{

    MsgBox();
    MessageBoxA(0, "恭喜你中毒了", "你中毒了", MB_OK);
}
```

## 改进之后

改进之后，可以正确的让程序结束

```c
#include <iostream>
#include <Windows.h>

#pragma optimize("",off)

void MsgBox()
{
    int ary[2];
    ary[4] = ary[3]; //相当于把ret返回地址复制了一遍
    ary[3] = (int)MessageBoxA;
    //ary[4] = ary[3]; //这条指令写到这个位置和写在上面一个位置是完全不一样的哟！
    ary[5] = 0;
    ary[6] = (int)"NO_CALL 恭喜你中毒了";
    ary[7] = (int)"NO_CALL 你中毒了";
    ary[8] = MB_OK;
}
int main()
{
    __asm push ebp;
    __asm push ebp;
    __asm push ebp;
    __asm push ebp;
    __asm push ebp;
    MsgBox();
    MessageBoxA(0, "恭喜你中毒了", "你中毒了", MB_OK);
}

```


## 改进前后的栈帧对比

由于ipencil长时间不用，现在才发现已经被我摔坏了，以后不常用的东西还是保管好呢，不要满不在意，用的时候才发现坏了。

所以我就直接用手写的图了，懒得画图了。

也确实是该换手机了，手机前置摄像头找出来的照片有点黑。


![栈空间对比](https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220917164427.jpg)

## 总结

因为我们采用栈溢出的方式调用了函数，那么应该`push到栈中的参数占的空间`占用了`其他栈帧的空间`。所以会导致后续程序流发生不可控制的变化。

![MessageBoxA的汇编代码](https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220917164601.png)

汇编中的`retn 10h`就是为了平衡call函数之前push到栈里面的参数所占的空间。第一开始不理解的地方就在于此，我觉得`retn 10h`平衡的也就是`4个参数--16字节`。但是up主却用了五个`push ebp`。

实际上，`retn 10h`使栈空间减少了20个字节的空间。

>retn操作：先eip=esp，然后esp=esp+4
>retn N操作：先eip=esp，然后esp=esp+4+N

所以是20个字节！也就是五个`push ebp`就可以提前把这20个字节的空间弄出来。而不用影响到后续main函数的栈帧。

除此之外呢，我还发现vs---debug编译模式和release模式，是非常不一样的。

![vs-debug&release](https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220917165306.png)

debug简单来说是为了方便分析程序，release模式是发布程序。我使用ida反汇编之后发现，debug生成的exe的汇编代码中添加了很多关于栈空间和一些寄存器的检查工作。而release模式下，是没有这些检查函数的。
