<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动漫-斗破苍穹</title>
      <link href="/2021/10/31/dong-man-dou-po-cang-qiong/"/>
      <url>/2021/10/31/dong-man-dou-po-cang-qiong/</url>
      
        <content type="html"><![CDATA[<h1 id="三年之约"><a href="#三年之约" class="headerlink" title="三年之约"></a>三年之约</h1><p>三年之约真的拍了三年，虽然没有看过小说，但随着慢慢地在看动漫以后，内心里也真正喜欢上了萧炎。可能动漫中确实有些夸张的地方，但还是能从中得到些许关于生活的感悟。</p><p>在第四季的结尾，萧炎临上云岚宗的那份淡然与宁静。他想到的是这三年间，帮助过他的人，自己经历过的事情。配上动漫的场景，的确看的出来制作方的确很用心。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211031212833.png" alt="临上云岚宗"></p><p>在忍受退婚之后，他一直以打败纳兰嫣然为目标，不断地去磨砺自己，增强自己的本领。但直到药老因为耗尽灵魂力量而进入沉睡状态的时候，萧炎才真正地明白：原来他是那么依赖药老。从那之后，他开始独自面对复杂的情况，准备唤醒药老的丹药。</p><p>萧炎也曾说，三年之约不过是给过去三年的一个交代。他真的是放下了，真正地专注于自己，而不是要打败谁。在经历了如此多的事情之后，他的内心真的已经很强大了。有的时候，我真觉得生活也是这样。我以前在高中的学习生活中，经常要以谁谁为目标，要在考试中超过他。但却总是事与愿违。经常因此灰心丧气许久。或者就是因为在打球的过程中，经常会有人嘲笑我，我就要非常努力地练球，证明给他们看。</p><p>可以说，前期的这些的确给了我很大的学习动力，但我因此浪费了很多不必要的精力和时间。因为我可能并没有想清楚自己想要活成什么样子。真正改变我的，就是复读的那一年。从现在的角度上来看，复读真的锻炼了我心理。几乎永远都在教室的最后面，老师不记得我的名字，同学只认识舍友，几乎没有任何娱乐活动。在那段日子里，我真的感觉自己每天都在进步，也或许正是从那个时候开始，我才明白我是要做我自己，不需要去看别人。正是这些经历，我在上大学之后，就一直锻炼自己的一个人生活的能力。</p><p>我再也不需要什么目标了，真正要做的就是不断地去完善自己。我不会左手，我就在寒假中努力的练习左手运球。我不会投三分，我就练深蹲和平板支撑锻炼自己的核心。并不是为了超越谁谁谁，也不是为了去赢得别人在球场上对我的赞美。就单纯地只是在完善自己。在家里没有球馆，没有场地，就自己去找没人的地方练习。令我很庆幸的是，路过的路人并没有嘲笑我。他们反而再说我是专业打球的。这真的令我很惭愧，也很高兴。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QQ%E5%9B%BE%E7%89%8720211031215440.jpg" alt="在家时训练的场地"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QQ%E5%9B%BE%E7%89%8720211031215449.jpg" alt="夕阳"></p><p>在学习上也是这样，虽然的确跟很多优秀的同学实在是没法比较，但我也习惯了这种巨大的差距。并不是躺平，我只是不想因为别人，而改变了我自己前进的方向。</p><p>就像片尾曲所唱的那样(<code>角色</code>)</p><blockquote><p>只需要 记得<br>从前现在 都要坚持 自我</p></blockquote><p>这文笔实在是差，写着写着就不知道写啥了。~~~~😀</p><p>以后我也想把这里当成个日记。想写的就随便写，反正也没人认识我。也没什么人可以看到。</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斗破苍穹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-直接定位表</title>
      <link href="/2021/10/26/hui-bian-yu-yan-xue-xi-zhi-jie-ding-wei-biao/"/>
      <url>/2021/10/26/hui-bian-yu-yan-xue-xi-zhi-jie-ding-wei-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h1><h2 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h2><p>以前我们多采用后面不带冒号的形式进行编程</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume:codecode segment    a: db 1,2,3,4,5,6,7,8    b: dw 0start:    mov si,offset a    mov bx,offset b    mov cx,8s:    mov al,cs:[si]    mov ah,0    add cs:[bx],ax    inc si    loop s    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>But the mark only represent the address of the memory. We still have another form of the mark that does not have the colon. For example.</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume:codecode segment    a db 1,2,3,4,5,6,7,8    b dw 0start:    mov si,offset a    mov bx,offset b    mov cx,8s:    mov al,a:[si]    mov ah,0    add bs,ax    inc si    loop s    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mov al,a[si]</code> equal to <code>mov al,cs:0[si]</code></p><p>So, we could find  the way helps us access the address of memory in a neat form. We call it data-mark.他标记了存储数据的单元的地址和长度，它不同于仅仅表示地址的标号。</p><h2 id="在其他段使用数据标号"><a href="#在其他段使用数据标号" class="headerlink" title="在其他段使用数据标号"></a>在其他段使用数据标号</h2><p>一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中，在其他段中，我们也可以使用数据标号来描述数据单元的地址和长度。</p><p><strong>注意：在后面加有‘：’的地址只能在代码段中使用，不能在其他段使用。</strong></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>安装一个新的int 7ch中断例程</p><blockquote><p>功能: 1.clear the screen<br>2.set the foreground<br>3.set the background<br>4.move up one row</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>编写新的int 7ch 中断例程</li><li>安装新的int 7ch 中断例程</li></ul><blockquote><p>这个实验过程的代码出了很多问题，到最后终于改好了。</p></blockquote><h4 id="初期的改错思路"><a href="#初期的改错思路" class="headerlink" title="初期的改错思路"></a>初期的改错思路</h4><p>the major problem 是中断例程中<code>table dw sub1,sub2,sub3,sub4</code>无法正常运作。<br>给人的感觉好像，不能在程序中用一样.按照这种形式写的话，后面的set标号无法被正确的编译。不知道为什么都变成了table标号下面的??</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211025211433.png" alt="问题1"></p><p>改成这种形式之后，才能在debug中的cpu看到正确的汇编代码，虽然代码段中把它们这些地址解析成了汇编指令</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211025210841.png" alt="问题2"></p><p>通过后续的观察发现,其实代码是被正确解析了的，只是在cpu版块的显示上table段中的存放的数据被当作了指令。但是为什么程序不执行呢？</p><blockquote><p>这也是为什么要把jmp命令放在前面的原因，就是为了不让table段存放的数据被当作指令执行，这样的话，肯定有问题的</p></blockquote><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211025212251.png" alt="改变写法后的对比图"></p><h4 id="后期的改错思路"><a href="#后期的改错思路" class="headerlink" title="后期的改错思路"></a>后期的改错思路</h4><p>先整理一下初期思路中出错的原因，再分析一下是哪些基础的知识没有掌握好，导致我们这么长时间一直在纠错</p><p><strong>初期思路：</strong></p><ul><li><p>1.jmp命令放在前面的原因，就是为了防止我们存储的数据被当作指令执行，这也是为什么你在debug模块中的cpu看汇编代码的时候，看起来好像很奇怪。但是它们都是正常的指令。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026164553.png" alt="cpu视角下的汇编代码"></p></li><li><p>2.<code>tabledata dw sub1,sub2,sub3,sub4;</code>无论是tabledata 还是 sub1，sub2 这些地址都是相对于最开始运行的CS段而言的，而我们想要的是中断例程，也就是执行中断例程的时候的CS段。这样去调用的话，肯定会出错。说成白话的话就是，本来一棵树距离图书馆35米，但是现在要问你，这棵树举例教学楼多少米，你要是还说35米。那是不是有点刻舟求剑的意思了。<strong>所以，真正要采用的是相对地址，还得加上0200h才行！</strong>    这样才行<code>tabledata dw offset sub1 - offset interupt + 0200h,offset sub2 - offset interupt+0200h,offset sub3 - offset interupt+0200h,offset sub4 - offset interupt+0200h</code></p></li><li><ol start="3"><li><code>call word ptr [bx]</code>这样默认的访问地址是 <code>ds+bx</code>，而你想要的是<code>cs:[bx]</code>所以要把寄存器显式的标注出来啊</li></ol></li><li><ol start="4"><li>虽然中断例程处，确实没有办法通过<code>F7</code>进入，但是可以通过看<code>0000:0200h</code>内存中代码，就可以发现到底是不是你想要的了。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026165549.png" alt="0000:0200处的代码"></li></ol></li><li><ol start="5"><li>int指令和iret指令的作用，如果真的能很好的掌握这两个指令，也犯不着这么长时间才找到问题的源头。</li></ol></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codecode segmentstart:    mov ax,cs    mov ds,ax    mov si,offset interupt; set the ds:si point to the source address    mov ax,0    mov es,ax    mov di,0200h; set the es:di point to the destination address    mov cx,offset interuptend-offset interupt; cx the length of transmisson    cld ; the sequence of the transmit    rep movsb    mov ax,0    mov es,ax    cli    mov word ptr es:[7ch*4],0200h    mov word ptr es:[7ch*4+2],0    sti    ;调用之前的设置你需要再看一下要求是怎么设置的    mov ah,2    mov al,3        int 7ch; 这里怎么跳到了4002h    ; call interupt    mov ax,4c00h    int 21h;所以程序大体上是没有问题的;但是加上table sub1,sub2,sub3,sub4之后就显的怪怪的;通过调试程序来看的话,只有mov bl,ah之后的程序是正常的;前面的程序好像都是错的一样,--通过CPU反汇编的指令来看的话,前面的几句都不对;我如果去掉table直接调用函数的话,就不会出现上述问题;对前面的简单程序进行操作后发现,这个table dw sub1,sub2,sub3,sub4不能在标号里面;也不是因为jmp short set语句和tabledata dw......两个语句的顺序问题;书上说interupt:    jmp short set    ;并不是写法是错的，而是你用错了    ;按道理来说,程序的执行CS IP 本来在code段    ;现在你引发了中断以后就跑到 中断例程中的CS IP了,但是此时 tabledata中保存的仍然是最开始的CS IP 这样一跳转的话,z    ; tabledata dw sub1,sub2,sub3,sub4;这种写法是错误的    ;写成下面这种形式的话，set标号就会重新显示出来    tabledata dw offset sub1 - offset interupt + 0200h,offset sub2 - offset interupt+0200h,offset sub3 - offset interupt+0200h,offset sub4 - offset interupt+0200h    ; tabledata dw offset sub1 - offset interupt + 0200h,offset sub2 - offset interupt + 0200h,offset sub3 - offset interupt + 0200h,offset sub4 - offset interupt + 0200hset:    push bx    push es    push cx    cmp ah,3;判读功能号是否大于3    ja sret    mov bl,ah    mov bh,0    add bx,bx;根据ah中的功能号计算对应子程序在table表中的偏移    add bx,offset tabledata-offset interupt + 0200h    ; call word ptr (offset tabledata-offset interupt)[bx+0200h];调用对应的功能子程序这句话有问题     ; 上面这条指令错就错在 这样隐含的寄存器是ds 也就是 访问的是ds:[...]但是我们想要的是cs:[bx]    call word ptr cs:[bx]    ; add bx,7e02h    ; jmp cs:[bx]sret:    pop cx    pop es    pop bx    ; ret    iret;make the screen emptysub1:    push bx    push cx    push es    mov bx,0b800h    mov es,bx    mov bx,0    mov cx,2000sub1s:    mov byte ptr es:[bx],' '    add bx,2    loop sub1s    pop es    pop cx    pop bx    ret    ; jmp sret; set the foregroundsub2:    push bx    push cx    push es    mov bx,0b800h    mov es,bx    mov bx,1    mov cx,2000sub2s:    and byte ptr es:[bx],11111000B    or es:[bx],al    add bx,2    loop sub2s    pop es    pop cx    pop bx    ret;set the background colorsub3:    push bx    push cx    push es    mov cl,4    shl al,cl    mov bx,0b800h    mov es,bx    mov bx,1    mov cx,2000sub3s:    and byte ptr es:[bx],10001111B    or es:[bx],al    add bx,2    loop sub3s    pop es    pop cx    pop bx    ret;scroll up one linesub4:    push cx    push si    push di    push es    push ds    mov si,0b800h    mov es,si    mov ds,si    mov si,160;ds:si指向第n+1行    mov di,0;es:di指向第n行    cld    mov cx,24;共复制24行sub4s:    push cx    mov cx,160    rep movsb    pop cx    loop sub4s    mov cx,80    mov si,0sub4s1:    mov byte ptr [160*24+si],' ';最后一行清空    add si,2    loop sub4s1    pop ds    pop es    pop di    pop si    pop cx    retinteruptend:    nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026170129.png" alt="清屏"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026170158.png" alt="设置前景色"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026170051.png" alt="设置背景色"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211026170240.png" alt="向上滚动一行"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-外中断</title>
      <link href="/2021/10/24/hui-bian-yu-yan-xue-xi-wai-zhong-duan/"/>
      <url>/2021/10/24/hui-bian-yu-yan-xue-xi-wai-zhong-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h1><h2 id="关于DOS-box是否真的操作硬件和内存的疑惑"><a href="#关于DOS-box是否真的操作硬件和内存的疑惑" class="headerlink" title="关于DOS-box是否真的操作硬件和内存的疑惑"></a>关于DOS-box是否真的操作硬件和内存的疑惑</h2><p>DOSBox is a <code>DOS-emulator</code> that uses the <code>SDL-library</code>which makes DOSBox very easy to port to different platforms. DOSBox has already been ported to many different platforms, such as Windows, BeOS, Linux, MacOS X…</p><p><code>Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D.</code>It is used by video playback software, emulators, and popular games including Valve’s award winning catalog and many Humble Bundle games.</p><p>SDL officially supports Windows, Mac OS X, Linux, iOS, and Android. Support for other platforms may be found in the source code.</p><p>SDL is written in C, works natively with C++, and there are bindings available for several other languages, including C# and Python.</p><h2 id="为什么有这个疑惑呢？"><a href="#为什么有这个疑惑呢？" class="headerlink" title="为什么有这个疑惑呢？"></a>为什么有这个疑惑呢？</h2><p>在之前的实验中，我们在中断向量表0000:0200至0000:02FF的部分增添了新的0号中断例程，并且修改了0号表项的入口地址，这样做，是不是影响了后续的程序呢？后面的程序是不是也会同样会收到影响呢？</p><p>好像是没有的,因为后面程序在<code>div指令溢出后</code>总是跑到一个循环里出不来</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211024105838.png" alt="1句"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211024105726.png" alt="2，3句"></p><p><strong>难道每次模拟的时候都会初始化？？也不是没有可能</strong></p><blockquote><p>通过本次实验的效果来看的话，上面的这个猜想是对的，也就是说DOS-box在每次重新打开的时候都会初始化，但是如果你不关闭这个DOS环境的话，它还是会影响下面的</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>安装一个新的int 9中断例程</p><blockquote><p>功能: 在DOS下，按下‘A’键后，除非不再松开，如果松开就显示全屏的A，其他键照常使用</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>编写新的int 9 中断例程</li><li>保存原有的int 9 地址</li><li>安装新的int 9 中断例程</li></ul><blockquote><p>感觉整个章节的思路比较有借鉴意义，当我没有不太想重新写一个函数，但是又要改善原有函数的功能的话，可以在新函数中去调用原函数，以屏蔽掉繁琐的步骤，更好的完善自己改善的功能。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codestack segment    db 128 dup(0)stack endscode segmentstart:    mov ax,stack    mov ss,ax    mov sp,128    push cs    pop ds    mov ax,0    mov es,ax    mov si,offset int9    mov di,204h    mov cx,offset int9end-offset int9    cld    rep movsb    push es:[9*4]    pop es:[200h]    push es:[9*4+2]    pop es:[202h]    cli    mov word ptr es:[9*4],204h    mov word ptr es:[9*4+2],0    sti;     mov ax,0b800h;     mov es,ax;     mov ah,'a'; s:;     mov es:[160*12+40*2],ah;     call delay;     inc ah;     cmp ah,'z';     jna s    mov ax,4c00h    int 21hint9:    push ax    push bx    push cx    push es    in al,60h        pushf    call dword ptr cs:[200h]    cmp al,1eh+80h    je printA    jmp int9retprintA:    ;if loose A    mov ax,0b800h    mov es,ax    mov bx,0    mov cx,2000s2:     mov byte ptr es:[bx],'A'    add bx,2    loop s2int9ret:    pop es    pop cx    pop bx    pop ax    iretint9end:    nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><strong>得先运行程序,然后在按下a就会有全屏A的效果了</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211024204149.png" alt="20211024204149"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-端口</title>
      <link href="/2021/10/23/hui-bian-yu-yan-xue-xi-duan-kou/"/>
      <url>/2021/10/23/hui-bian-yu-yan-xue-xi-duan-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>我们前面讲过,各种存储器都和CPU的地址线\数据线\控制线相连. CPU在操控它们的时候,把它们都当作内存来对待,把它们总地看作一个由若干存储单元组成的逻辑存储器,这个逻辑存储器我们称其位内存地址空间.</p><p>在PC机系统中,和CPU通过总线相连的芯片除各种存储器外,还有以下三种芯片.</p><ul><li>各种接口卡(比如 网卡\显卡) 上的接口芯片,它们控制接口卡进行工作;</li><li>主板上的接口芯片,CPU通过它们对部分外设进行访问;</li><li>其他芯片,用来存储相关的系统信息,或进行相关的输入输出处理</li></ul><p>在这些芯片中,都由一组可以由CPU读写的寄存器.这些寄存器,它们在物理上可能处于不同的芯片中,但是它们在以下两点上相同:</p><ul><li>都和CPU的总线相连,当然这种链接是通过它们所在的芯片进行的</li><li>CPU对它们进行读或者写的时候都通过控制线向它们所在的芯片发出端口读写命令</li></ul><p>可见,从CPU的角度,这些寄存器都当作端口,对它们进行统一编址,从而建立了一个统一的端口地址空间.每一个端口在地址空间中都有一个地址.</p><p>CPU 可以直接独写以下三个地方的数据:</p><ul><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ul><h2 id="端口独写"><a href="#端口独写" class="headerlink" title="端口独写"></a>端口独写</h2><h3 id="访问内存"><a href="#访问内存" class="headerlink" title="访问内存"></a>访问内存</h3><p><code>mov ax,ds:[8]</code></p><ul><li>CPU通过地址线将地址信息8发出</li><li>CPU通过控制线发出内存读命令,选中存储器芯片,并通知它,将要从中读取数据</li><li>存储器将8号单元中的数据通过数据线送入CPU</li></ul><h3 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h3><p><code>int al,60h</code></p><ul><li>CPU通过地址线将地址信息60h发出;</li><li>CPU通过控制线发出端口读命令,选中端口所在的芯片,并通知它,将要从中读取数据</li><li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>CMOS RAM 中,存放着当前的时间: 年\月\日\时\分\秒,这六个信息的长度均为1字节.以BCD码的方式存放</p><blockquote><p>编程 以 <code>年/月/日 时:分:秒</code>的格式,显示当前的日期\时间</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>因为读写的单元不是很有规律,所以只能一个一个的写了</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codedata segment    db 20 dup(0)data ends;s min hour day month yearcode segmentstart:    ;s    mov bl,0    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax        ;分    mov bl,2    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax        ;时    mov bl,4    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax    ;日    mov bl,7    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax        ;月    mov bl,8    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax    ;年    mov bl,9    mov al,bl    out 70h,al    in al,71h    mov ah,al    mov cl,4    shr ah,cl;右移四位,取高4位    and al,00001111b;与,取低4位        add ah,30h    add al,30h    push ax    mov ax,data    mov ds,ax    pop ax    mov ds:[0],ah    mov ds:[1],al    mov byte ptr ds:[2],'/'    pop ax    mov ds:[3],ah    mov ds:[4],al    mov byte ptr ds:[5],'/'        pop ax    mov ds:[6],ah    mov ds:[7],al        mov byte ptr ds:[8],' '        pop ax    mov ds:[9],ah    mov ds:[10],al    mov byte ptr ds:[11],':'        pop ax    mov ds:[12],ah    mov ds:[13],al    mov byte ptr ds:[14],':'    pop ax    mov ds:[15],ah    mov ds:[16],al    mov bx,0b800h    mov es,bx    mov si,0    mov bx,0    mov cx,0s:     mov byte ptr cl,ds:[bx]    jcxz ok    mov byte ptr es:[160*12+40*2+si],cl    inc bx    add si,2    jmp sok:    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211023202035.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-int指令</title>
      <link href="/2021/10/23/hui-bian-yu-yan-xue-xi-int-zhi-ling/"/>
      <url>/2021/10/23/hui-bian-yu-yan-xue-xi-int-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211023100523.png" alt="思维导图"></p><h2 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h2><ul><li>开机后，CPU一加电，初始化CS=0FFFFH，IP=0，自动从FFFF：0单元开始执行程序。FFFF：0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件检测系统和初始化程序</li><li>初始化程序将建立BIOS所支持的中断向量。<blockquote><p>注意， 对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为他们是固化到ROM中的程序，一直在内存中存在</p></blockquote></li><li>硬件系统检测和初始化完成后，调用int 19h进行操作系统引导。从此将计算机交由操作系统控制。</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</li></ul><h2 id="实验13"><a href="#实验13" class="headerlink" title="实验13"></a>实验13</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote><p>编写并安装int 7ch中断例程，功能为显示一个用0结束的字符串，中断例程安装在0：200处<br>dh 行号，dl 列号， cl 颜色， ds:si指向字符串首地址</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>编写能显示字符串的中断处理程序</li><li>将终端服务程序移动到0000:0200处</li><li>修改中断向量表中的7cH号中断的入口地址,使其指向0000:0200</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><blockquote><p>一些注意事项和问题就写到注释里面了,后面忘了的话记得看看</p></blockquote><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codedata segment    db 'welcome to masm!',0data endscode segmentstart:    mov ah,15    int 10h    mov ah,0    int 10h    mov ax,cs    mov ds,ax    mov si,offset interupt; set the ds:si point to the source address    mov ax,0    mov es,ax    mov di,200h; set the es:di point to the destination address    mov cx,offset interuptend-offset interupt; cx the length of transmisson    cld ; the sequence of the transmit    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[7ch*4],200h    mov word ptr es:[7ch*4+2],0        mov dh,10    mov dl,10    mov cl,2    mov ax,data    mov ds,ax    mov si,0    int 7ch    mov ax,4c00h    int 21h;dh 行号;dl 列号;cl 颜色;ds:si 指向字符串首地址interupt:    mov ax,0b800h    mov es,ax    ;找行号对应的内存地址    mov ah,00    mov al,160    mul dh    mov bp,ax    ;找列对应的内存地址    mov ah,00    mov al,2    mul dl    mov di,ax    s:        mov al,ds:[si]        cmp al,0        je ok        mov es:[bp+di],al        mov es:[bp+di+1],cl        inc si        add di,2        jmp s    ok:        iretinteruptend:    nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211023102716.png" alt="实现效果"></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote><p>编写并安装int 7ch中断例程，功能为完成loop指令的功能<br>cx为循环次数，bx为位移</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>编写能实现loop循环的中断处理程序</li><li>将终端服务程序移动到0000:0200处</li><li>修改中断向量表中的7cH号中断的入口地址,使其指向0000:0200</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codedata segment    db 'welcome to masm!',0data endscode segmentstart:    mov ah,15    int 10h    mov ah,0    int 10h    mov ax,cs    mov ds,ax    mov si,offset interupt; set the ds:si point to the source address    mov ax,0    mov es,ax    mov di,200h; set the es:di point to the destination address    mov cx,offset interuptend-offset interupt; cx the length of transmisson    cld ; the sequence of the transmit    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[7ch*4],200h    mov word ptr es:[7ch*4+2],0    mov ax,0b800h    mov es,ax    mov di,160*12    mov bx, offset s - offset se    mov cx,80s:    mov byte ptr es:[di],'!'    add di,2    int 7chse:     nop    mov ax,4c00h    int 21h;采用中断方式实现的loop,转移的范围要更大因为时16位的;正常情况下的loop是8位的,范围相对来说要小一些interupt:    push bp    mov bp,sp    dec cx    jcxz interuptret;就是加不加bx的区别,当cx为零的时候,这个时候就不加bx也就是不会再跳回去了    add ss:[bp+2],bx;注意这个bx是个负数！interuptret:    pop bp    iretinteruptend:    nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211023102946.png" alt="实现效果"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote><p>下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序.</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>这里面有个写法挺奇妙的, <code>ds:[ds:[si]]</code>是可以这样嵌套着写的</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codecode segments1: db 'Good,better,best,','$'s2: db 'Never let it rest,','$'s3: db 'Till good is better,','$'s4: db 'And better,best.','$'s:  dw offset s1, offset s2, offset s3,offset s4row: db 2,4,6,8start:    mov ah,15    int 10h    mov ah,0    int 10h    mov ax,cs    mov ds,ax    mov bx,offset s    mov si,offset row;行号    mov cx,4ok:    mov bh,0;第0页    mov dh,ds:[si];这个行号怎么不起作用呢    mov dl,0;列号    mov ah,2    int 10    mov dx,ds:[ds:[bx]];可以这样嵌套着写！我真是个大聪明！哈哈哈哈哈~~~    mov ah,9    int 21h        ;直接在这里加就行了,不用非得跑到mov指令那里加    ;不能直接加 标号,得加寄存器,你个憨憨    add si,1    add bx,2    loop ok    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>有个疑惑就是为什么这个地方的行号和列号的改变不起作用呢??</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211023103301.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-内中断</title>
      <link href="/2021/10/21/hui-bian-yu-yan-xue-xi-nei-zhong-duan/"/>
      <url>/2021/10/21/hui-bian-yu-yan-xue-xi-nei-zhong-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211021105626.png" alt="思维导图"></p><h2 id="debug单步执行命令的原理"><a href="#debug单步执行命令的原理" class="headerlink" title="debug单步执行命令的原理"></a>debug单步执行命令的原理</h2><p>基本上,CPU在执行完一条指令之后,如果检测到标志寄存器的TF位为1,则产生单步中断,引发中断的过程。单步中断的中断类型码为1,则它引发的中断过程如下:</p><ul><li>取得中断码类型1</li><li>标志寄存器入栈,TF\IF设置为0</li><li>CS、IP入栈</li><li>IP=(1<em>4),CS=(1</em>4+2)</li></ul><p>首先Debug提供了单步中断的中断处理程序,功能为显示所有寄存器中的内容后等待输入命令。然后,在使用t命令执行执行时,Debug将TF设置为1,使得CPU工作于中断方式下,则在CPU执行完这条指令后就引发单步中断,执行单步中断的中断处理程序,所有寄存器中的内容将被显示在屏幕上，并且等待输入命令。</p><p>在进入中断处理程序之前,设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断。这就是为什么在终端过程中有TF=0这一步。</p><p>最后,CPU提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供实现机制</p><h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><p>一般情况下,CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会相响应。对于这些情况，下面列举其中一种情况来进行说明。</p><p>在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会相应。这样做的主要原因是，SS:SP联合指向栈顶，而对它们的设置应该连续完成。如果在设置完ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器，cs和ip的值。而ss改变，sp并未改变，ss：sp指向的不是正确的栈顶，将引起出错误。所以CPU在执行完设置ss 的指令后，不响应中断。</p><p>所以我们应该利用这个特性，将设置ss和sp的指令连续存放。</p><h2 id="实验12"><a href="#实验12" class="headerlink" title="实验12"></a>实验12</h2><blockquote><p>编写0号中断的处理程序,使得在除法溢出发生时,在屏幕中间显示字符串”divide error!”,然后返回到DOS</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>编写能显示divide error！的0号中断处理程序</li><li>将终端服务程序移动到0000:0200处</li><li>修改中断向量表中的0号中断的入口地址,使其指向0000:0200</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><p>一些注意事项和问题就写到注释里面了,后面忘了的话记得看看</p></blockquote><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codecode segmentstart:;清屏    mov ah,15    int 10h    mov ah,0    int 10h;将do0送入内存0000:0200处    ;ds:si传送的原始位置    mov ax,code    mov ds,ax    mov si,offset do0    ;es:di传送的目的位置    mov ax,0000    mov es,ax    mov di,0200h;！！！！0200后面要加h啊！！     ;传送的长度    mov cx,offset do0end - offset do0    ;传送的方向 正向传送    cld    rep movsb;将do0的入口地址0000:0200存储在中断向量表0号表项中    mov ax,0000    mov es,ax    mov word ptr es:[0],0200h ;！！！！在没有寄存器显示指示操作的数据大小的时候,一定要用word或者byte显式指明    mov word ptr es:[2],0000h ;另外你只用写往里面存的数就行了,不用按照高低字节改变,他自己会改变的    mov ax,1000    mov bh,1    div bh    mov ax,4c00h    int 21;可以显示 overflow的中断处理程序 do0do0:    jmp do0start    db 'divide error!'do0start:    mov ax,cs    mov ds,ax    mov si,0202h ;设置ds:si指向字符串        mov ax,0B800H    mov es,ax    mov di,12*160+36*2 ;设置es:di指向字符串        ;明白为什么这里它不用这个rep的命令了把,因为显存里面的结构是 要显示的字符+颜色背景啥的,但是这个只能是一个一个的加    mov cx,13;设置字符串长度    ; cld;设置传输方向    ; rep movsb    s:        mov al,[si]        mov es:[di],al        inc si        add di,2;为什么不用rep命令的原因就在这        loop s    mov ax,4c00h    int 21hdo0end:    nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-标志寄存器</title>
      <link href="/2021/10/20/hui-bian-yu-yan-xue-xi-biao-zhi-ji-cun-qi/"/>
      <url>/2021/10/20/hui-bian-yu-yan-xue-xi-biao-zhi-ji-cun-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211020165355.png" alt="思维导图"></p><h2 id="计算机是如何知道到底是按有符号数处理还是按无符号数处理"><a href="#计算机是如何知道到底是按有符号数处理还是按无符号数处理" class="headerlink" title="计算机是如何知道到底是按有符号数处理还是按无符号数处理"></a>计算机是如何知道到底是按有符号数处理还是按无符号数处理</h2><p>CPU在执行add等指令的时候,就包含了两种含义:无符号数运算和有符号数运算。对于无符号数运算,CPU用CF位来记录是否产生了进位;对于有符号数运算,CPU用OF位来记录是否产生了溢出,当然,还要用SF位记录结果的符号。CF和OF所表示的进位和溢出,是分别对无符号数和有符号数运算而言的,他们之间没有任何关系。</p><p>也就是说,本身就是有两层含义都在,但具体看作哪一种,取决于写程序的你怎么处理这些变换的标志位。如何利用这些标志位和运算结果来正确的表达你想要的计算方式。</p><h2 id="实验11"><a href="#实验11" class="headerlink" title="实验11"></a>实验11</h2><blockquote><p>编写一个子程序,将包含任意字符,以0结尾的字符串中的小写字母转变成大写字母,描述如下。<br>名称：letterc<br>功能：将以0为结尾的字符串中的小写字母转变成大写字母<br>参数：ds:si指向字符串首地址</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>判断所取到的字节数据是不是0,是的话结束,不是的话,继续判断</li><li>判断取到的字节数据是不是小写字母。是的话,转变成大写字母；不是的话,就不变</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesgdatasg segment    db "Beginner's All-purpose Symbolic Instruction Code.",0datasg endscodesg segment    begin:        mov ax,datasg        mov ds,ax        mov si,0        call letterc        mov ax,4c00h        int 21hletterc:    mov ch,00    mov cl,ds:[si]    jcxz ok    cmp cx,97    jb next    cmp cx,122    ja next    sub cx,32    mov ds:[si],clnext:    inc si    jmp lettercok:     retcodesg endsend begin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决主题代码块没有行号的问题</title>
      <link href="/2021/10/19/jie-jue-zhu-ti-dai-ma-kuai-mei-you-xing-hao-de-wen-ti/"/>
      <url>/2021/10/19/jie-jue-zhu-ti-dai-ma-kuai-mei-you-xing-hao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="解决主题代码块没有行号的问题"><a href="#解决主题代码块没有行号的问题" class="headerlink" title="解决主题代码块没有行号的问题"></a>解决主题代码块没有行号的问题</h1><p>也是看了网上许多的解决方案,因为自己并不是很清楚这个hexo渲染页面详细的原理,所以对于一些基本的解决方案并没有自己的思考。通过观察别人的博客,通过控制台看其他人的css、js文件,终于发现可能是主题本身就没有写这部分,所以即使设置改回来了,还是没有办法实现。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-在主题下的source-css-matery-css下添加如下代码"><a href="#1-在主题下的source-css-matery-css下添加如下代码" class="headerlink" title="1.在主题下的source/css/matery.css下添加如下代码"></a>1.在主题下的source/css/matery.css下添加如下代码</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211019164659.png" alt="具体目录"></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.line-numbers-rows</span> <span class="token punctuation">&#123;</span>    <span class="token property">border-right-width</span><span class="token punctuation">:</span> 0px <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.line-numbers</span> <span class="token punctuation">&#123;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> 1.5rem 1.5rem 1.5rem 3.5rem <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 1rem 0 <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> #272822<span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> 0.35rem<span class="token punctuation">;</span>    <span class="token property">tab-size</span><span class="token punctuation">:</span> 4<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-在主题下的source-libs-prism-prism-css中添加如下代码"><a href="#2-在主题下的source-libs-prism-prism-css中添加如下代码" class="headerlink" title="2.在主题下的source/libs/prism/prism.css中添加如下代码"></a>2.在主题下的source/libs/prism/prism.css中添加如下代码</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">pre[class*="language-"].line-numbers</span> <span class="token punctuation">&#123;</span> <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token property">padding-left</span><span class="token punctuation">:</span> 3.8em<span class="token punctuation">;</span> <span class="token property">counter-reset</span><span class="token punctuation">:</span> linenumber<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">pre[class*="language-"].line-numbers > code</span> <span class="token punctuation">&#123;</span> <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token property">white-space</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.line-numbers .line-numbers-rows</span> <span class="token punctuation">&#123;</span> <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token property">pointer-events</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> -3.8em<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span> <span class="token comment">/* works for line-numbers below 1000 lines */</span> <span class="token property">letter-spacing</span><span class="token punctuation">:</span> -1px<span class="token punctuation">;</span> <span class="token property">border-right</span><span class="token punctuation">:</span> 1px solid #999<span class="token punctuation">;</span> <span class="token property">-webkit-user-select</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token property">-moz-user-select</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token property">-ms-user-select</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token property">user-select</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token selector">.line-numbers-rows > span</span> <span class="token punctuation">&#123;</span>  <span class="token property">pointer-events</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">counter-increment</span><span class="token punctuation">:</span> linenumber<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token selector">.line-numbers-rows > span:before</span> <span class="token punctuation">&#123;</span>   <span class="token property">content</span><span class="token punctuation">:</span> <span class="token function">counter</span><span class="token punctuation">(</span>linenumber<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token property">color</span><span class="token punctuation">:</span> #999<span class="token punctuation">;</span>   <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>   <span class="token property">padding-right</span><span class="token punctuation">:</span> 0.8em<span class="token punctuation">;</span>   <span class="token property">text-align</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码块行数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-课程设计</title>
      <link href="/2021/10/18/hui-bian-yu-yan-xue-xi-ke-cheng-she-ji/"/>
      <url>/2021/10/18/hui-bian-yu-yan-xue-xi-ke-cheng-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h1><p>在整个课程中,我们一共有两个课程设计,编写两个比较综合的程序,这是第一个。任务:将实验7中的power idea公司的数据按照图10.2所示的格式在屏幕上显示出来。</p><p><strong>效果</strong><br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211018160247.png" alt="20211018160247"></p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul><li>从数字转换成字符串–通过除以10来不断获取余数,在加上30,最后再逆向输出</li><li>因为程序要显示的数据有些已经大于65535,应该编写一个新的数据到字符串转换的子程序,完成dword型到字符串的转换</li><li>在循环中如何选择寄存器(组合)来实现对有规律数据的复制</li><li>对数据存储结构和控制移位的寄存器值的变化的控制</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然实现了效果,但是在思路上还是比较凌乱,尤其是在整体的思路上面.还是改不了边写边改的毛病.</p><ul><li><input disabled="" type="checkbox"> 后面还是要不断的把代码再优化优化</li></ul><h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><h3 id="寄存器寻址组合"><a href="#寄存器寻址组合" class="headerlink" title="寄存器寻址组合"></a>寄存器寻址组合</h3><p>已知的是 di+bp / bx+si / bx+di 这几种可以用来在内存中遍历数据,在用之前,需要搞清楚,数据元素的确定最少需要几个变化的值来定位。</p><h3 id="条件指令的转移范围"><a href="#条件指令的转移范围" class="headerlink" title="条件指令的转移范围"></a>条件指令的转移范围</h3><p>条件指令的转移范围只能是从(-128-127),如果想要跳转的位置超过了这个范围,可以先跳到附近的位置,再在附近的位置利用无条件指令跳到想跳到的位置。</p><h3 id="汇编语言清除屏幕输出"><a href="#汇编语言清除屏幕输出" class="headerlink" title="汇编语言清除屏幕输出"></a>汇编语言清除屏幕输出</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">mov ah,15int 10hmov ah,0int 10h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li>哪些寄存器在循环的过程中需要变化,哪些寄存器需要在下一次循环或者调用子程序之前初始化,这些都要搞清楚</li><li>再利用div等有范围和大小限制的指令时,考虑一下是否会有溢出的情况</li><li>jmp和je等条件跳转指令如何实现循环的过程</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">;TODO ;1.现在 char段前面四个字节的年份复制完成了 √;2.着手将收入转换位为字符串并存在char段中  √;3.下一步是 将雇员数转换为字符串存在char段中,这个应该不用divdw了 √;4.最后一步就是显示了,不过应该也是比较头疼的把 √;整理TODO;1.整理一下到底哪几个寄存器可以组合起来用来寻址,我快疯了~~~;已知的是di+bp/bx+si/bx+diassume cs:codesg,ds:datadata segment    ;0    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'    db '1993','1994','1995'    ;54H    dd 16,22,382,1356,2390,8000,160000,24486,50065,97479,140417,197514    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000        ;A8H    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226    dw 11542,14430,15257,17800data endstable segment    db 21 dup ('year summ ne ?? ')table endschar segment    db 672 dup(0) ;672 = 32*21 每一年的数据占23个字节(取个整数刚好是32个字节-16的倍数), 一共有21年    ;00 XXXX    ;03 XXXX    ;06 XXXX    ;09 XXXX    ;年份 1997          4字节    ;空格               1字节-5    ;收入 max = 5937000 7个字节    ;空格               1字节-13        ;雇员数 max = 17800 5个字节    ;空格               1字节-19    ;人均收入 max = 333  3个字节    ;空格               1字节char endstestsg segment    db 1680 dup(0) testsg segmentcodesg segmentstart:    mov ah,15    int 10h    mov ah,0    int 10h    mov ax,data    mov ds,ax    mov ax,table    mov es,ax    call calculate_income    mov ax,table    mov ds,ax    mov ax,char    mov es,ax    call duplicate_year        call num_char    call employees_char    call average_salary_char    call show_str        mov ax,4c00h    int 21h;将数据存入显存当中show_str:    mov ax,char    mov ds,ax    mov ax,0B800H    mov es,ax        mov dh,4;行号    mov dl,0;列号    mov cl,2;颜色    mov bx,0    show_str_year:        push dx        ;找行号对应的内存地址        mov ah,00        mov al,160        mul dh        mov bp,ax        ;找列对应的内存地址        mov ah,00        mov al,2        mul dl        mov di,ax                ; ;找行号对应的内存地址--数据段        ; mov ah,00        ; mov al,10H        ; mov dl,dh        ; mov dh,0        ; mul dx        ; mov bx,ax        ;把颜色转移一下        mov al,cl        push cx        mov si,0        show_str_year_loop:            mov cl,ds:[bx+si]            mov ch,0            jcxz show_str_year_loop_ok            mov es:[bp+di],cl            mov es:[bp+di+1],al            add di,2            add si,1            jmp short  show_str_year_loop        show_str_year_loop_ok:            pop cx            mov dl,10;列号            ;更新下一个列地址            mov ah,00            mov al,2            mul dl            mov di,ax            ;把颜色再设置回来            mov al,cl                push cx        mov si,0        show_str_income_loop:            mov cl,ds:[bx+si+5]            mov ch,0            jcxz show_str_income_loop_ok            mov es:[bp+di],cl            mov es:[bp+di+1],al            add di,2            add si,1            jmp short  show_str_income_loop        show_str_income_loop_ok:            pop cx            mov dl,20;列号            ;更新下一个列地址            mov ah,00            mov al,2            mul dl            mov di,ax            ;把颜色再设置回来            mov al,cl                push cx        mov si,0        show_str_employees_loop:            mov cl,ds:[bx+si+13]            mov ch,0            jcxz show_str_employees_loop_ok            mov es:[bp+di],cl            mov es:[bp+di+1],al            add di,2            add si,1            jmp short  show_str_employees_loop        show_str_employees_loop_ok:            pop cx            mov dl,30;列号            ;更新下一个列地址            mov ah,00            mov al,2            mul dl            mov di,ax            ;把颜色再设置回来            mov al,cl        push cx        mov si,0        show_str_average_loop:            mov cl,ds:[bx+si+19]            mov ch,0            jcxz show_str_average_loop_ok            mov es:[bp+di],cl            mov es:[bp+di+1],al            add di,2            add si,1            jmp short  show_str_average_loop        show_str_average_loop_ok:            pop cx            mov dl,40;列号            ;更新下一个列地址            mov ah,00            mov al,2            mul dl            mov di,ax            ;把颜色再设置回来            mov al,cl                       pop dx        add bx,20H        add dh,1;行号加一        mov dl,0;列号清零        mov ax,21        sub al,dh        cmp byte ptr al,0        ; cmp byte ptr dh,21        ;je show_str_ok;这很明显不相等啊,为什么还跳转了？        ;你应该是跳转到循环里才对,如果不是跳到循环里,它其实没有发生跳转,只是按顺序往下执行刚好到下面了        je show_str_ok;这样写也跳转了。。？？        show_str_year_relay:            jmp show_str_year    show_str_ok:        ret;把人均工资部分转换成字符串average_salary_char:    mov bx,0    mov di,0    mov cx,21    average_salary_char_all:        push cx        mov ax,ds:[bx+0DH]        mov dx,0        mov si,0        mov bp,10        average_salary_char_one:                div bp            cmp ax,0            je average_salary_char_one_ok            push dx            mov dx,0            inc si            jmp average_salary_char_one        average_salary_char_one_ok:            push dx            inc si                        mov cx,si            mov si,0            mov bp,0            average_salary_char_one_ok_loop:                pop ax                add al,30H                mov es:[di+bp+19],al                inc bp                loop average_salary_char_one_ok_loop        pop cx        add bx,10H        add di,20H        loop average_salary_char_all    ret;把雇员数部分转换成字符串employees_char:    mov bx,0    mov di,0    mov cx,21    employees_char_all:        push cx        mov ax,ds:[bx+0AH]        mov dx,0        mov si,0        mov bp,10        employees_char_one:                div bp            cmp ax,0            je employees_char_one_ok            push dx            mov dx,0            inc si            jmp employees_char_one        employees_char_one_ok:            push dx            inc si                        mov cx,si            mov si,0            mov bp,0            employees_char_one_ok_loop:                pop ax                add al,30H                mov es:[di+bp+13],al                inc bp                loop employees_char_one_ok_loop        pop cx        add bx,10H        add di,20H        loop employees_char_all    ret;把收入部分的数字转换为字符串存储到内存当中num_char:    mov bx,0    mov cx,21    num_char_loop:        push cx                mov si,0        mov di,0        mov ax,ds:[bx+5H]        mov dx,ds:[bx+7H]        mov cx,0AH        ;具体的一个数转换为字符        num_char_loop_div:            call divdw            mov bp,0            ;如果dx和ax都为零说明该数转换完成            mov bp,dx            or bp,ax            cmp bp,0            je num_char_loop_div_ok            push cx;余数入栈            inc si            mov cx,0AH;每次跳回去之前要把cx再设置为零            jmp num_char_loop_div            num_char_loop_div_ok:                ;最后一个商小于10,上面没办法入栈了                push cx;在这里把这个入栈                inc si                mov cx,si;si中保留着这个具体数的所有余数                mov bp,0                mov ax,2H                mul bx                 mov di,ax                 num_char_loop_div_ok_loop:                        pop ax                    add ax,30H                    mov es:[di+5H+bp],al                    add bp,1                    loop num_char_loop_div_ok_loop                ; ;填了个空格                ; mov al,' '                ; mov es:[di+5H+bp],al        pop cx        add bx,10H        loop num_char_loop;把data段中的年份复制到char段里面去duplicate_year:    mov bx,0    mov si,0    mov di,0    mov cx,21    duplicate_year_all:        push cx        mov cx,2        mov bx,0        duplicate_year_year:            mov ax,ds:[di+bx]            mov es:[si+bx],ax            add bx,2            loop duplicate_year_year        ; ;添个空格         ; mov al,' '        ; mov es:[si+bx],al        add si,20H        add di,10H        pop cx        loop duplicate_year_all    ret;刚好是之前计算人均收入程序calculate_income:    mov bx,0;bx定位data段,bx year和收入都是四个字节可以公用,但是雇员数是两个字节的没办法公用    mov bp,0;bp定位es段    mov di,0;di用来在循环中服务于雇员数,因为它是两个字节,没办法跟year和outcome公用一个递增寄存器    mov cx,21    overall:        push cx        mov cx,2        mov si,0        year:            ;年份的4字节---两个字            mov ax,ds:[bx+si]            mov es:[bp+si],ax            add si,2            loop year        mov cx,2        mov si,0        outcome:            ;收入的4字节---两个字            mov ax,ds:[bx+54H+si]            mov es:[bp+5H+si],ax            add si,2            loop outcome        ;雇员数---一个字        mov ax,ds:[di+0A8H]        mov es:[bp+0AH],ax        ;计算人均收入        mov ax,es:[bp+5H];计算人均收入的,要用es的定位,那偏移量就得按照es的来。最开始写成ds的定位了[bx+54H]了        mov dx,es:[bp+5H+2]        div word ptr es:[bp+0AH]        mov es:[bp+0DH],ax        ;所有的空格        ;第一次没有考虑到空格是一个字节,这里不应该用16位的,应该用8位的        mov al,' '        mov es:[bp+4H],al        mov es:[bp+9H],al        mov es:[bp+0FH],al        pop cx        add di,2        add bx,4        add bp,16        loop overall    ret;名称：divdw;功能：进行不会产生溢出的除法运算,被除数为dword,除数为word.结果为dword;参数: ax dword的低16位 | dx dword高16位 | cx除数16位;返回: dx 结果的高16位, ax 结果的低16位, cx 余数;应用举例：计算 1000000/10(F4240H/0AH);结果: dx = 0001H  ax = 86A0H cx = 0divdw:    push si    push bx    push ax    mov ax,dx    div cl    mov bl,al    mov bh,00H    mov al,ah    mov ah,00H;bx保留商,ax保留余数    pop si    mov dx,si    mov dx,ax    mov ax,si    div cx;32/16 ax余数,dx商    mov si,bx    mov bx,dx    mov dx,si    mov cx,bx    pop bx    pop si    retcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-call和ret指令</title>
      <link href="/2021/10/16/hui-bian-yu-yan-xue-xi-call-he-ret-zhi-ling/"/>
      <url>/2021/10/16/hui-bian-yu-yan-xue-xi-call-he-ret-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="call和ret指令"><a href="#call和ret指令" class="headerlink" title="call和ret指令"></a>call和ret指令</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211016111954.png" alt="思维导图"></p><p>关于使用栈来传递参数并用ret返回的实际例子还是需要多看才行。</p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><h3 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">名称：show_str功能：在指定的位置,用指定的颜色,显示一个用0结束的字符串参数：dh 行号(0-24), dl 列号 0-79, cl颜色, ds:si指向字符串的首地址返回: 无应用举例：在屏幕的8行3列,用绿色显示出data段中的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codedata segment    db 'Welcome to masm!',0data endscode segmentstart:    mov dh,8    mov dl,3    mov cl,2    mov ax,data    mov ds,ax    mov si,0    call show_str        mov ax,4c00h    int 21hshow_str:    push es    push bp    push bx    mov ax,0B800H    mov es,ax    ;找行号对应的内存地址    mov al,160    mul dh    mov bp,ax    sub bp,160    ;找列对应的内存地址    mov al,2    mul dl    mov di,ax    sub di,2    ;把颜色转移一下    mov bl,cl    push cxs:     mov cl,ds:[si]    mov ch,0    jcxz ok    mov es:[bp+di],cl    mov es:[bp+di+1],bl    add di,2    add si,1    jmp short sok:    pop cx    pop bx    pop bp    pop es    retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211016112701.png" alt="显示字符串"></p><h3 id="解决除法溢出的问题"><a href="#解决除法溢出的问题" class="headerlink" title="解决除法溢出的问题"></a>解决除法溢出的问题</h3><p>用div指令做出发的时候可能产生除法溢出,比如:1000000/10就不能用div指令来算</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">名称：divdw功能：进行不会产生溢出的除法运算,被除数为dword,除数为word.结果为dword参数: ax dword的低16位 | dx dword高16位 | cx除数返回: dx 结果的高16位, ax 结果的低16位, cx 余数应用举例：计算 1000000/10(F4240H/0AH)结果: dx = 0001H  ax = 86A0H cx = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesgdatasg segmentdatasg endscodesg segmentstart:    mov ax,4240H    mov dx,000FH    mov cx,0AH    call divdw    mov ax,4c00h    int 21h;这里面就是因为 div 被除数默认放在ax | dx(高)和ax(低)中,所以比较麻烦;除数可以放在寄存器里也可以放在内存单元里，有8/16两种, 8-AL商 AH余数 || 16-AX商 DX余数;再就是因为数据运算要符合相同的类型,同为16或同为8,在寄存器里面换来换去的就比较麻烦divdw:    push ax    mov ax,dx    div cl    mov bl,al    mov bh,00H    mov al,ah    mov ah,00H;bx保留商,ax保留余数    pop si    mov dx,si    mov dx,ax    mov ax,si    div cx;32/16 ax余数,dx商    mov si,bx    mov bx,dx    mov dx,si    mov cx,bx    retcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行截图-1"><a href="#运行截图-1" class="headerlink" title="运行截图"></a>运行截图</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211016113513.png" alt="解决除法溢出的问题"></p><h3 id="数值显示"><a href="#数值显示" class="headerlink" title="数值显示"></a>数值显示</h3><p>将12666以字符串的形式显示到显示器上</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">名称：dtoc功能：将word型数据转变为十进制的字符串,字符串以0为结尾符参数：ax word型数据    ds:si指向字符串的首地址返回：无应用举例: 将12666以十进制的形式在屏幕的8行3列,用绿色显示出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="改进前代码"><a href="#改进前代码" class="headerlink" title="改进前代码"></a>改进前代码</h4><p>改进前,主要是利用在内存中的位置,来对字符串进行逆向的输出。因为算余数的话,顺序是66621得倒过来才行</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:code,ds:datadata segment    db 10 dup(0)data endscode segmentstart:    mov ax,12666    mov bx,data    mov ds,bx    mov si,0    call dtoc        mov dh,8    mov dl,3    mov cl,2    call show_str    mov ax,4c00h    int 21hdtoc:    mov dx,00    mov bh,00    mov bl,10;感觉逻辑没问题啊,商越界了 得用32/16的    div bx ;为什么会在这里卡住呢,感觉像是无限循环？？？    mov ch,00h    mov cl,dl    jcxz ok    add byte ptr cx,0030H    mov ds:[si],cx    inc si    jmp dtocok:    ;也不是不能操作栈,在之前push进去的,在这里都pop出来就不会有问题,要不然回影响ret指令pop IP    ;后面你可以再试试,这个程序还是有问题    sub si,1;运行完之后si=5,然而ds[si]此时刚好是0,所以你得减去个1才行    retshow_str:    push es    push bp    push bx    mov ax,0B800H    mov es,ax    ;找行号对应的内存地址    mov ah,00    mov al,160    mul dh    mov bp,ax    sub bp,160    ;找列对应的内存地址    mov ah,00    mov al,2    mul dl    mov di,ax    sub di,2    ;把颜色转移一下    mov bl,cl    push cxs:     mov cl,ds:[si]    mov ch,0    jcxz ok1    mov es:[bp+di],cl    mov es:[bp+di+1],bl    add di,2    sub si,1    jmp short sok1:    pop cx    pop bx    pop bp    pop es    ret        code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="改进后代码"><a href="#改进后代码" class="headerlink" title="改进后代码"></a>改进后代码</h4><p>改进之后,利用了栈的特性,先将算出来的余数入栈,然后再出栈写到内存里.这样就刚好倒过来了。不过需要注意的是,<code>在子程序中push进去的,在ret之前都要pop出来哦！</code></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:code,ds:datadata segment    db 10 dup(0)data endscode segmentstart:    mov ax,12666    mov bx,data    mov ds,bx    mov si,0    call dtoc        mov dh,8    mov dl,3    mov cl,2    call show_str    mov ax,4c00h    int 21hdtoc:    mov dx,00    mov bh,00    mov bl,10;感觉逻辑没问题啊,商越界了 得用32/16的    div bx ;为什么会在这里卡住呢,感觉像是无限循环？？？    mov ch,00h    mov cl,dl    jcxz ok    add byte ptr cx,0030H    mov ds:[si],cx    inc si    jmp dtocok:    ;也不是不能操作栈,在之前push进去的,在这里都pop出来就不会有问题,要不然回影响ret指令pop IP    ;后面你可以再试试,这个程序还是有问题    sub si,1;运行完之后si=5,然而ds[si]此时刚好是0,所以你得减去个1才行    retshow_str:    push es    push bp    push bx    mov ax,0B800H    mov es,ax    ;找行号对应的内存地址    mov ah,00    mov al,160    mul dh    mov bp,ax    sub bp,160    ;找列对应的内存地址    mov ah,00    mov al,2    mul dl    mov di,ax    sub di,2    ;把颜色转移一下    mov bl,cl    push cxs:     mov cl,ds:[si]    mov ch,0    jcxz ok1    mov es:[bp+di],cl    mov es:[bp+di+1],bl    add di,2    sub si,1    jmp short sok1:    pop cx    pop bx    pop bp    pop es    ret        code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行截图-2"><a href="#运行截图-2" class="headerlink" title="运行截图"></a>运行截图</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211016114256.png" alt="数值显示"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-1-汉堡店</title>
      <link href="/2021/10/16/mei-shi-pian-1-han-bao-dian/"/>
      <url>/2021/10/16/mei-shi-pian-1-han-bao-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次是跟舍友去吃的一个汉堡店,本来是想着能有那种美食视频上面看到的那样,有那种一口都塞不下的汉堡。地点就在川大望江校区地铁站的周边。</p><p>最主要是比较贵，我和室友一共花了<code>148</code>,就点了<code>两个汉堡</code>(具体价钱给忘了)`一盘鸡翅`(6个/32)</p><h2 id="汉堡"><a href="#汉堡" class="headerlink" title="汉堡"></a>汉堡</h2><p>结果这汉堡并不是很大,口感的话,我是觉得就一般,牛肉饼反而有一种腥味在。总体感觉就一般。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/D5181D27FB0D2ABF12A801D3EEE3666A.jpg" alt="汉堡1"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/C7B2046D0B0F24404CDB4355A0113227.jpg" alt="汉堡2"></p><h2 id="鸡翅"><a href="#鸡翅" class="headerlink" title="鸡翅"></a>鸡翅</h2><p>鸡翅的话,还凑合把,主要是有蜂蜜芥末的酱。个人比较喜欢</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/B977411C890AA8437C60E59E84F4538A.jpg" alt="鸡翅"></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-2-美国烤肉</title>
      <link href="/2021/10/16/mei-shi-pian-2-mei-guo-kao-rou/"/>
      <url>/2021/10/16/mei-shi-pian-2-mei-guo-kao-rou/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次由我室友和我还有另外两个同学一同前往，这个也是贵,最后人均花了105,不过体验还算可以。点了四个菜？名字忘了,大体就是烤肉串、意面、洋葱炒牛绒外加那种饼可以卷起来吃、烤肉三拼(鸡肉、牛肉、猪肉)</p><p>也是想体验一把视频里大口吃肉的感觉,但是回想起来,之前寒假的时候,我爸炖了好多排骨,同样是大口吃肉,为什么当时我就没有胃口吃呢？<br>为了弥补之前的遗憾,下一个寒假,我一定要将烤肉吃腻。大院子加上碳烤,想想就很过瘾。</p><h1 id="照骗"><a href="#照骗" class="headerlink" title="照骗"></a>照骗</h1><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/6DFA58B31EAAC59588475432A6AC93D7.jpg" alt="1"><br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/0CD8EF7A1D8C4E7CCCB4C33B921C5F98.jpg" alt="这个意面真的贵"></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-3-鸡毛店</title>
      <link href="/2021/10/16/mei-shi-pian-3-ji-mao-dian/"/>
      <url>/2021/10/16/mei-shi-pian-3-ji-mao-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次由我室友和我还有另外两个同学一同前往，这个还算可以,最后人均花了65? 点了 酸菜鱼？毛血旺？其他的忘了,这都是后面整理的了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QQ%E5%9B%BE%E7%89%8720211016180849.jpg" alt="照骗1"></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-4-东北菜</title>
      <link href="/2021/10/16/mei-shi-pian-4-dong-bei-cai/"/>
      <url>/2021/10/16/mei-shi-pian-4-dong-bei-cai/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次由我和我的两个舍友,这家店相对来说比较实惠,个人感觉也比较好吃。可能是因为自己家乡也在北方的原因。</p><ul><li>地三鲜</li><li>锅包肉—感觉跟我爸弄得差不多~~~</li><li>饺子</li><li>炸茄盒</li><li><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QQ%E5%9B%BE%E7%89%8720211016181146.jpg" alt="东北菜"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-5-麦当劳</title>
      <link href="/2021/10/16/mei-shi-pian-5-mai-dang-lao/"/>
      <url>/2021/10/16/mei-shi-pian-5-mai-dang-lao/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次是所有的舍友了,毕竟一个舍友请客,点的麦当劳,有汉堡、可乐、炸鸡、小龙虾和粉条、薯条、披萨~~ 如果要是硬要算人均的话,应该在50左右</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QQ%E5%9B%BE%E7%89%8720211016181638.jpg" alt="麦当劳"></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美食篇-6-陶德砂锅</title>
      <link href="/2021/10/16/mei-shi-pian-6-tao-de-sha-guo/"/>
      <url>/2021/10/16/mei-shi-pian-6-tao-de-sha-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h1><p>这次是舍友和我外加上两个大寝的舍友,这次的菜也非常好吃，人均55? 可惜照骗我只有一张了。有一个鲫鱼饺子、红烧猪蹄、还有一个肥肠、还有虾仁米线,还点了一些包子。</p><p>本来想尝尝肥肠的,因为之前看别人在视频里面吃的时候,我感觉很香。结果吃了一口,差点原地~~</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/1E5077B3A17D99CD7EDF42E4F291B254.jpg" alt="照片"></p>]]></content>
      
      
      <categories>
          
          <category> 美食 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-数据处理的两个基本问题</title>
      <link href="/2021/10/13/hui-bian-yu-yan-xue-xi-shu-ju-chu-li-de-liang-ge-ji-ben-wen-ti/"/>
      <url>/2021/10/13/hui-bian-yu-yan-xue-xi-shu-ju-chu-li-de-liang-ge-ji-ben-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>还是画这样的图，感觉思路清晰一些。新的东西并不多,大多感觉还是对以往问题的一个总结。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102156.png" alt="思维导图"></p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><p>编程,将data段中的数据按如下格式写入到table段中,并计算21年中的人均收入(取整),结果也按照下面的格式保存在table段中。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102611.png" alt="题干1"><br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102632.png" alt="题干2"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  具体的思路就是,利用内外循环,大循环循环00-10H-20H这样每一行的数据,小循环循环每个数据项</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>中具体的字节\字。同时利用idata和si</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesg,ds:datadata segment    ;0    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'    db '1993','1994','1995'    ;54H    dd 16,22,382,1356,2390,8000,160000,24486,50065,97479,140417,197514    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5973000        ;A8H    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226    dw 11542,14430,15257,17800data endstable segment    db 21 dup ('year summ ne ?? ')table endscodesg segment;正好印证了两个重点的地方 1.数据在什么地方 2.数据的大小;算人均收入的那个还没有写--------------------------------------------------------start:    mov ax,data    mov ds,ax        mov ax,table    mov es,ax;这里经常把ax写成table了    mov bx,0;bx定位data段,bx year和收入都是四个字节可以公用,但是雇员数是两个字节的没办法公用    mov bp,0;bp定位es段    mov di,0;di用来在循环中服务于雇员数,因为它是两个字节,没办法跟year和outcome公用一个递增寄存器    mov cx,21    overall:        push cx        mov cx,2        mov si,0        year:            ;年份的4字节---两个字            mov ax,ds:[bx+si]            mov es:[bp+si],ax            add si,2            loop year        mov cx,2        mov si,0        outcome:            ;收入的4字节---两个字            mov ax,ds:[bx+54H+si]            mov es:[bp+5H+si],ax            add si,2            loop outcome        ;雇员数---一个字        mov ax,ds:[di+0A8H]        mov es:[bp+0AH],ax        ;计算人均收入        mov ax,es:[bp+5H];计算人均收入的,要用es的定位,那偏移量就得按照es的来。最开始写成ds的定位了[bx+54H]了        mov dx,es:[bp+5H+2]        div word ptr es:[bp+0AH]        mov es:[bp+0DH],ax        ;所有的空格        ;第一次没有考虑到空格是一个字节,这里不应该用16位的,应该用8位的        mov al,' '        mov es:[bp+4H],al        mov es:[bp+9H],al        mov es:[bp+0FH],al        pop cx        add di,2        add bx,4        add bp,16        loop overall    ;计算收入    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-转移指令原理</title>
      <link href="/2021/10/13/hui-bian-yu-yan-xue-xi-zhuan-yi-zhi-ling-yuan-li/"/>
      <url>/2021/10/13/hui-bian-yu-yan-xue-xi-zhuan-yi-zhi-ling-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="转移指令原理"><a href="#转移指令原理" class="headerlink" title="转移指令原理"></a>转移指令原理</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013193650.png" alt="思维导图"></p><h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><p>在对应的机器码中不包含转移的目的地址,而包含的是到目的地址的位移。这种设计,方便了程序段在内存中的浮动装配。使程序装在内存中的不同位置都可正确执行,因为在执行时,只涉及到位移,而不是地址。如果是地址的话,程序没有装载到对应的位置,就会造成程序没有办法正确执行。</p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><h3 id="实验8-分析一个奇怪的程序"><a href="#实验8-分析一个奇怪的程序" class="headerlink" title="实验8 分析一个奇怪的程序"></a>实验8 分析一个奇怪的程序</h3><p>分析下面的程序,在运行前思考:这个程序可以正确返回吗？</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesgcodesg segment    mov ax,4c00h    int 21h;反正就是刚好利用了jmp 的相对位移的特性.short 8位位移 = 标号处的地址-jmp指令后的第一个字节地址start:    mov ax,0s:    nop    nop    mov di,offset s    mov si,offset s2    mov ax,cs:[si]    mov cs:[di],axs0:    jmp short ss1:    mov ax,0    int 21h    mov ax,0s2:    jmp short s1    nopcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以正确返回,刚好利用了jmp 的相对位移的特性.short 8位位移 = 标号处的地址-jmp指令后的第一个字节地址。当程序再次跳回到s标号处执行时,其第一条指令为 EBF6,就刚好是往上面跳到了 <code>mov ax,4c00h</code></p><h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013194841.png" alt="实验8"></p><h3 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h3><p>在屏幕中间分别显示绿色\绿底红色\白底蓝色的字符串”welcome to masm!”.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>感觉这个没用到这章讲的东西啊??!!，还是因为我水平不行？？</p><p><strong>我是真的憨憨,第一开始没有注意到题目中说的是要在屏幕中间显示</strong></p><h5 id="改进前-写了三个循环"><a href="#改进前-写了三个循环" class="headerlink" title="改进前,写了三个循环"></a>改进前,写了三个循环</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'datasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov ax,0B800H    mov es,ax;1        mov bx,6E0H    mov si,0    mov di,80    mov cx,16s:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],02H    add di,2    add si,1    loop s;2    mov bx,780H    mov si,0    mov di,80    mov cx,16s1:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],24H    add di,2    add si,1    loop s1;3    mov bx,820H    mov si,0    mov di,80    mov cx,16s2:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],71H    add di,2    add si,1    loop s2    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="改进后-写成了一个循环"><a href="#改进后-写成了一个循环" class="headerlink" title="改进后,写成了一个循环"></a>改进后,写成了一个循环</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'    db 02H,24H,71Hdatasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov ax,0B800H    mov es,ax;1        mov bx,6E0H    mov cx,3    mov bp,0all:    push cx    mov si,0    mov di,80    mov cx,16    s:          mov al,ds:[si]        mov es:[bx+di],al        mov al,ds:[bp+16]        mov es:[bx+di+1],al        add di,2        add si,1        loop s    add bp,1    add bx,160    pop cx    loop all; ;2;     mov bx,780H;     mov si,0;     mov di,80;     mov cx,16; s1:  ;     mov al,ds:[si];     mov es:[bx+di],al;     mov byte ptr es:[bx+di+1],24H;     add di,2;     add si,1;     loop s1; ;3;     mov bx,820H;     mov si,0;     mov di,80;     mov cx,16; s2:  ;     mov al,ds:[si];     mov es:[bx+di],al;     mov byte ptr es:[bx+di+1],71H;     add di,2;     add si,1;     loop s2    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行截图-1"><a href="#运行截图-1" class="headerlink" title="运行截图"></a>运行截图</h4><p>这个运行结果，怎么有的时候行有的时候不行？之前运行的时候，第一行的welcome 显示成了 celcome或是1/4elcome很奇怪。但是后面就又正常了<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013201157.png" alt="实验九"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013205518.png" alt="改正后"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-更灵活的定位内存地址的方法</title>
      <link href="/2021/10/11/hui-bian-yu-yan-xue-xi-geng-ling-huo-de-ding-wei-nei-cun-di-zhi-de-fang-fa/"/>
      <url>/2021/10/11/hui-bian-yu-yan-xue-xi-geng-ling-huo-de-ding-wei-nei-cun-di-zhi-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="编程1-将datasg段中每个单词的前四个字母改为大写字母"><a href="#编程1-将datasg段中每个单词的前四个字母改为大写字母" class="headerlink" title="编程1 将datasg段中每个单词的前四个字母改为大写字母"></a>编程1 将datasg段中每个单词的前四个字母改为大写字母</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesg,ss:stacksg,ds:datasgstacksg segment    dw 0,0,0,0,0,0,0,0stacksg endsdatasg segment    db '1. display      '    db '2. brows        '    db '3. replace      '    db '4. modify       'datasg endscodesg segmentstart:    mov ax,stacksg    mov ss,ax    mov sp,16;初始化栈段        mov ax,datasg    mov ds,ax;初始化数据段        mov bx,0    mov cx,4s:    push cx    mov cx,4    mov si,0s0:    mov al,ds:[bx+3+si];这个地方必须要是 bx+(si/di)+(idata)这样的形式,()为可选内容    and al,11011111B;01100100 01000100--44      mov ds:[bx+3+si],al    inc si    loop s0    pop cx    add bx,16    loop s        mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011200251.png" alt="运行截图"></p><h3 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li><code>and al,11011111b</code>少打了一个1</li></ul><h2 id="编程2-将datasg中的第一个字符串转换成大写-第二个字符串转成小写"><a href="#编程2-将datasg中的第一个字符串转换成大写-第二个字符串转成小写" class="headerlink" title="编程2 将datasg中的第一个字符串转换成大写,第二个字符串转成小写"></a>编程2 将datasg中的第一个字符串转换成大写,第二个字符串转成小写</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'BaSiC'    db 'iNfOrMaTiOn'datasg endscodesg segment    start:        mov ax,datasg        mov ds,ax                mov bx,1        mov cx,2    s:        mov al,ds:[bx]        and al,11011111b        mov ds:[bx],al        add bx,2        loop s                mov bx,6;这个bx要定位到 第二个字符串的第一个大写字母啊        mov cx,5    s0:        mov al,ds:[bx]        or al,00100000b        mov ds:[bx],al                add bx,2        loop s0        mov ax,4c00h        int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011203022.png" alt="运行截图"></p><h3 id="出现的错误-1"><a href="#出现的错误-1" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li>第二个字符串定位是要在<code>第一个大写字母N</code></li></ul><h2 id="编程3-用si和di实现将字母串”welcome-to-masm-”复制到它后面的数据区中"><a href="#编程3-用si和di实现将字母串”welcome-to-masm-”复制到它后面的数据区中" class="headerlink" title="编程3 用si和di实现将字母串”welcome to masm!”复制到它后面的数据区中"></a>编程3 用si和di实现将字母串”welcome to masm!”复制到它后面的数据区中</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume  cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'    db '................'datasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov si,0    mov di,10h    mov bx,0    mov cx,8 s:     mov ax,ds:[bx+si]    mov ds:[bx+di],ax        add si,2    add di,2        loop s    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011204256.png" alt="运行截图"></p><h3 id="出现的错误-2"><a href="#出现的错误-2" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li><code>assume codesg</code> 和<code>code segment</code> 不匹配</li><li>di寄存器写成bi</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章中,我们主要讲解了更为灵活的寻址方式的应用和一些编程方法,主要的内容有：</p><ul><li>寻址方式 [bx]–编程2[bx+idata] [bx+si]–编程3[bx+si+idata]–编程1</li><li>二重循环问题的处理,处理两个循环loop都使用cx寄存器的时候,会出现冲突的问题.解决的最佳方式就是将cx的值暂时存储到栈空间中,等到再次回到外层循环的时候,再将其出栈,以此实现将互不影响.这里也能体现处在<code>调用函数</code>掉用<code>被调用函数</code>的时候,将各个寄存器的值入栈,等到<code>被调用函数</code>返回时,再将各个寄存器的值初始化到调用<code>被调用函数</code>之前,这样就可以继续执行<code>调用函数</code>,而不产生影响.</li><li>栈的应用</li><li>大小写转换的方法<br>小写转大写 <code>and al,11011111b</code><br>大写转小写 <code>or al,00100000b</code></li><li>and | or 指令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-[bx]和loop指令</title>
      <link href="/2021/10/10/hui-bian-yu-yan-xue-xi-bx-he-loop-zhi-ling/"/>
      <url>/2021/10/10/hui-bian-yu-yan-xue-xi-bx-he-loop-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h2><p><code>mov ax,[bx]</code>, bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中,将SA:EA处的数据送入ax中,<strong>注意这里是字型数据哦！</strong> 即:<code>ax = ds*16 + bx</code></p><p>建议以后再写汇编语言程序的时候,把[bx]前面的段寄存器显式地标注出来,也就是所谓的<strong>段前缀</strong>。</p><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop 指令就是一个循环指令，注意cx循环次数,和bx在循环过程中的变化。</p><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>计算ffff:0-ffff:b单元中的数据的和,结果存储在dx中</p><h3 id="数据相加的问题"><a href="#数据相加的问题" class="headerlink" title="数据相加的问题"></a>数据相加的问题</h3><ul><li>dx = dx + 内存中的8位数据 类型不匹配</li><li>dl = dl + 内存中的8位数据 结果越界</li></ul><p>解决方案：利用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器ax中<strong>高八位要初始化为0</strong>,再将ax中的数据加到dx上,从而使两个运算对象的类型匹配并且结果不会超界。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-and-2"><a href="#1-and-2" class="headerlink" title="1 and 2"></a>1 and 2</h3><p>编程 ,向内存 0:200<del>0:23F依次传送数据0</del>63</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesegcodeseg segmentstart: mov ax,0200H    ;这里第一次写成0H了 心里想的确实是0200 不知道怎么弄成0了      mov ds,ax          mov bx,0H      mov cx,40H    s:  mov ds:[bx],bl    inc bx    loop s        mov ax,4c00H    int 21hcodeseg endsend startend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>将”mov ax,4c00h”之前的指令复制到内存0:200h处,补全程序,上机调试,跟踪运行结果.</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesegcodeseg segmentstart: mov ax,cs    mov ds,ax    mov ax,0020h    mov es,ax    mov bx,0    mov cx,17h;第一次写的21(10进制),看网上有说18的，感觉不对呀，我17的话就刚刚好是可以复制完的    ;还有view里面cpu指令前面的地址是该指令的起始地址 你还要加上这个指令的大小,才算是下一条指令的相对地址,而且别忽略了最初的地址是从零开始算的s:  mov al,ds:[bx];标签表示的是相对于段定义起始位置的位置    mov es:[bx],al    inc bx    loop s    mov ax,4c00h    int 21hcodeseg endsend startend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211010160654.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-包含多个段的程序</title>
      <link href="/2021/10/10/hui-bian-yu-yan-xue-xi-bao-han-duo-ge-duan-de-cheng-xu/"/>
      <url>/2021/10/10/hui-bian-yu-yan-xue-xi-bao-han-duo-ge-duan-de-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h1><p>代码结构</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codecode segment      ··      ··      数据      ··      ··start:      ··      ··      代码      ··      ··code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h1><p>代码结构跟上面的差不多,就是要在start中初始化段指针(SS\SP)</p><h1 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h1><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:code, ds:data, ss:stackdata segment    ··data endsstack segment    ··stack endscode segmentstart:      ··      ··      代码      ··      ··code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构是这个结构,但是在代码段中,仍然需要使用初始化指令来将相应的ds\ss\sp寄存器初始化才可以。总而言之，cpu到底如何处理我们定义的段的中的内容,是当作指令执行，还是当作数据访问，还是当作栈空间,完全是靠程序中具体的汇编指令,和汇编指令对cs:ip、ss:sp、ds等寄存器的设置来决定的。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>前面几个都是给出程序来调试观察的。就不列举出来了</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>编写code总的代码段,将a段和b段中的数据依次相加,将结果保存在c段中。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c ends;把a 、b段中的数据相加，结果存储到c段当中code segmentstart: mov ax,a    mov ds,ax        mov ax,b    mov es,ax  mov ax,c  mov ss,ax  mov sp,8        mov bx,0    mov cx,7 ;方法1; 这样的话解决不了最后08+08的情况, 栈顶指针刚好是0001-> FFFF 这样10放高地址就恰好被溢出了。; 所以我觉得,还有一种方式是最后一个元素，用al，其他的用ah, 按照栈元素来说，这样做的是对的; 代做: 这样做很麻烦倒是,更好的方式应该是分别计算两个字节的，然后组成一个字，同时push进去，这样的话就不用处理最后一个栈顶元素的问题了; 方法1-------是个错误的方法，解决不了栈顶最初始的元素s: mov ah,ds:[bx]  add ah,es:[bx]  push ax  add sp,1;    mov c:[bx],al  inc bx  loop s;处理最后一个元素    mov al,ds:[bx]    add al,es:[bx]    push ax;方法二------推荐--正确    ; mov cx,4 ;方法2; s: mov ah,ds:[bx];    add ah,es:[bx];    add bx,1   ;    mov al,ds:[bx];    add al,es:[bx];    add bx,1;    push ax;    loop s    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>编写code中的代码,用push指令将a段中的前八个字型数据,逆序存储到b段中。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segmentstart: mov ax,b    mov ss,ax    mov sp,10h;8个字型数据,栈顶指针的大小应该是10h哦！        mov ax,a    mov es,ax        mov bx,0    mov cx,8s: push es:[bx]    add bx,2;bx这里要自增2哦！    loop s    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-第一个程序-1</title>
      <link href="/2021/10/06/hui-bian-yu-yan-xue-xi-di-yi-ge-cheng-xu-1/"/>
      <url>/2021/10/06/hui-bian-yu-yan-xue-xi-di-yi-ge-cheng-xu-1/</url>
      
        <content type="html"><![CDATA[<h1 id="关于汇编程序的执行问题"><a href="#关于汇编程序的执行问题" class="headerlink" title="关于汇编程序的执行问题"></a>关于汇编程序的执行问题</h1><p>在DOS中,可执行文件中的程序P1若要运行，必须有一个正在运行的程序p2,将p1从可执行文件中加载入内存,将CPU的控制权交给它.p1才能够运行,当p1运行完毕后,应该将cpu的控制权交还给使她得以运行的程序p2</p><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul><li>在提示符<code>C:\masm</code>后面输入可执行文件的名字”1”,按下回车enter键，这时，思考问题4.1</li><li>1.exe运行</li><li>运行结束后，返回。再次显示提示符<code>C:masm</code>.思考问题4.2</li></ul><h3 id="4-1-此时-有一个正在运行的程序将1-exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？"><a href="#4-1-此时-有一个正在运行的程序将1-exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？" class="headerlink" title="4.1 此时,有一个正在运行的程序将1.exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？"></a>4.1 此时,有一个正在运行的程序将1.exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？</h3><p>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个成为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p><p>DOS中有一个程序command.com，这个程序在DOS中成为命令解释器，也就是DOS系统的shell。</p><p>DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他相关的任务后，在屏幕上显示出当前盘符和当前路径组成的提示符，等待用户输入。</p><p>用户可以输入所要执行的命令，如：cd、dir、type等，这些命令由command执行，command执行完这些命令后，再次显示由当前盘符和当前路径组成的提示符，等待用户输入。</p><p>如果用户要执行一个程序，则输入该程序的可执行文件的名称，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载到内存中，设置CS:IP指向程序的入口。此后command暂时停止运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示出由当前盘符和当前路径组成的提示符，等待用户输入。</p><p>在DOS中，command处理各种输入：命令或要执行的程序的文件名。我们就是用过command来进行工作的。</p><h3 id="4-2-程序运行结束后，返回到了哪里？"><a href="#4-2-程序运行结束后，返回到了哪里？" class="headerlink" title="4.2 程序运行结束后，返回到了哪里？"></a>4.2 程序运行结束后，返回到了哪里？</h3><p>程序运行结束后，返回到了command中。</p><h4 id="汇编程序从写出到执行的过程"><a href="#汇编程序从写出到执行的过程" class="headerlink" title="汇编程序从写出到执行的过程"></a>汇编程序从写出到执行的过程</h4><p>编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 链接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行</p><h2 id="观察下面程序执行过程中，寄存器和栈顶元素的变化"><a href="#观察下面程序执行过程中，寄存器和栈顶元素的变化" class="headerlink" title="观察下面程序执行过程中，寄存器和栈顶元素的变化"></a>观察下面程序执行过程中，寄存器和栈顶元素的变化</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">assume cs:codesegcodeseg segmentstart:  mov ax,2000H        mov ss,ax        mov sp,0        pop ax        pop bx        push ax        push bx        pop ax        pop bx        mov ax,4c00H    int 21hcodeseg endsend startend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ax bx 各出入栈。IP和SP指针在变化，其余寄存器没看到变化。栈顶元素最后还是变化到跟初始状态下一致了</p><p>PSP的头两个字节时CD20,其中的内容为</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211006115030.png" alt="PSP"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-寄存器-3</title>
      <link href="/2021/10/04/hui-bian-yu-yan-xue-xi-ji-cun-qi-3/"/>
      <url>/2021/10/04/hui-bian-yu-yan-xue-xi-ji-cun-qi-3/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="基本指令-1-PUSH"><a href="#基本指令-1-PUSH" class="headerlink" title="基本指令 1 PUSH"></a>基本指令 1 PUSH</h2><p>对于push指令的执行</p><ul><li>SP = SP - 2, SS:SP指向当前栈顶前面的单元,以当前栈顶前面的单元为新的栈顶;</li><li>将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶</li></ul><p>具体的图就不画了</p><h2 id="基本指令-2-POP"><a href="#基本指令-2-POP" class="headerlink" title="基本指令 2 POP"></a>基本指令 2 POP</h2><p>关于pop指令的执行</p><ul><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP = SP + 2, SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li></ul><p><strong>注意</strong>: 栈里面的单元是以字为单位的(2个字节),字单元的地址是两个字节地址中的低地址</p><h2 id="栈顶的超界问题"><a href="#栈顶的超界问题" class="headerlink" title="栈顶的超界问题"></a>栈顶的超界问题</h2><p>对于8086CPU不保证对栈的操作不会越界。也就是说,8086CPU只知道栈顶在何出(由SS:SP指示),而不知道我们安排的栈空间有多大。这点好像CPU只知道执行的指令在何出(由CS:IP指示),而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU的工作机理,它只<code>考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条</code></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="寄存器清零"><a href="#寄存器清零" class="headerlink" title="寄存器清零"></a>寄存器清零</h3><p>两种方式:</p><ul><li>sub ax,ax 机器码为2个字节</li><li>mov ax,0 机器码为3个字节</li></ul><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>一段内存,可以既是代码的存储空间,又是数据的存储空间,还可以是栈空间,也可以什么也不是.关键在于CPU中寄存器的设置，即CS\IP\SS\SP\DS的指向。</p><p>我们可以用一个段来此存放数据,将它定义为 数据段 </p><p>我们可以用一个段来此存放代码,将它定义为 代码段 </p><p>我们可以用一个段来此存放栈,将它定义为 栈段</p><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p><p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就能指向我们定义的代码段中的指令。</p><p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，就将我们定义的栈段当作栈空间来操作。</p><p>比如我们将10000H - 1001FH 安排为代码段，并在里面存储如下代码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mov ax, 1000Hmov ss, axmov sp, 0020Hmov ax, csmov ds, axmov ax, [0]add ax, [2]mov bx, [4]add bx, [6]push axpush bxpop axpop bx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置CS = 10000H,IP=0。这段代码将得到执行，可以看到，在这段代码中，我们又将10000H - 1001FH 安排为栈段和数据段。10000H - 1001FH 这段内存，既是代码段，又是栈段和数据段。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-寄存器-2</title>
      <link href="/2021/10/02/hui-bian-yu-yan-xue-xi-ji-cun-qi-2/"/>
      <url>/2021/10/02/hui-bian-yu-yan-xue-xi-ji-cun-qi-2/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器-2"></a>寄存器-2</h1><h2 id="字的存储"><a href="#字的存储" class="headerlink" title="字的存储"></a>字的存储</h2><p>字的存储没什么好说的，注意下低地址就行了</p><h2 id="指令操作单元之间的关系"><a href="#指令操作单元之间的关系" class="headerlink" title="指令操作单元之间的关系"></a>指令操作单元之间的关系</h2><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>  8086CPU不支持将数据直接送入段寄存器的操作。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002102608.png" alt="mov指令数据流向"></p><h3 id="sub、add指令"><a href="#sub、add指令" class="headerlink" title="sub、add指令"></a>sub、add指令</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002102642.png" alt="指令数据流向"></p><h2 id="jmp指令跳转后，cs-code-segment-会发生变化"><a href="#jmp指令跳转后，cs-code-segment-会发生变化" class="headerlink" title="jmp指令跳转后，cs code segment 会发生变化"></a>jmp指令跳转后，cs <code>code segment</code> 会发生变化</h2><p>  初始情况下 CS=2000H，IP=0，DS=1000H, AX=0, BX=0</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">20000H-20002H mov ax,6222H20003H-20007H jmp 0ff0:010020008H-20009H mov bx,ax10000H-10002H mov ax,2000H10003H-10004H mov ds,ax10005H-10007H mov ax,[0008]10008H-1000AH mov ax,[0002]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  想说的就是，在执行完<code>jmp 0ff0:0100</code>时 <code>CS 2000H-&gt;0FF0H</code> , <code>IP 0003H-&gt; 0100H</code>,而且执行到<code>mov ax,[0002]</code>后不会再跳回来</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002104344.png" alt="汇编执行图"></p>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习-寄存器</title>
      <link href="/2021/10/01/hui-bian-yu-yan-xue-xi-ji-cun-qi/"/>
      <url>/2021/10/01/hui-bian-yu-yan-xue-xi-ji-cun-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><ol><li><p><strong>使用debug指令，将上面的程序段写入内存，逐条执行，观察每条指令执行后，CPU中相关寄存器中的内容变化。</strong></p><p> 输入指令<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001094702.png" alt="20211001094702"></p><p> 修改cs ip 使用r指令<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001094920.png" alt="20211001094920"></p><p> 执行程序 使用t指令<br> <code>具体的过程就不截图了，是ax bx ip 三个寄存器之间值的变化</code></p></li><li><p><strong>利用了三条指令计算2的八次方</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mov ax,1add ax,axjmp 2000:0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也是通过t 命令运行程序并观察寄存器中值的变化。</p></li><li><p><strong>查看内存中的内容</strong><br>查看主板上面的内容，我是没看见。不知道是不是因为使用的是DOSbox的原因<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001102449.png" alt="20211001102449"></p></li><li><p><strong>向内存从B8100H 开始的单元中填写数据</strong></p><p>我盲猜，作者想让读者观察到的显示是有的内存地址(ROM)不能写，有的内存地址可以写</p><p>按照书上面写的8086PC机内存地址的空间分配图来说，b8100属于显存地址空间。<br>我输入过程中的感觉很奇怪，这里面的数据会自己变化</p><p>这里按道理来说b810:0000这个存储单元中存放的应该是20H才对，不知道为什么为了30H<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001103438.png" alt="20211001103438"></p><p>同样都是使用d指令来查询内存中的内容，按道理来说1和2处显示的应该一样才对，3和4就刚好是一样的？？？<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001103918.png" alt="20211001103918"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 研究生预备学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新博客主题</title>
      <link href="/2021/09/30/geng-xin-bo-ke-zhu-ti/"/>
      <url>/2021/09/30/geng-xin-bo-ke-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="更新博客主题"><a href="#更新博客主题" class="headerlink" title="更新博客主题"></a>更新博客主题</h1><p>保研之后，除了规划一下下一步的研究生学习生活，在无意中逛其他大神的博客的时候，无意间发现了这个非常好看的主题。于是就抽空更换了一下，因为之前自己在<code>GitHub page</code>上搭建过一次，这次遇到的困难并不算多。</p><h2 id="遇到的问题以及待办"><a href="#遇到的问题以及待办" class="headerlink" title="遇到的问题以及待办"></a>遇到的问题以及待办</h2><ul><li><p>长时间不写markdown了，以至于很多插件都不太会用了，</p></li><li><p>之前文章中的代码高亮问题，也不知道是因为插件bug的原因，就是代码块好像必须要用小写才行。也懒得改之前的了，<code>后面的文章一定要按照小写的来</code>。</p></li><li><p>之前文章中的目录就不需要了，这个主题有方便的目录</p></li></ul><h3 id="计划继续完善的东西"><a href="#计划继续完善的东西" class="headerlink" title="计划继续完善的东西"></a>计划继续完善的东西</h3><ul><li><input disabled="" type="checkbox"> 在gitee上面搭建一份一样的博客</li><li><input disabled="" type="checkbox"> 还是希望深入接触一下hexo博客，后面还是希望能增添一些属于自己的东西，毕竟是自己的博客嘛</li><li><input disabled="" type="checkbox"> 这段时间反正也是比较闲，就尽量把每天学到的内容总结一下，写上来把，也算是督促自己了</li><li><input disabled="" type="checkbox"> 主页当中的图片大小会影响到下面博客文章的展示排版</li><li><input disabled="" type="checkbox"> 主页轮播图中有的图片不显示，因为他直接把md文章前面写的那些img文件拼接到cdn后面了。后面有机会看着改一下。</li><li><input disabled="" type="checkbox"> 友情链接，那几个图片显示不了，也不知道是不是跨域问题。</li><li><input checked="" disabled="" type="checkbox"> 不知道他这个目录是怎么显示的，有的有，有的没有。搞清楚一下。<strong>文章TOC设置</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 瞎搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客主题 </tag>
            
            <tag> 待办 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生预备学习</title>
      <link href="/2021/09/30/yan-jiu-sheng-yu-bei-xue-xi-qing-dan/"/>
      <url>/2021/09/30/yan-jiu-sheng-yu-bei-xue-xi-qing-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="研究生预备学习"><a href="#研究生预备学习" class="headerlink" title="研究生预备学习"></a>研究生预备学习</h1><h2 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h2><p>  不管是运气还是个人实力，最终还是被保研到了本校网络空间安全学院继续学习。自己也选择了最开始选择网安专业最希望自己成为的那种人（二进制逆向），也找了学院里面做相关研究的导师。但是自己在本科期间并没有很好的基础。所以决定利用大四的时间，多学习一些基础的知识，以应对繁重科研压力的研究生生活</p><h2 id="主要阅读的书籍清单"><a href="#主要阅读的书籍清单" class="headerlink" title="主要阅读的书籍清单"></a>主要阅读的书籍清单</h2><h3 id="基础书籍"><a href="#基础书籍" class="headerlink" title="基础书籍"></a>基础书籍</h3><ul><li><input disabled="" type="checkbox"> 汇编语言 王爽</li><li><input disabled="" type="checkbox"> 逆向工程核心原理</li><li><input disabled="" type="checkbox"> 程序是怎样跑起来的</li></ul><h3 id="进阶书籍"><a href="#进阶书籍" class="headerlink" title="进阶书籍"></a>进阶书籍</h3><p>还在想~~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--线性表</title>
      <link href="/2021/07/02/shu-ju-jie-gou-xian-xing-biao-1/"/>
      <url>/2021/07/02/shu-ju-jie-gou-xian-xing-biao-1/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>直接放代码了，题目就是王道2022线性表那节的题目。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 线性表.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。&#x2F;&#x2F;# include &lt;iostream&gt;# define LIST_INIT_SIZE 100 &#x2F;&#x2F; 线性表存储空间的初始分配量# define LISTINCREMENT 10&#x2F;&#x2F;线性表存储空间的分配增量typedef struct &#123;    int* elem; &#x2F;&#x2F;存储空间基址    int length;&#x2F;&#x2F;当前长度    int listsize;&#x2F;&#x2F;当前分配的存储容量(以sizeof(int)为单位)&#125;SqList;&#x2F;*    初始化创建*&#x2F;bool InitList_Sq(SqList &amp;L) &#123;    L.elem &#x3D; (int*)malloc(LIST_INIT_SIZE * sizeof(int));    memset(L.elem, 0, LIST_INIT_SIZE * sizeof(int));    if (!L.elem) return false;    L.length &#x3D; 0;    L.listsize &#x3D; LIST_INIT_SIZE;    return true;&#125;void ListPrint_Sq(SqList&amp; L) &#123;    if (L.length &#x3D;&#x3D; 0) &#123; printf_s(&quot;该顺序表为空&quot;); exit(0); &#125;    for (int i &#x3D; 0; i &lt;&#x3D; L.length - 1; i++) &#123;        printf_s(&quot;%d-&gt;&quot;, *(L.elem + i));    &#125;    printf_s(&quot;\n&quot;);&#125;&#x2F;*    在固定位置插入元素*&#x2F;bool ListInsert_Sq(SqList&amp; L, int i, int e) &#123;    &#x2F;&#x2F;在顺序线性表L中第i个位置之前插入新的元素e    &#x2F;&#x2F;i的合法值    if (i&lt;1 || i&gt;L.length + 1) return false;    if (L.length &gt; L.listsize) &#123;&#x2F;&#x2F;当前存储空间已满，增加分配        int* newbase &#x3D; (int*)realloc(L.elem, ((L.listsize + LISTINCREMENT)*sizeof(int)));        if (!newbase) exit(OVERFLOW);        L.elem &#x3D; newbase;&#x2F;&#x2F;新基址        L.listsize  &#x3D; L.listsize + LISTINCREMENT;    &#125;    int* q &#x3D; &amp;(L.elem[i - 1]); &#x2F;&#x2F;q为插入位置    for (int* p &#x3D; &amp;(L.elem[L.length - 1]); p &gt;&#x3D; q; --p)        *(p + 1) &#x3D; *p;&#x2F;&#x2F;插入位置的元素后移    *q &#x3D; e;    ++L.length;    return true;&#125;&#x2F;*    删除固定位置的元素*&#x2F;bool ListDelete_Sq(SqList&amp; L, int i, int&amp; e) &#123;    &#x2F;&#x2F;在顺序线性表L中删除第i个元素，并用e返回值    if (i&lt;1 || i&gt;L.length + 1)return false;    int* p &#x3D; &amp;(L.elem[i - 1]);&#x2F;&#x2F;被删除元素的位置    e &#x3D; *p;    int* q &#x3D; L.elem + L.length - 1;    for (++p; p &lt;&#x3D; q; ++p) *(p - 1) &#x3D; *p;&#x2F;&#x2F;被删除元素之后的元素左移    --L.length;    return false;&#125;&#x2F;*    删除顺序表中最小的元素 √*&#x2F;bool ListDeleteMin_Sq(SqList&amp; L, int&amp; e) &#123;    if (!(L.elem) || L.length &#x3D;&#x3D; 0) &#123; printf_s(&quot;长度为零&quot;); exit(-1); &#125;    int* q &#x3D; L.elem + L.length - 1;    int* p &#x3D; L.elem;    int* tag &#x3D; L.elem;    for (; p &lt;&#x3D; q; p++) &#123;        if (*p &lt; *tag) tag &#x3D; p;    &#125;    e &#x3D; *tag;    *tag &#x3D; *q;    return true;&#125;&#x2F;*    顺序表逆置 √*&#x2F;bool ListReverse_Sq(SqList&amp; L) &#123;    if (L.length &#x3D;&#x3D; 0) return false;    int* temp,*p,*q;    &#x2F;&#x2F; C++不允许空指针，定义只是定义int*,定义了并没有实际的指向。习惯上一定要进行初始指针的初始化操作。    temp &#x3D;(int*)malloc(1*sizeof(int));    &#x2F;&#x2F;也或者在这里直接用int类型的test即可。    int test;    for (int i &#x3D; 0; i &lt;&#x3D; L.length&#x2F; 2-1; i++) &#123;        p &#x3D; L.elem + i;        q &#x3D; L.elem + L.length - 1 - i;        test &#x3D; *p;        *p &#x3D; *q;        *q &#x3D; test;    &#125;    return true;&#125;&#x2F;*    删除顺序表中所有值为x的元素 √     ----无论是有序表还是无序表用这个都行，有序表可以先找到所有的元素，然后一起移动，但是从时间复杂度上面来讲是一样的    从逻辑上讲，2这个值的确被删除了    但是从存储的结构上讲，2这个值还在存储空间里，只不过在逻辑上，这个位置已经是不合法的了。(改变了顺序表的长度)*&#x2F;bool ListDeleValue(SqList&amp; L, int e) &#123;    int k &#x3D; 0;    if (L.length &#x3D;&#x3D; 0)return false;    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;        if (*(L.elem + i) !&#x3D; e) &#123;            k++;            *(L.elem + k - 1) &#x3D; *(L.elem + i);        &#125;    &#125;    L.length &#x3D; k;&#125;&#x2F;*    删除值在s和t之间的节点 √    跟上面的方法很像了*&#x2F;bool ListDeleValueBetween(SqList&amp; L, int s, int t) &#123;    if (s &gt; t) &#123;        printf_s(&quot;请检查参数设置\n&quot;);         return false;    &#125;    int k &#x3D; 0;    if (L.length &#x3D;&#x3D; 0)return false;    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;        if (*(L.elem + i) &lt;s || *(L.elem + i) &gt; t) &#123;            k++;            *(L.elem + k - 1) &#x3D; *(L.elem + i);        &#125;    &#125;    L.length &#x3D; k;&#125;&#x2F;*    删除有序线性表中所有的重复值*&#x2F;bool ListDeleteDuplicateValueInOrder(SqList&amp; L) &#123;    if (L.length &#x3D;&#x3D; 0 || L.length &#x3D;&#x3D; 1)return false;    int k&#x3D;0;    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;        if (*(L.elem + i) !&#x3D; *(L.elem + i + 1)) &#123;            k++;            *(L.elem + k - 1) &#x3D; *(L.elem + i);        &#125;    &#125;    L.length &#x3D; k;    return true;&#125;int main()&#123;    SqList test;    InitList_Sq(test);    ListInsert_Sq(test, 1, 2);    ListInsert_Sq(test, 2, 2);    ListInsert_Sq(test, 3, 2);    ListInsert_Sq(test, 4, 3);    ListInsert_Sq(test, 5, 4);    ListInsert_Sq(test, 6, 5);    ListInsert_Sq(test, 7, 5);    ListInsert_Sq(test, 8, 6);    &#x2F;&#x2F;测试删除最小的元素    &#x2F;&#x2F;int tag;    &#x2F;&#x2F;ListDeleteMin_Sq(test, tag);    &#x2F;&#x2F;printf_s(&quot;%d&quot;, tag);    &#x2F;&#x2F;测试元素逆序    &#x2F;&#x2F;ListReverse_Sq(test);    &#x2F;&#x2F;ListPrint_Sq(test);    &#x2F;&#x2F;测试删除所有值为x的元素    &#x2F;&#x2F;ListDeleValue(test, 2);    &#x2F;&#x2F;ListPrint_Sq(test);    &#x2F;&#x2F;测试删除区间内的值    &#x2F;&#x2F;ListDeleValueBetween(test,2, 5);    &#x2F;&#x2F;ListPrint_Sq(test);    &#x2F;&#x2F;测试删除有序表中的重复值    ListDeleteDuplicateValueInOrder(test);    ListPrint_Sq(test);&#125;&#x2F;&#x2F; 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单&#x2F;&#x2F; 调试程序: F5 或调试 &gt;“开始调试”菜单&#x2F;&#x2F; 入门使用技巧: &#x2F;&#x2F;   1. 使用解决方案资源管理器窗口添加&#x2F;管理文件&#x2F;&#x2F;   2. 使用团队资源管理器窗口连接到源代码管理&#x2F;&#x2F;   3. 使用输出窗口查看生成输出和其他消息&#x2F;&#x2F;   4. 使用错误列表窗口查看错误&#x2F;&#x2F;   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目&#x2F;&#x2F;   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波拉契数列时间复杂度分析</title>
      <link href="/2021/06/30/fei-bo-la-qi-shu-lie-shi-jian-fu-za-du-fen-xi/"/>
      <url>/2021/06/30/fei-bo-la-qi-shu-lie-shi-jian-fu-za-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">斐波拉契数列时间复杂度分析</a><ul><li><a href="#%E9%80%92%E5%BD%92%E7%89%88">递归版</a><ul><li><a href="#%E8%AF%81%E6%98%8E1">证明1</a></li><li><a href="#%E8%AF%81%E6%98%8E2">证明2</a></li></ul></li></ul></li></ul><h1 id="斐波拉契数列时间复杂度分析"><a href="#斐波拉契数列时间复杂度分析" class="headerlink" title="斐波拉契数列时间复杂度分析"></a>斐波拉契数列时间复杂度分析</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>递归版本的时间复杂度分析，真的不知道怎么分析，需要根据<code>f(n) = f(n-1) + f(n-2)</code>推出通解。这显然是个数学问题。<br>不知道为什么他们会给出这结果，难道不管通项公式的后一项了？</p><p>通项公式如下:<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630173631.png" alt="20210630173631"></p><h3 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630173802.png" alt="20210630173802"></p><h3 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h3><p>还是看不太懂，为什么要给加法加个1呢？<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630174145.png" alt="20210630174145"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训day11</title>
      <link href="/2021/06/23/shi-xun-day11/"/>
      <url>/2021/06/23/shi-xun-day11/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#test">Test</a></li><li><a href="#%E4%BD%9C%E4%B8%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">作业功能实现</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF">修改代码思路</a></li><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li></ul></li></ul><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>关于git 中rebase和merge的区别<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210621145651.png" alt="20210621145651"></p><h1 id="作业功能实现"><a href="#作业功能实现" class="headerlink" title="作业功能实现"></a>作业功能实现</h1><ul><li><input checked="" disabled="" type="checkbox"> 增加时间搜索</li><li><input checked="" disabled="" type="checkbox"> 增加时间更新修改</li><li><input checked="" disabled="" type="checkbox"> 增加个人页面 并且展示当前登录用户的名称和此用户的个人信息，增加修改</li><li><input disabled="" type="checkbox"> (扩展)用户可以自定义上传头像更新 实现退出效果</li></ul><h2 id="修改代码思路"><a href="#修改代码思路" class="headerlink" title="修改代码思路"></a>修改代码思路</h2><ul><li><input disabled="" type="checkbox"> 更改前端代码，增加相应的板块</li><li><input disabled="" type="checkbox"> Mapper 添加相应的查询</li><li><input disabled="" type="checkbox"> Controller接口</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p><input checked="" disabled="" type="checkbox">  用户更新里面的时间输入框无法渲染,就像是个普通的input, —-是不是跟js代码的渲染顺序有关系？？？？</p><pre><code>在回调函数里面继续写js代码就行啦</code></pre></li><li><p><input checked="" disabled="" type="checkbox">  在用户个人页面把详细的信息以pojo对应的方式传进去</p></li><li><p><input checked="" disabled="" type="checkbox">  修改了代码后记得重新打包哦！！！  否则上传到服务器的包还是之前的jar包，就会恼火很长时间。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 国信安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode7/8-找链表交点/合并有序链表</title>
      <link href="/2021/06/15/leetcode78-zhao-lian-biao-jiao-dian-he-bing-you-xu-lian-biao/"/>
      <url>/2021/06/15/leetcode78-zhao-lian-biao-jiao-dian-he-bing-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#leetcode7-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9">leetcode7-找链表交点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li></ul></li><li><a href="#leetcode8-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">leetcode8-合并有序链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">复杂度分析</a></li></ul></li></ul></li></ul><h1 id="leetcode7-找链表交点"><a href="#leetcode7-找链表交点" class="headerlink" title="leetcode7-找链表交点"></a>leetcode7-找链表交点</h1><p>这个题目又没有好好审题，我以为的交点可以是这样的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113259.png" alt="20210615113259"></p><p>没想到交点以后的所有节点应该都是重合的！</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113350.png" alt="20210615113350"></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果有相交的结点D的话,每条链的头结点先走完自己的链表长度,然后回头走另外的一条链表,那么两结点一定为相交于D点,因为这时每个头结点走的距离是一样的,都是 AD + BD + DC,而他们每次又都是前进1,所以距离相同,速度又相同,固然一定会在相同的时间走到相同的结点上,即D点。</p><ul><li><p>如果不相交 ： 如果不相交的话 假设两个链表长度不相等 一个为A 一个为B ，指针第一次走完A会去走B,另一个走完B再去走A，两个指针走的路程都是A+B。会同时为NULL 跳出循环</p></li><li><p>如果不相交且链表长度相等: 那么一个指针走A,一个指针走B，它俩同时走到NULL，相等，跳出循环</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    struct ListNode* A, * B;    A &#x3D; headA;    B &#x3D; headB;    while(A!&#x3D;B)&#123;        A &#x3D; A &#x3D;&#x3D; NULL ? headB : A-&gt;next;        B &#x3D; B &#x3D;&#x3D; NULL ? headA : B-&gt;next;    &#125;    return A;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(N)</code> 最差依次访问一遍 <code>A+B</code> 中的所有节点 <br><br>空间复杂度 <code>O(1)</code> 就用两个指针</p><h1 id="leetcode8-合并有序链表"><a href="#leetcode8-合并有序链表" class="headerlink" title="leetcode8-合并有序链表"></a>leetcode8-合并有序链表</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。示例1：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;he-bing-liang-ge-pai-xu-de-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>leetcode的题解</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615164632.png" alt="20210615164632"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123;    struct ListNode* a, *b,*c,*d;    a &#x3D; l1;    b &#x3D; l2;    d &#x3D; c &#x3D; (struct ListNode*)malloc(sizeof(struct ListNode));    while(a&amp;&amp;b)&#123;        if(a-&gt;val &lt; b-&gt;val) &#123;            c-&gt;next &#x3D; a;            a &#x3D; a-&gt;next;            c &#x3D; c-&gt;next;        &#125;        else if(a-&gt;val&gt;&#x3D;b-&gt;val)&#123;            c-&gt;next &#x3D; b;            b &#x3D; b-&gt;next;            c &#x3D; c-&gt;next;        &#125;    &#125;    if(a &#x3D;&#x3D; NULL) c-&gt;next &#x3D; b;    else c-&gt;next &#x3D; a;    return d-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(M+N)</code> M为l1链表的长度 N为l2链表的长度 <br><br>空间复杂度 O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode5-反向输出链表</title>
      <link href="/2021/06/14/leetcode5-fan-xiang-shu-chu-lian-biao/"/>
      <url>/2021/06/14/leetcode5-fan-xiang-shu-chu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="反向输出链表"><a href="#反向输出链表" class="headerlink" title="反向输出链表"></a>反向输出链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre class="line-numbers language-none"><code class="language-none">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1：输入：head &#x3D; [1,3,2]输出：[2,3,1] 限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>第一遍遍历找到一共的个数</li><li>malloc</li><li>倒序赋值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;反序打印链表int* reversePrint(struct ListNode* head, int* returnSize) &#123;    &#x2F;&#x2F;第一遍遍历获取数目    int num &#x3D; 0;    struct ListNode* temp &#x3D; head;    while (temp)    &#123;        num++;        temp &#x3D; temp-&gt;next;    &#125;    int* ret &#x3D; (int*)malloc(num * sizeof(int));    memset(ret, -1, num * sizeof(int));        temp &#x3D; head;    int i &#x3D; 1;    while (temp)    &#123;        ret[num - i] &#x3D; temp-&gt;val;        i++;        temp &#x3D; temp-&gt;next;    &#125;    *returnSize &#x3D; num;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(n)<br>空间复杂度 O(n)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>差不多跟我一样</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int* reversePrint(struct ListNode* head, int* returnSize)&#123;    struct ListNode *p &#x3D; head;    int n &#x3D; 0;    while(p !&#x3D; NULL) &#123;        p &#x3D; p-&gt;next;        n++;    &#125;    int *arr &#x3D; (int *)malloc(sizeof(int) * n);    struct ListNode *q &#x3D; head;    *returnSize &#x3D; n;    for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--)&#123;        arr[i] &#x3D; q-&gt;val;        q &#x3D; q-&gt;next;    &#125;    return arr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode6-判断链表中是否存在环</title>
      <link href="/2021/06/14/leetcode6-pan-duan-lian-biao-zhong-shi-fou-cun-zai-huan/"/>
      <url>/2021/06/14/leetcode6-pan-duan-lian-biao-zhong-shi-fou-cun-zai-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode6-判断链表中是否存在环"><a href="#leetcode6-判断链表中是否存在环" class="headerlink" title="leetcode6-判断链表中是否存在环"></a>leetcode6-判断链表中是否存在环</h1><p>这道题感觉很难嗷！ 但是确实是属于简单题的行列( 我是fw )，全程都在看解析。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool hasCycle(struct ListNode* head) &#123;    if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;        return false;    &#125;    struct ListNode* slow &#x3D; head;    struct ListNode* fast &#x3D; head-&gt;next;    while (slow !&#x3D; fast) &#123;        if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) &#123;            return false;        &#125;        slow &#x3D; slow-&gt;next;        fast &#x3D; fast-&gt;next-&gt;next;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点数。</p><ul><li><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p></li><li><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p></li></ul></li><li><p>空间复杂度：<code>O(1)</code> 我们只使用了两个指针的额外空间。</p></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p>重要的是哈希表的原理<br>知乎的文章： 具体还是你后面去看看相应的源码，会比较方便一些。</p><p><a href="https://zhuanlan.zhihu.com/p/144296454">https://zhuanlan.zhihu.com/p/144296454</a></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p></li><li><p>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode4-删除链表节点</title>
      <link href="/2021/06/11/leetcode4-shan-chu-lian-biao-jie-dian/"/>
      <url>/2021/06/11/leetcode4-shan-chu-lian-biao-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="leecode4-删除链表节点"><a href="#leecode4-删除链表节点" class="headerlink" title="leecode4-删除链表节点"></a>leecode4-删除链表节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>说明：文章中的优秀思路均来自优秀题解的第一个，之所以截图是因为懒。。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。注意：此题对比原题有改动示例 1:输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2:输入: head &#x3D; [4,5,1,9], val &#x3D; 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;shan-chu-lian-biao-de-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里借鉴了前面看到优秀思路中的<strong>虚拟节点 virtualNode</strong> ,即在头节点head前再增加一个虚拟节点，可以避免讨论 <strong>tag</strong> 节点是否是头节点的情况。最后统一返回 <strong>virtualNode-&gt;next</strong></p><ul><li>遍历链表找到值相等的节点</li><li>保留节点的前驱节点 <strong>prev</strong></li><li>前驱节点 <strong>prev</strong> 指向删除节点 <strong>tag</strong> 的下一节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode* deleteNode(struct ListNode* head, int val) &#123;    struct ListNode* tag &#x3D; head, * prev&#x3D;NULL;    struct ListNode* virtualNode &#x3D; (ListNode*)malloc(sizeof(ListNode));    virtualNode-&gt;next &#x3D; head;    virtualNode-&gt;val &#x3D; -1;    prev &#x3D; virtualNode;    while (tag-&gt;next)    &#123;        if (tag-&gt;val &#x3D;&#x3D; val) break;        prev &#x3D; tag;        tag &#x3D; tag-&gt;next;    &#125;    prev-&gt;next &#x3D; tag-&gt;next;    return virtualNode-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果理解递归很困难，可以采用一种叫做<strong>坚定信念</strong>的理解方式。即假设<strong>deleteNode返回的值就是对应节点的下一个节点</strong>，那下面这个java版的递归就不难理解了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611093444.png" alt="20210611093444"></p>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py如何根据字符串来创建对应的类</title>
      <link href="/2021/06/11/py-ru-he-gen-ju-zi-fu-chuan-lai-chuang-jian-dui-ying-de-lei/"/>
      <url>/2021/06/11/py-ru-he-gen-ju-zi-fu-chuan-lai-chuang-jian-dui-ying-de-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="py如何根据字符串来创建对应的类"><a href="#py如何根据字符串来创建对应的类" class="headerlink" title="py如何根据字符串来创建对应的类"></a>py如何根据字符串来创建对应的类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>py的反射原理，简单来说，反射就是能实现动态地调用方法\实例化对象。</p><p>举个例子:<br></p><p>创建一个学生类Student的对象 person1、创建一个老师类Teacher的对象person1</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">person1 &#x3D; Student(name&#x3D;&quot;张三&quot;)orperson1 &#x3D; Teacher(name&#x3D;&quot;张三&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>试想一下，假如，你并不是先前(在写程序之前)就知道这个person1的身份到底是学生还是老师，那你该如何创建这个对象？</p><p>或者说你要 <strong>根据这个人的输入: 职业:老师,姓名:张三</strong> 来动态的创建对象。</p><p>这里就要用到py的反射</p><p>对应到web路由可能更容易理解。详细请看 <a href="https://www.liujiangblog.com/course/python/48">https://www.liujiangblog.com/course/python/48</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在本次实训的过程中，由于是基线检查，但是对于每个审查条目的规则(存储在数据库)是不一样的。</p><p>关键的是，所用的validator中预制的规则rule无法满足特定的需求。然后，除了使用他文档中的规则意外，我根据他自定义规则的写法，自定义如下三种规则</p><ul><li>AuditRule-判断前后集合是否一致</li><li>AuditRuleInclude-判断前面集合是否是后面集合的子集</li><li>AuditRuleSame-判断两个字符串是否相等。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class AuditRule(Rule):    &quot;&quot;&quot;    TestCode:        rules &#x3D; &#123;&quot;age&quot;: AuditRule(&#39;test,test&#39;)&#125;        req &#x3D; &#123;&quot;age&quot;: &#39;test,test&#39;&#125;        print(validate(req, rules,return_info&#x3D;True))    &quot;&quot;&quot;    def __init__(self, string: str):        Rule.__init__(self)        self.string &#x3D; string        self.value &#x3D; string.split(&#39;,&#39;)    def check(self, arg: str):        if arg is None:            arg &#x3D; &quot;Null&quot;            self.set_error(&quot;excepted get |&quot; + self.string + &quot;| but get |&quot; + arg.replace(&quot;\&quot;&quot;, &quot;&quot;) + &quot;|&quot;)            return False        exit_value_list &#x3D; arg.split(&#39;,&#39;)        # 判断两个集合是否一样  前面是否是后面的子集        self.set_error(&quot;excepted get |&quot; + self.string + &quot;| but get |&quot; + arg.replace(&quot;\&quot;&quot;, &quot;&quot;) + &quot;|&quot;)        return set(exit_value_list) &#x3D;&#x3D; set(self.value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，我所用的validator这个包，就已经利用了反射。因为他就是根据我输入的字符串，去动态地翻译和创建成对应的类。所以我也想实现根据数据库中存储的规则，来动态地创建。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611161640.png" alt="20210611161640"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="使用的函数"><a href="#使用的函数" class="headerlink" title="使用的函数"></a>使用的函数</h3><p>我就只用到了<strong>getattr</strong>函数。其对应的文档解释如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getattr(object, name, default&#x3D;None): # known special case of getattr    &quot;&quot;&quot;    getattr(object, name[, default]) -&gt; value        Get a named attribute from an object; getattr(x, &#39;y&#39;) is equivalent to x.y.    When a default argument is given, it is returned when the attribute doesn&#39;t    exist; without it, an exception is raised in that case.    &quot;&quot;&quot;    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ul><li><p>创建package rules 将自定义的三个类分别以.py的形式放进去</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162135.png" alt="20210611162135"></p></li><li><p>在package中创建rules.py的文件，将自定义类，导入。<strong>第一行不要也可以</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162237.png" alt="20210611162237"></p></li><li><p>在要使用的文件中，以<strong>from rules import rules as Custom</strong>的形式导入</p></li><li><p>编写相应的代码</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">for item in results:if item[3].startswith(&quot;Audit&quot;):    rules[item[0]] &#x3D; getattr(Custom, item[3])(item[2])else:    rules[item[0]] &#x3D; item[1] + &quot;:&quot; + item[2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>它对应的原理通过debug我猜测如下:<br>通过 <code>from rules import rules as Custom</code> 的方式其实是已经创建了<code>Custom</code>这个对象，其拥有三个自定义类的属性。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162753.png" alt="20210611162753"></p><p>然后通过<code>getattr</code>得到字符串对应的属性(类),并通过后面括号里面的字符串进行实例化。</p>]]></content>
      
      
      <categories>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode3-反转链表II</title>
      <link href="/2021/06/10/leetcode3-fan-zhuan-lian-biao-ii/"/>
      <url>/2021/06/10/leetcode3-fan-zhuan-lian-biao-ii/</url>
      
        <content type="html"><![CDATA[<p>目录:</p><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii">反转链表II</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li><li><a href="#%E4%BC%98%E7%A7%80%E6%80%9D%E8%B7%AF">优秀思路</a><ul><li><a href="#%E6%96%B9%E6%B3%951">方法1:</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">时间复杂度分析</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C">方法二</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">时间复杂度分析</a></li></ul></li></ul></li></ul></li></ul><h1 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a>反转链表II</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><pre class="line-numbers language-none"><code class="language-none">给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1：输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4输出：[1,4,3,2,5]示例 2：输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1输出：[5] 提示：链表中节点数目为 n1 &lt;&#x3D; n &lt;&#x3D; 500-500 &lt;&#x3D; Node.val &lt;&#x3D; 5001 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>左端节点不是起始节点</li></ol><ul><li>找到左端点的前一个节点 <strong>leftpointer_1</strong> + 左端点 <strong>leftpointer</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端点的前一个节点 <strong>leftpointer_1</strong> 的next指向右端点 </li><li><strong>返回 head 头节点</strong></li></ul><ol start="2"><li>左端节点是起始节点(head)</li></ol><ul><li>左端点的前一个节点 <strong>leftpointer_1</strong> 为 <strong>null</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li><strong>返回右端节点 <strong>prev</strong></strong></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode* reverseBetween(struct ListNode* head, int left, int right) &#123;    struct ListNode* leftpointer_1, * rightpointer_1;    leftpointer_1 &#x3D; rightpointer_1 &#x3D; head;    int leftmove &#x3D; left - 2;    int rigthmove &#x3D; right - left;    int temp &#x3D; rigthmove;    if (temp &#x3D;&#x3D; 0 || temp &lt; 0) return head;    if (leftmove &#x3D;&#x3D; -1) leftpointer_1 &#x3D; NULL;    else    &#123;        while (leftmove &gt; 0 &amp;&amp; leftpointer_1-&gt;next)        &#123;            leftpointer_1 &#x3D; leftpointer_1-&gt;next;            leftmove--;        &#125;    &#125;    struct ListNode* prev &#x3D; leftpointer_1;    struct ListNode* curr, * leftpointer;    if (leftpointer_1)     curr &#x3D; leftpointer &#x3D; leftpointer_1-&gt;next;    else curr &#x3D; leftpointer &#x3D; head;    while (curr &amp;&amp; temp &gt;&#x3D; 0) &#123;        struct ListNode* next &#x3D; curr-&gt;next;        curr-&gt;next &#x3D; prev;        prev &#x3D; curr;        curr &#x3D; next;        temp--;        rightpointer_1 &#x3D; curr;    &#125;    if (leftpointer_1) &#123;        leftpointer_1-&gt;next &#x3D; prev;        leftpointer-&gt;next &#x3D; rightpointer_1;        return head;    &#125;    else &#123;        leftpointer-&gt;next &#x3D; rightpointer_1;        return prev;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>与我们的方法非常类似，但在编码的过程中，采用了虚拟头节点的方式，避免了左端点是否是起始点的分类讨论。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610143526.png" alt="20210610143526"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;    &#x2F;&#x2F; 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论    struct ListNode *dummyNode &#x3D; malloc(sizeof(struct ListNode));    dummyNode-&gt;val &#x3D; -1;    dummyNode-&gt;next &#x3D; head;    struct ListNode *pre &#x3D; dummyNode;    &#x2F;&#x2F; 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点    &#x2F;&#x2F; 建议写在 for 循环里，语义清晰    for (int i &#x3D; 0; i &lt; left - 1; i++) &#123;        pre &#x3D; pre-&gt;next;    &#125;    &#x2F;&#x2F; 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点    struct ListNode *rightNode &#x3D; pre;    for (int i &#x3D; 0; i &lt; right - left + 1; i++) &#123;        rightNode &#x3D; rightNode-&gt;next;    &#125;    &#x2F;&#x2F; 第 3 步：切断出一个子链表（截取链表）    struct ListNode *leftNode &#x3D; pre-&gt;next;    struct ListNode *curr &#x3D; rightNode-&gt;next;    &#x2F;&#x2F; 注意：切断链接    pre-&gt;next &#x3D; NULL;    rightNode-&gt;next &#x3D; NULL;    &#x2F;&#x2F; 第 4 步：同第 206 题，反转链表的子区间    reverseLinkedList(leftNode);    &#x2F;&#x2F; 第 5 步：接回到原来的链表中    pre-&gt;next &#x3D; rightNode;    leftNode-&gt;next &#x3D; curr;    return dummyNode-&gt;next;&#125;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reverse-linked-list-ii&#x2F;solution&#x2F;fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq&#x2F;来源：力扣（LeetCode）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610144049.png" alt="20210610144049"></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;    &#x2F;&#x2F; 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论    struct ListNode *dummyNode &#x3D; malloc(sizeof(struct ListNode));    dummyNode-&gt;val &#x3D; -1;    dummyNode-&gt;next &#x3D; head;    struct ListNode *pre &#x3D; dummyNode;    for (int i &#x3D; 0; i &lt; left - 1; i++) &#123;        pre &#x3D; pre-&gt;next;    &#125;    struct ListNode *cur &#x3D; pre-&gt;next;    struct ListNode *next;    for (int i &#x3D; 0; i &lt; right - left; i++) &#123;        next &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; next-&gt;next;        next-&gt;next &#x3D; pre-&gt;next;        pre-&gt;next &#x3D; next;    &#125;    return dummyNode-&gt;next;&#125;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reverse-linked-list-ii&#x2F;solution&#x2F;fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2-反转链表</title>
      <link href="/2021/06/08/leetcode2-fan-zhuan-lian-biao/"/>
      <url>/2021/06/08/leetcode2-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;fan-zhuan-lian-biao-lcof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>链表没有节点</li><li>链表只有一个节点</li><li>链表有两个节点</li><li>链表有三个及三个以上的节点</li></ol><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/%E7%94%A8ipad%E6%8A%8A%E6%80%9D%E8%B7%AF%E7%9A%84%E5%9B%BE%E7%94%BB%E5%9C%A8%E8%BF%99.png" alt="用ipad把思路的图画在这"></p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>由于只用遍历一遍链 <br><br>时间复杂度为<strong>O(n) n 为链表的长度</strong> <br><br>以上代码，<strong>分配的空间不会随着处理数据量的变化而变化，因此得到空间复杂度为 O空间复杂度为O(1</strong>)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>这次优秀思路其实跟我思路差不多，但是优秀思路的代码写的要更简洁。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210608172423.png" alt="20210608172423"></p><h2 id="我思路的代码"><a href="#我思路的代码" class="headerlink" title="我思路的代码"></a>我思路的代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode* reverseList(struct ListNode* head) &#123;    ListNode* first,*second,*third;        &#x2F;&#x2F; 0个节点    if (head &#x3D;&#x3D; NULL) return NULL;    &#x2F;&#x2F; 1个节点    if (head-&gt;next &#x3D;&#x3D; NULL) return head;    &#x2F;&#x2F; 2个节点    if (head-&gt;next-&gt;next &#x3D;&#x3D; NULL) &#123;        first &#x3D; head;        second &#x3D; head-&gt;next;        first-&gt;next &#x3D; NULL;        second-&gt;next &#x3D; first;        return second;    &#125;    &#x2F;&#x2F; 3个以上的节点    first &#x3D; head;    second &#x3D; head-&gt;next;    third &#x3D; head-&gt;next-&gt;next;        while (1) &#123;        second-&gt;next &#x3D; first;        if (third &#x3D;&#x3D; NULL) break;        first &#x3D; second;        second &#x3D; third;        third &#x3D; third-&gt;next;    &#125;    &#x2F;&#x2F;把第一个节点的next指向null    head-&gt;next &#x3D; NULL;    &#x2F;&#x2F;返回头节点    return second;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>validator使用</title>
      <link href="/2021/06/08/validator-shi-yong/"/>
      <url>/2021/06/08/validator-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="validator使用"><a href="#validator使用" class="headerlink" title="validator使用"></a>validator使用</h1><p>看清楚使用的是哪个包，去找相应的文档就行。</p><p>我使用的是这个validator包 :<a href="https://github.com/CSenshi/Validator">https://github.com/CSenshi/Validator</a></p><p>网上的教程很多都是 <a href="https://github.com/mansam/validator.py%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E7%9C%8B%E4%BA%86%E6%96%87%E6%A1%A3%E5%92%8C%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8A%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E3%80%82">https://github.com/mansam/validator.py，所以在看了文档和源码之后，把使用方法整理一下。</a></p><p>本来是要整理一下，但是发现人家文档写的很清楚了。</p><p>链接：<a href="https://github.com/CSenshi/Validator">https://github.com/CSenshi/Validator</a></p>]]></content>
      
      
      <categories>
          
          <category> 包使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训day6-day10</title>
      <link href="/2021/06/07/shi-xun-day6-10/"/>
      <url>/2021/06/07/shi-xun-day6-10/</url>
      
        <content type="html"><![CDATA[<h1 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h1><p>总体来说这一周相较于上一周来说没有学到太多东西，最有收获的还是初步地应用了一下反射，还有就是关于编码的简洁性。</p><p>诸如向安全组审核的东西，不过是读文件审核再写回数据库，可以说没有什么难度，只是工作的过程相对来说要繁琐一些，要去跟英文的文档做一个对应，复制粘贴本地安全组中的说明内容等等。</p><h1 id="circular-import"><a href="#circular-import" class="headerlink" title="circular import"></a>circular import</h1><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210607095716.png" alt="20210607095716"></p><h1 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h1><p>RFC（Request For Comments）意即“请求评论”，包含了关于Internet的几乎所有重要的文字资料</p><h1 id="用户权限分配"><a href="#用户权限分配" class="headerlink" title="用户权限分配"></a>用户权限分配</h1><p>或者直接去微软的网站上面翻译：<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221963%28v%3dws.11%29">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221963%28v%3dws.11%29</a></p><h2 id="对应中文"><a href="#对应中文" class="headerlink" title="对应中文"></a>对应中文</h2><table><thead><tr><th>常量值</th><th>组策略</th></tr></thead><tbody><tr><td>SeNetworkLogonRight</td><td>从网络访问此计算机</td></tr><tr><td>SeBackupPrivilege</td><td>备份文件和目录</td></tr><tr><td>SeChangeNotifyPrivilege</td><td>绕过遍历检查</td></tr><tr><td>SeSystemtimePrivilege</td><td>更改系统时间</td></tr><tr><td>SeCreatePagefilePrivilege</td><td>创建一个页面文件</td></tr><tr><td>SeDebugPrivilege</td><td>调试程序</td></tr><tr><td>SeRemoteShutdownPrivilege</td><td>从远程系统强制关机</td></tr><tr><td>SeAuditPrivilege</td><td>管理审核安全日志</td></tr><tr><td>SeIncreaseQuotaPrivilege</td><td>信任计算机和用户帐户可以执行委派</td></tr><tr><td>SeIncreaseBasePriorityPrivilege</td><td>提高计划优先级</td></tr><tr><td>SeLoadDriverPrivilege</td><td>加载和卸载设备驱动程序</td></tr><tr><td>SeBatchLogonRight</td><td>作为批处理作业登录</td></tr><tr><td>SeServiceLogonRight</td><td>拒绝作为服务登录</td></tr><tr><td>SeInteractiveLogonRight</td><td>本地登录</td></tr><tr><td>SeSecurityPrivilege</td><td>管理审核和安全日志</td></tr><tr><td>SeSystemEnvironmentPrivilege</td><td>修改固件环境值</td></tr><tr><td>SeProfileSingleProcessPrivilege</td><td>配置文件单一进程</td></tr><tr><td>SeSystemProfilePrivilege</td><td>配置文件系统性能</td></tr><tr><td>SeAssignPrimaryTokenPrivilege</td><td>创建令牌对象</td></tr><tr><td>SeRestorePrivilege</td><td>还原文件和目录</td></tr><tr><td>SeShutdownPrivilege</td><td>关闭系统</td></tr><tr><td>SeTakeOwnershipPrivilege</td><td>取得文件或其他对象的所有权</td></tr><tr><td>SeUndockPrivilege</td><td>从扩展坞上移除计算机</td></tr><tr><td>SeManageVolumePrivilege</td><td>执行卷维护任务</td></tr><tr><td>SeRemoteInteractiveLogonRight</td><td>允许通过远程桌面服务登录</td></tr><tr><td>SeImpersonatePrivilege</td><td>身份验证后模拟客户端</td></tr><tr><td>SeCreateGlobalPrivilege</td><td>创建全局对象</td></tr><tr><td>SeIncreaseWorkingSetPrivilege</td><td>增加进程工作集</td></tr><tr><td>SeTimeZonePrivilege</td><td>更改时区</td></tr><tr><td>SeCreateSymbolicLinkPrivilege</td><td>创建符号链接</td></tr><tr><td>SeDelegateSessionUserImpersonatePrivilege</td><td>信任计算机和用户帐户可以执行委派</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 国信安实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-1-单链表输出倒数第k个节点</title>
      <link href="/2021/06/06/leetcode1-dan-lian-biao-shu-chu-dao-shu-di-k-ge-jie-dian/"/>
      <url>/2021/06/06/leetcode1-dan-lian-biao-shu-chu-dao-shu-di-k-ge-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表输出倒数第k个节点"><a href="#单链表输出倒数第k个节点" class="headerlink" title="单链表输出倒数第k个节点"></a>单链表输出倒数第k个节点</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>遍历得到链表的节点个数</li><li>再根据节点个数和k得到目标节点的正向序号</li><li>遍历链表找到该节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="单链表版"><a href="#单链表版" class="headerlink" title="单链表版"></a>单链表版</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode &#123;    int val;    struct ListNode* next;&#125;;struct ListNode* getKthFromEnd(struct ListNode* head, int k) &#123;    int all &#x3D; 0;    ListNode* temp &#x3D; head;    while (temp-&gt;next)    &#123;        all++;        temp &#x3D; temp-&gt;next;    &#125;    all &#x3D; all + 1;&#x2F;&#x2F;加上最后一个节点    int num &#x3D; all - k + 1;    if (num &lt; 1) return NULL;    else    &#123;        temp &#x3D; head;        while (num !&#x3D; 1)        &#123;            temp &#x3D; temp-&gt;next;            num--;        &#125;        return temp;    &#125;&#125;int main()&#123;    ListNode *ahead, *after, *head, *result, *temp;    ahead &#x3D; (struct ListNode*)malloc(sizeof(ListNode));    ahead-&gt;val &#x3D; 1;    head &#x3D; ahead;    for (int i &#x3D; 1; i &lt; 7; i&#x3D;i+1) &#123;        after &#x3D; (struct ListNode*)malloc(sizeof(ListNode));        after-&gt;val &#x3D; i + 1;        after-&gt;next &#x3D; NULL;        ahead-&gt;next &#x3D; after;        ahead &#x3D; after;    &#125;    temp &#x3D; head;    while (1) &#123;        printf_s(&quot;%d-&gt;&quot;, temp-&gt;val);        if (temp-&gt;next&#x3D;&#x3D;NULL) &#123;            printf_s(&quot;\n%s&quot;, &quot;跳出循环&quot;);            break;        &#125;        temp &#x3D; temp-&gt;next;    &#125;        result &#x3D; getKthFromEnd(head, 1);    if (result-&gt;next) &#123;        printf_s(&quot;\n%d-&gt;%d&quot;, result-&gt;val, result-&gt;next-&gt;val);&#x2F;&#x2F;这里有可能result没有next节点    &#125;    else         printf_s(&quot;\n%d&quot;, result-&gt;val);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双链表版"><a href="#双链表版" class="headerlink" title="双链表版"></a>双链表版</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;双向链表版struct ListNode &#123;    int val;    struct ListNode* next;&#x2F;&#x2F;前向指针    struct ListNode* previous;&#x2F;&#x2F;后向指针&#125;;struct ListNode* getKthFromEnd(struct ListNode* head, int k) &#123;    ListNode* temp &#x3D; head;    while (temp-&gt;next)    &#123;        temp &#x3D; temp-&gt;next;    &#125;    if (k &lt; 1) return NULL;    else    &#123;        while (k !&#x3D; 1)        &#123;            temp &#x3D; temp-&gt;previous;            k--;        &#125;        return temp;    &#125;&#125;int main()&#123;    ListNode* ahead, * after, * head, * result, * temp;    ahead &#x3D; (struct ListNode*)malloc(sizeof(ListNode));    ahead-&gt;val &#x3D; 1;    ahead-&gt;previous &#x3D; NULL;    head &#x3D; ahead;    &#x2F;&#x2F;temp &#x3D; ahead;    for (int i &#x3D; 1; i &lt; 7; i &#x3D; i + 1) &#123;        after &#x3D; (struct ListNode*)malloc(sizeof(ListNode));        after-&gt;val &#x3D; i + 1;        after-&gt;next &#x3D; NULL;        after-&gt;previous &#x3D; ahead;                ahead-&gt;next &#x3D; after;        ahead &#x3D; after;    &#125;    temp &#x3D; head;    while (1) &#123;        printf_s(&quot;%d-&gt;&quot;, temp-&gt;val);        if (temp-&gt;next &#x3D;&#x3D; NULL) &#123;            printf_s(&quot;\n%s&quot;, &quot;跳出循环&quot;);            break;        &#125;        temp &#x3D; temp-&gt;next;    &#125;    result &#x3D; getKthFromEnd(head, 2);    if (result-&gt;next) &#123;        printf_s(&quot;\n%d-&gt;%d&quot;, result-&gt;val, result-&gt;next-&gt;val);&#x2F;&#x2F;这里有可能result没有next节点    &#125;    else        printf_s(&quot;\n%d&quot;, result-&gt;val);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优秀解题思路"><a href="#优秀解题思路" class="headerlink" title="优秀解题思路"></a>优秀解题思路</h2><ul><li>初始化两个指针a,b 指向头节点</li><li>b指针先往前走k个节点</li><li>a,b指针同时向前走，直到b为空指针</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct ListNode* getKthFromEnd(struct ListNode* head, int k)&#123;    struct ListNode *prev, *cur;    prev &#x3D; head;    cur &#x3D; head;    for(k&#x3D;k-1;k&gt;0;k--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    while(cur-&gt;next !&#x3D; NULL)&#123;        prev &#x3D; prev-&gt;next;        cur &#x3D; cur-&gt;next;    &#125;    return prev;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训day5</title>
      <link href="/2021/06/04/shi-xun-day5/"/>
      <url>/2021/06/04/shi-xun-day5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring入门4"><a href="#Spring入门4" class="headerlink" title="Spring入门4"></a>Spring入门4</h1><p>项目代码:<a href="https://gitee.com/laobameishijia/guoxinan-practical-training">https://gitee.com/laobameishijia/guoxinan-practical-training</a></p><ul><li><a href="#spring%E5%85%A5%E9%97%A84">Spring入门4</a><ul><li><a href="#%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0">简单登录页面实现</a><ul><li><a href="#%E9%A2%84%E6%9C%9F%E6%95%88%E6%9E%9C">预期效果</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">实现过程</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0">创建服务接口，并实现</a></li><li><a href="#%E5%86%99%E5%A5%BDmapper%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">写好mapper,进行数据查询</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E4%BC%A0%E5%8F%82">控制器注册服务，传参</a></li></ul></li></ul></li><li><a href="#springboot%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C">Springboot数据校验</a><ul><li><a href="#%E6%90%9E%E6%B8%85%E6%A5%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B">搞清楚什么是面向切面编程</a></li><li><a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB----%E5%86%99%E4%B8%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3">实体类—-写上相关注解</a></li><li><a href="#%E6%A0%A1%E9%AA%8C%E7%B1%BB----%E6%A3%80%E9%AA%8C%E6%95%B0%E6%8D%AE%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%94%B1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">校验类—-检验数据、抛出异常,由异常处理类进行处理</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8----%E5%B0%86%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BC%A0%E7%BB%99%E6%A0%A1%E9%AA%8C%E7%B1%BB%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C">控制器—-将前端传入数据传给校验类进行校验</a></li></ul></li><li><a href="#springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8">Springboot全局异常</a><ul><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB">异常处理类</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8--%E4%BB%A5%E7%99%BB%E5%BD%95%E5%BC%82%E5%B8%B8%E4%B8%BA%E4%BE%8B">自定义异常–以登录异常为例</a></li><li><a href="#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">在服务中抛出异常</a></li></ul></li><li><a href="#spring%E6%8B%A6%E6%88%AA%E5%99%A8">Spring拦截器</a><ul><li><a href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8">登录拦截器</a></li><li><a href="#%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AA%E5%99%A8">注册拦截器</a></li></ul></li></ul></li></ul><h2 id="简单登录页面实现"><a href="#简单登录页面实现" class="headerlink" title="简单登录页面实现"></a>简单登录页面实现</h2><h3 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h3><ul><li>登录成功，进入主页—登录成功</li><li>登录失败：告诉用户具体错误–用户不存在、密码不正确、登录失败</li><li>退出登录，提示用户是否退出，点击是删除session退出登录。</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>处理持久层—(操作数据库的Mapper)的代码：查询—findByName(String adminName) 找不到—提示用户不存在</li><li>处理登录业务逻辑(服务Service)—-实现登录失败、密码不正确几种情况的逻辑。</li><li>控制层—-路由控制、结果返回</li><li>表现层(视图、网页)—-ajax异步请求、Session保留会话</li></ul><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210605102000.png" alt="20210605102000"></p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="创建服务接口，并实现"><a href="#创建服务接口，并实现" class="headerlink" title="创建服务接口，并实现"></a>创建服务接口，并实现</h4><p>接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface LoginService &#123;    &#x2F;**     * 用户登录     * @param admin     * @return     *&#x2F;    JsonData login (Admin admin, HttpSession session);    JsonData exit (HttpServletRequest request);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class LoginServiceImpl implements LoginService &#123;        @Autowired    private AdminMapper mapper;        @Override    public  JsonData login(Admin admin, HttpSession session)&#123;        &#x2F;&#x2F;数据校验                &#x2F;&#x2F;从数据库中查数据        Admin dbAdmin &#x3D; mapper.findoneByName(admin.getAdminName());                if (dbAdmin &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F;说明用户不存在&#x2F;&#x2F;            return new JsonData(1001,&quot;用户不存在&quot;);            throw new LoginException(1001,&quot;用户不存在&quot;);        &#125;                &#x2F;&#x2F;判断状态        if(dbAdmin.getAdminStatus()!&#x3D;null &amp;&amp; !(dbAdmin.getAdminStatus().equals(0)))&#123;&#x2F;&#x2F;            return new JsonData(1001,&quot;用户被锁定,联系管理员&quot;);            throw new LoginException(1002,&quot;用户被锁定,联系管理员&quot;);        &#125;                &#x2F;&#x2F;判断密码正确        if(!dbAdmin.getAdminPwd().equals(admin.getAdminPwd()))&#123;&#x2F;&#x2F;            return new JsonData(1001,&quot;密码错误&quot;);            throw new LoginException(1003,&quot;密码错误&quot;);        &#125;        &#x2F;&#x2F;存到session        session.setAttribute(&quot;adminName&quot;,admin.getAdminName());        &#x2F;&#x2F;更新用户最后登录时间        dbAdmin.setLastLoginTime(new Timestamp(System.currentTimeMillis()));        &#x2F;&#x2F;dbAdmin没有问题        System.out.println(dbAdmin.toString());        mapper.update(dbAdmin);        return new JsonData(200,&quot;登录正常&quot;);            &#125;    @Override    public  JsonData exit(HttpServletRequest request)&#123;        request.getSession().invalidate();        return new JsonData(200,&quot;退出正常&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="写好mapper-进行数据查询"><a href="#写好mapper-进行数据查询" class="headerlink" title="写好mapper,进行数据查询"></a>写好mapper,进行数据查询</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 主要用来操作数据库，增删改查 *&#x2F;@Mapperpublic interface AdminMapper &#123;    &#x2F;**     * 查询所有数据     *&#x2F;    List&lt;Admin&gt; findAll();    List&lt;Admin&gt; fineByParam(@Param(&quot;param&quot;) MyParam param);    &#x2F;**     *增加     * @param admin     *&#x2F;    void save(@Param(&quot;admin&quot;) Admin admin);    &#x2F;**     * 真删除     *&#x2F;    void deleteTrue(@Param(&quot;delete&quot;) Integer id);    &#x2F;**     * 更新     * @param admin     *&#x2F;    void update(@Param(&quot;admin&quot;) Admin admin);    &#x2F;**     * 软删除     * @param id     *&#x2F;    void deleteFalse(@Param(&quot;id&quot;) Integer id);    &#x2F;**     * 查询单条数据     * @param id     *&#x2F;    Admin findone(@Param(&quot;id&quot;) Integer id);    &#x2F;**     * 通过用户名查询对应的用户     * @param name     * @return     *&#x2F;    Admin findoneByName(@Param(&quot;name&quot;) String name);    &#x2F;**     * 批量插入     *&#x2F;    int insertBatch(@Param(&quot;adminList&quot;) List&lt;Admin&gt; adminList);    &#x2F;**     * 批量删除     * @param adminList     * @return     *&#x2F;    int deleteBatch(@Param(&quot;adminList&quot;) List&lt;Admin&gt; adminList);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="控制器注册服务，传参"><a href="#控制器注册服务，传参" class="headerlink" title="控制器注册服务，传参"></a>控制器注册服务，传参</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LoginController &#123;    @Autowired    private LoginServiceImpl loginService;    @RequestMapping(&quot;&#x2F;page&quot;)    public String login() &#123;        return &quot;login&quot;;    &#125;    @PostMapping(&quot;&#x2F;verify&quot;)    @ResponseBody&#x2F;&#x2F;不需要进行页面跳转而是直接返回数据。    &#x2F;&#x2F;添加了@ResponseBody注解的方法，返回值会通过HTTP响应主体直接发送给浏览器。    public JsonData verifyLogin(@Validated Admin admin, BindingResult result, HttpSession session) throws Exception &#123;        &#x2F;&#x2F;数据校验        &#x2F;&#x2F;获取所有错误        ValidatorUtil.showMsg(result);        return loginService.login(admin, session);    &#125;    @PostMapping(&quot;&#x2F;exit&quot;)    @ResponseBody&#x2F;&#x2F;不需要进行页面跳转而是直接返回数据。    &#x2F;&#x2F;添加了@ResponseBody注解的方法，返回值会通过HTTP响应主体直接发送给浏览器。    public JsonData exit(HttpServletRequest request) throws Exception &#123;        return loginService.exit(request);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Springboot数据校验"><a href="#Springboot数据校验" class="headerlink" title="Springboot数据校验"></a>Springboot数据校验</h2><h3 id="搞清楚什么是面向切面编程"><a href="#搞清楚什么是面向切面编程" class="headerlink" title="搞清楚什么是面向切面编程"></a>搞清楚什么是面向切面编程</h3><p>AOP技术利用一种称为“横切”的技术，剖解开封装对象的内部，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为Aspect切面。所谓的切面，简单来说就是与业务无关，却为业务模块所共同调用的逻辑，将其封装起来便于减少系统的重复代码，降低模块的耦合度，有利用未来的可操作性和可维护性。</p><p>例如：银行系统的取款流程和查询余额的流程</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210605095214.png" alt="20210605095214"></p><p>hibernate validator 加几个注释，由后端检验<br>一般来说，Web应用都是前后端都会对数据进行校验，前端一般是用js正则进行校验，后端主要是对传入接口的数据进行校验，不能对一些无效的数据产生返回。</p><h3 id="实体类—-写上相关注解"><a href="#实体类—-写上相关注解" class="headerlink" title="实体类—-写上相关注解"></a>实体类—-写上相关注解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Admin &#123;  private Integer id;  @NotBlank(message &#x3D; &quot;用户名不能为空！&quot;)  private String adminName;  @NotBlank(message &#x3D; &quot;密码不能为空&quot;)  private String adminPwd;  private Long adminPhone;  private Timestamp lastLoginTime;  private Timestamp createTime;  private Timestamp updateTime;  private Integer adminStatus;  private Integer isDeleted;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="校验类—-检验数据、抛出异常-由异常处理类进行处理"><a href="#校验类—-检验数据、抛出异常-由异常处理类进行处理" class="headerlink" title="校验类—-检验数据、抛出异常,由异常处理类进行处理"></a>校验类—-检验数据、抛出异常,由异常处理类进行处理</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidatorUtil &#123;    &#x2F;**     * 展示错误信息     *&#x2F;    public static void showMsg(BindingResult result) throws Exception &#123;        List&lt;ObjectError&gt; allErrors &#x3D; result.getAllErrors();        for (ObjectError error : allErrors) &#123;            throw  new Exception(error.getDefaultMessage());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="控制器—-将前端传入数据传给校验类进行校验"><a href="#控制器—-将前端传入数据传给校验类进行校验" class="headerlink" title="控制器—-将前端传入数据传给校验类进行校验"></a>控制器—-将前端传入数据传给校验类进行校验</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidatorUtil &#123;    &#x2F;**     * 展示错误信息     *&#x2F;    public static void showMsg(BindingResult result) throws Exception &#123;        List&lt;ObjectError&gt; allErrors &#x3D; result.getAllErrors();        for (ObjectError error : allErrors) &#123;            throw  new Exception(error.getDefaultMessage());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Springboot全局异常"><a href="#Springboot全局异常" class="headerlink" title="Springboot全局异常"></a>Springboot全局异常</h2><p>着重去理解异常类抛出和处理的顺序。抛出了哪个是由哪个类处理，往调用者抛出????</p><p>SpringBoot中有一个<code>ControllerAdvice</code>的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用<code>ExceptionHandler</code>注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。非常方便后续异常的分类处理以及代码维护</p><h3 id="异常处理类"><a href="#异常处理类" class="headerlink" title="异常处理类"></a>异常处理类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvicepublic class MyExceptionAdvice &#123;        &#x2F;**     * 专门用于处理登录异常     * @param e     * @return     *&#x2F;    @ExceptionHandler(LoginException.class)    public JsonData loginExceptionHandler(LoginException e)&#123;        return new JsonData(e.getCode(),e.getMessage());    &#125;        @ExceptionHandler(Exception.class)    public JsonData  exceptionHandler(Exception e) &#123;        &#x2F;&#x2F;记录异常日志        &#x2F;&#x2F;异常日志对于系统非常重要                return new JsonData(1002,e.getMessage());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义异常–以登录异常为例"><a href="#自定义异常–以登录异常为例" class="headerlink" title="自定义异常–以登录异常为例"></a>自定义异常–以登录异常为例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LoginException extends RuntimeException &#123;    private Integer code;    private String msg;    public LoginException() &#123;    &#125;    public LoginException(Integer code, String msg) &#123;        super(msg);        this.code &#x3D; code;        this.msg &#x3D; msg;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code &#x3D; code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg &#x3D; msg;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在服务中抛出异常"><a href="#在服务中抛出异常" class="headerlink" title="在服务中抛出异常"></a>在服务中抛出异常</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class LoginServiceImpl implements LoginService &#123;        @Autowired    private AdminMapper mapper;        @Override    public  JsonData login(Admin admin, HttpSession session)&#123;        &#x2F;&#x2F;数据校验                &#x2F;&#x2F;从数据库中查数据        Admin dbAdmin &#x3D; mapper.findoneByName(admin.getAdminName());                if (dbAdmin &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F;说明用户不存在&#x2F;&#x2F;            return new JsonData(1001,&quot;用户不存在&quot;);            throw new LoginException(1001,&quot;用户不存在&quot;);        &#125;                &#x2F;&#x2F;判断状态        if(dbAdmin.getAdminStatus()!&#x3D;null &amp;&amp; !(dbAdmin.getAdminStatus().equals(0)))&#123;&#x2F;&#x2F;            return new JsonData(1001,&quot;用户被锁定,联系管理员&quot;);            throw new LoginException(1002,&quot;用户被锁定,联系管理员&quot;);        &#125;                &#x2F;&#x2F;判断密码正确        if(!dbAdmin.getAdminPwd().equals(admin.getAdminPwd()))&#123;&#x2F;&#x2F;            return new JsonData(1001,&quot;密码错误&quot;);            throw new LoginException(1003,&quot;密码错误&quot;);        &#125;        &#x2F;&#x2F;存到session        session.setAttribute(&quot;adminName&quot;,admin.getAdminName());        &#x2F;&#x2F;更新用户最后登录时间        dbAdmin.setLastLoginTime(new Timestamp(System.currentTimeMillis()));        &#x2F;&#x2F;dbAdmin没有问题        System.out.println(dbAdmin.toString());        mapper.update(dbAdmin);        return new JsonData(200,&quot;登录正常&quot;);            &#125;    @Override    public  JsonData exit(HttpServletRequest request)&#123;        request.getSession().invalidate();        return new JsonData(200,&quot;退出正常&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Spring拦截器"><a href="#Spring拦截器" class="headerlink" title="Spring拦截器"></a>Spring拦截器</h2><p>应用的例子：在用户没有登录的时候，无法进入系统中的其他页面。</p><p>原理：<br>对每一个请求进行审查，如果满足要求，则放行；不满足要求，重定向到其他页面。<br><strong>需要注意的是，要严格审查逻辑，放行登录页面和静态资源，不要产生无限循环的情况。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210605103735.png" alt="20210605103735"></p><h3 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 登录拦截器 *&#x2F;public class LoginInterceptor implements HandlerInterceptor &#123;    &#x2F;**     * 前置方法     * @param request     * @param response     * @param handler     * @return     * @throws Exception     *&#x2F;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        &#x2F;&#x2F;判断是否登录        &#x2F;&#x2F;判断session        &#x2F;&#x2F;没有登录重定向到登录页面、登录了，定向到index页面        &#x2F;&#x2F;先去获取session对象        HttpSession session &#x3D; request.getSession();        &#x2F;&#x2F;获取登录的标记        String adminName &#x3D; (String) session.getAttribute(&quot;adminName&quot;);        &#x2F;&#x2F;判断session的值是否为null        if (adminName &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F;如果没有登录，这里就产生了循环，因为默认是拦截所有请求，所以就变成了无限次的重定向，            &#x2F;&#x2F;浏览器出现了too many redirect            response.sendRedirect(&quot;&#x2F;login&#x2F;page&quot;);            return false;        &#125;        return true;&#x2F;&#x2F;false拦截、true放行    &#125;    &#x2F;**     * 后置方法     * @param request     * @param response     * @param handler     * @param modelAndView     * @throws Exception     *&#x2F;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SystemConfig implements WebMvcConfigurer &#123;    &#x2F;**     * 专门用来注册拦截器的     * @param registry     *&#x2F;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LoginInterceptor())                &#x2F;&#x2F;拦截所有的请求                .addPathPatterns(&quot;&#x2F;**&quot;)                &#x2F;&#x2F;放行方法                .excludePathPatterns(&quot;&#x2F;login&#x2F;**&quot;)                &#x2F;&#x2F;放行css                .excludePathPatterns(&quot;&#x2F;static&#x2F;**&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 国信安实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训day4</title>
      <link href="/2021/06/03/shi-xun-day4/"/>
      <url>/2021/06/03/shi-xun-day4/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#spring%E5%85%A5%E9%97%A83">Spring入门3</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-mybatis">什么是 MyBatis</a><ul><li><a href="#%E5%8E%9F%E7%90%86%E5%9B%BE">原理图</a></li><li><a href="#mtbatis%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">MtBatis进行数据查询</a></li></ul></li><li><a href="#springboot%E6%9F%A5%E6%89%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E9%A1%BA%E5%BA%8F">SpringBoot查找静态资源的顺序</a></li><li><a href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8Bvarchar%E5%92%8Cchar%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%93%AA%E7%A7%8D%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%E4%B8%BA%E4%BB%80%E4%B9%88">MySQL数据库中的字段类型varchar和char的主要区别是什么？哪种字段的查找效率要高，为什么</a></li></ul></li></ul><h1 id="Spring入门3"><a href="#Spring入门3" class="headerlink" title="Spring入门3"></a>Spring入门3</h1><p>Java体系操作数据库的框架：</p><ul><li>全ORM: Hibernate，JPA 完全隔离sql语句，不写sql即可实现相应的数据库操作。相对半ORM来说执行速度会慢一点。</li><li>半ORM：Mybatis 隔离sql和java语句，java和 sql是分开的。更适合web项目的开发</li></ul><h2 id="什么是-MyBatis"><a href="#什么是-MyBatis" class="headerlink" title="什么是 MyBatis"></a>什么是 MyBatis</h2><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210603114409.png" alt="20210603114409"></p><h3 id="MtBatis进行数据查询"><a href="#MtBatis进行数据查询" class="headerlink" title="MtBatis进行数据查询"></a>MtBatis进行数据查询</h3><ul><li>导入依赖 maven包</li><li>配置数据源 确定数据库的类型、账号、密码</li><li>Mybatis相关文件的创建</li></ul><p>1.创建实体类<br>数据库中的表 — 类<br>数据库表中的字段  — 类属性<br>数据            – 对象<br>2.创建接口 AdminMapper<br>3.创建对应的映射文件 Xml<br>4.配置mybatis 指定映射文件的位置、打印sql语句等<br>5.扫描接口  在启动类上面扫描<br>6.单元测试 去test目录下的Tests进行</p><h2 id="SpringBoot查找静态资源的顺序"><a href="#SpringBoot查找静态资源的顺序" class="headerlink" title="SpringBoot查找静态资源的顺序"></a>SpringBoot查找静态资源的顺序</h2><p>先从resources &gt; static &gt; public<br>如果在这几个文件夹中任意一个文件中找到静态资源，就不会再去其他的文件夹查找。都没有，就会直接抛出404.</p><h2 id="MySQL数据库中的字段类型varchar和char的主要区别是什么？哪种字段的查找效率要高，为什么"><a href="#MySQL数据库中的字段类型varchar和char的主要区别是什么？哪种字段的查找效率要高，为什么" class="headerlink" title="MySQL数据库中的字段类型varchar和char的主要区别是什么？哪种字段的查找效率要高，为什么"></a>MySQL数据库中的字段类型varchar和char的主要区别是什么？哪种字段的查找效率要高，为什么</h2><p><strong>区别一，定长和变长</strong><br>char 表示定长，长度固定，varchar表示变长，即长度可变，当所插入的字符串超出它们的长度时，视情况来处理，如果是严格模式，则会拒绝插入并提示错误信息，如果是宽松模式，则会截取然后插入。如果插入的字符串长度小于定义长度时，则会以不同的方式来处理，如char（10），表示存储的是10个字符，无论你插入的是多少，都是10个，如果少于10个，则用空格填满。而varchar（10），小于10个的话，则插入多少个字符就存多少个。varchar怎么知道所存储字符串的长度呢？实际上，对于varchar 字段来说，需要使用一个（如果字符串长度小于255）或两个字节（长度大于255）来存储字符串的长度。<br><strong>区别之二</strong><br>存储的容量不同对char来说，最多能存放的字符个数 255，和编码无关。而varchar呢，最多能存放 65532 个字符。VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532 字节，最大有效长度是 65532 字节，在varchar存字符串的时候，第一个字节是空的，不存任何的数据，然后还需要两个字节来存放字符串的长度。所以有效长度就是 65535 - 1 - 2= 65532</p>]]></content>
      
      
      <categories>
          
          <category> 国信安实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训day3</title>
      <link href="/2021/06/02/shi-xun-day3/"/>
      <url>/2021/06/02/shi-xun-day3/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#spring%E5%85%A5%E9%97%A82">Spring入门2</a><ul><li><a href="#mvc%E6%A8%A1%E5%BC%8Fmodeviewcontroller">MVC模式(mode\view\controller)</a><ul><li><a href="#mvc%E5%8E%9F%E7%90%86%E5%9B%BE">MVC原理图</a></li></ul></li><li><a href="#springmvc%E6%98%AF%E4%BB%80%E4%B9%88">springMVC是什么</a><ul><li><a href="#%E5%8E%9F%E7%90%86%E5%9B%BE">原理图</a></li></ul></li><li><a href="#spring-thymeleaf">spring thymeleaf</a><ul><li><a href="#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB">动静分离</a></li></ul></li><li><a href="#spring%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91">Spring接口开发</a><ul><li><a href="#%E7%B1%BB%E4%B8%8A%E7%9A%84%E6%B3%A8%E8%A7%A3">类上的注解</a></li><li><a href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E6%B3%A8%E8%A7%A3">方法上的注解</a></li><li><a href="#%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3">参数注解</a></li></ul></li></ul></li></ul><h1 id="Spring入门2"><a href="#Spring入门2" class="headerlink" title="Spring入门2"></a>Spring入门2</h1><h2 id="MVC模式-mode-view-controller"><a href="#MVC模式-mode-view-controller" class="headerlink" title="MVC模式(mode\view\controller)"></a>MVC模式(mode\view\controller)</h2><p>详见博客 <a href="https://www.cnblogs.com/xiaoxi/p/6164383.html">https://www.cnblogs.com/xiaoxi/p/6164383.html</a></p><h3 id="MVC原理图"><a href="#MVC原理图" class="headerlink" title="MVC原理图"></a>MVC原理图</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210602172050.png" alt="20210602172050"></p><p>M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）</p><p>V-View 视图（做界面的展示  jsp，html……）</p><p>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）</p><h2 id="springMVC是什么"><a href="#springMVC是什么" class="headerlink" title="springMVC是什么"></a>springMVC是什么</h2><p>　　springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210602172227.png" alt="20210602172227"></p><p>第一步:用户发起请求到前端控制器（DispatcherServlet）</p><p>第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找</p><p>第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）</p><p>第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）</p><p>第五步：处理器适配器去执行Handler</p><p>第六步：Handler执行完给处理器适配器返回ModelAndView</p><p>第七步：处理器适配器向前端控制器返回ModelAndView</p><p>第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</p><p>第九步：视图解析器像前端控制器返回View</p><p>第十步：前端控制器对视图进行渲染</p><p>第十一步：前端控制器向用户响应结果</p><h2 id="spring-thymeleaf"><a href="#spring-thymeleaf" class="headerlink" title="spring thymeleaf"></a>spring thymeleaf</h2><p>详见 <a href="https://developer.aliyun.com/article/769977">https://developer.aliyun.com/article/769977</a></p><p>模板引擎在web领域的主要作用：让网站实现界面和数据分离，这样大大提高了开发效率，让代码重用更加容易。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>对于传统jsp或者其他模板来说，没有一个模板引擎的后缀为.html，就拿jsp来说jsp的后缀为.jsp,它的本质就是将一个html文件修改后缀为.jsp，然后在这个文件中增加自己的语法、标签然后执行时候通过后台处理这个文件最终返回一个html页面。</p><p>浏览器无法直接识别.jsp文件，需要借助网络(服务端)才能进行访问；而Thymeleaf用html做模板可以直接在浏览器中打开。开发者充分考虑html页面特性，将Thymeleaf的语法通过html的标签属性来定义完成，这些标签属性不会影响html页面的完整性和显示。如果通过后台服务端访问页面服务端会寻找这些标签将服务端对应的数据替换到相应位置实现动态页面！大体区别可以参照下图</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210602173047.png" alt="20210602173047"></p><p>上图的意思就是如果直接打开这个html那么浏览器会对th等标签忽视而显示原始的内容。如果通过服务端访问那么服务端将先寻找th标签将服务端储存的数据替换到对应位置。具体效果可以参照下图,下图即为一个动静结合的实例。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210602173204.png" alt="20210602173204"></p><h2 id="Spring接口开发"><a href="#Spring接口开发" class="headerlink" title="Spring接口开发"></a>Spring接口开发</h2><p>做如下区分的目的：方便后续代码的扩展和维护</p><h3 id="类上的注解"><a href="#类上的注解" class="headerlink" title="类上的注解"></a>类上的注解</h3><p>Stererotype.Component标记Spring中普通组件<br>Stererotype.Controller 控制器<br>Stererotype.Service服务层对象、处理业务逻辑<br>Stererotype. Repository持久层对象、操作数据库<br>Web.bin.annotation.RestController web控制器，返回json数据</p><h3 id="方法上的注解"><a href="#方法上的注解" class="headerlink" title="方法上的注解"></a>方法上的注解</h3><p>@RequsetMapping 路由控制返回数据<br>@GetMapping get请求获取用户数据<br>@PostMapping 获取数据<br>@PutMapping 更新数据<br>@DeleteMapping 删除数据</p><h3 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h3><p>@RequestParam required参数是否必传、name别名(前端看到的)、defaultValue:默认值 (这个name很奇怪，不知道怎么用的)</p>]]></content>
      
      
      <categories>
          
          <category> 国信安实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/01/hello-world/"/>
      <url>/2021/06/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实训day1-day2</title>
      <link href="/2021/06/01/shi-xun-day1-day2/"/>
      <url>/2021/06/01/shi-xun-day1-day2/</url>
      
        <content type="html"><![CDATA[<h1 id="实训day1-day2"><a href="#实训day1-day2" class="headerlink" title="实训day1-day2"></a>实训day1-day2</h1><p>目录:</p><ul><li><a href="#%E5%AE%9E%E8%AE%ADday1-day2">实训day1-day2</a><ul><li><a href="#git%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8">git工具的使用</a><ul><li><a href="#%E5%85%B3%E4%BA%8Egit%E7%9A%84%E5%8E%9F%E7%90%86">关于git的原理</a></li><li><a href="#git-%E5%B7%A5%E4%BD%9C%E6%B5%81">git 工作流</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8push%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8Cpull">为什么在<code>push</code>之前需要进行<code>pull</code></a></li><li><a href="#git%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81">git处理冲突</a></li></ul></li><li><a href="#spring%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8">spring项目入门</a><ul><li><a href="#java%E5%8F%8D%E5%B0%84">java反射</a></li><li><a href="#%E6%80%9D%E8%80%83">思考</a><ul><li><a href="#spring-ioc">Spring IOC</a></li><li><a href="#spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di">Spring 依赖注入DI</a></li></ul></li></ul></li></ul></li></ul><h2 id="git工具的使用"><a href="#git工具的使用" class="headerlink" title="git工具的使用"></a>git工具的使用</h2><h3 id="关于git的原理"><a href="#关于git的原理" class="headerlink" title="关于git的原理"></a>关于git的原理</h3><p>找到了一篇博客对于git的原理以及存储讲解的非常清楚</p><p><a href="https://zhaohuabing.com/post/2019-01-21-git/">https://zhaohuabing.com/post/2019-01-21-git/</a></p><h3 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h3><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210601113100.png" alt="20210601113100"></p><h3 id="为什么在push之前需要进行pull"><a href="#为什么在push之前需要进行pull" class="headerlink" title="为什么在push之前需要进行pull"></a>为什么在<code>push</code>之前需要进行<code>pull</code></h3><p>如果项目只有一个人，那无所谓。但是一般情况下，项目中都会有许多项目成员，在我们将自己的<code>分支 1</code> 合并到 <code>主分支 master</code>时，<code>主分支master</code>有可能已经发生改变(即成员2将自己的<code>分支2</code>合并到<code>主分支 master</code>之后<code>push</code>),此时如果直接<code>push</code>，会导致成员2所修改的部分被覆盖。</p><p>而在这之前进行<code>pull</code>操作，会把远程分支于本地分支进行合并。然后再进行<code>push</code></p><p>git可能会在这种情况下，禁止你进行push操作</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210601113613.png" alt="20210601113613"></p><h3 id="git处理冲突"><a href="#git处理冲突" class="headerlink" title="git处理冲突"></a>git处理冲突</h3><p>git并不能智能化地解决不同开发者修改同一个文件的情况。如果不同开发者对同一文件进行了修改，那么这个冲突的过程，必须要手动解决，然后再次提交。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210601114236.png" alt="20210601114236"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210601114412.png" alt="20210601114412"></p><p>日志</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210601114336.png" alt="20210601114336"></p><h2 id="spring项目入门"><a href="#spring项目入门" class="headerlink" title="spring项目入门"></a>spring项目入门</h2><p>  基础的创建项目+运行web项目 没什么可以说的</p><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>具体去看博客:<a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a></p><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong><br>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Apple apple &#x3D; new Apple(); &#x2F;&#x2F;直接初始化，「正射」apple.setPrice(4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。<br>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class clz &#x3D; Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);Method method &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);Constructor constructor &#x3D; clz.getConstructor();Object object &#x3D; constructor.newInstance();method.invoke(object, 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么在浏览器中输入<a href="http://localhost:8080/index%E5%B0%B1%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84IndexController%E4%B8%AD%E7%9A%84index%E6%96%B9%E6%B3%95%EF%BC%9F">http://localhost:8080/index就能够访问到对应的IndexController中的index方法？</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerpublic class IndexController &#123;    @RequestMapping(&quot;&#x2F;index&quot;)    public String index()&#123;        return &quot;Lakers win&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来说，就是在运行时，浏览器通过获取<code>/index</code>找到了IndexController这个类（可能是Spring容器在启动之前或者之后创建好的），然后调用方法index，向前端返回 Lakers win</p><h4 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h4><p>详见博客：<a href="https://www.cnblogs.com/ysocean/p/7466217.html">https://www.cnblogs.com/ysocean/p/7466217.html</a></p><p>IOC-Inversion of Control，即控制反转。它不是什么技术，而是一种设计思想。</p><p>&emsp;&emsp;传统的创建对象的方法是直接通过 new 关键字，而 spring 则是通过 IOC 容器来创建对象，也就是说我们将创建对象的控制权交给了 IOC 容器。我们可以用一句话来概括 IOC：</p><p>&emsp;&emsp;IOC 让程序员不在关注怎么去创建对象，而是关注与对象创建之后的操作，把对象的创建、初始化、销毁等工作交给spring容器来做。</p><p>项目加载时会扫描有注解<code>@RestController、@Controller、@Service、@Component</code>的类，通过反射创建这些类的对象放入Spring的容器 **(hashMap:key =》value —–indexController 名字 =》indexController的对象)**，需要使用的时候通过key直接取出来使用。</p><h4 id="Spring-依赖注入DI"><a href="#Spring-依赖注入DI" class="headerlink" title="Spring 依赖注入DI"></a>Spring 依赖注入DI</h4><p>详见：<a href="http://c.biancheng.net/view/4253.html">http://c.biancheng.net/view/4253.html</a></p><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p><p>当某个 Java 实例需要另一个 Java 实例时，传统的方法是由调用者创建被调用者的实例（例如，使用 new 关键字获得被调用者实例），而使用 Spring 框架后，被调用者的实例不再由调用者创建，而是由 Spring 容器创建，这称为控制反转。</p><p>Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。</p><p>依赖注入主要有两种实现方式，分别是属性 setter 注入和构造方法注入。</p>]]></content>
      
      
      <categories>
          
          <category> 国信安实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>篮球比赛数据统计</title>
      <link href="/2021/05/28/lan-qiu-bi-sai-shu-ju-tong-ji/"/>
      <url>/2021/05/28/lan-qiu-bi-sai-shu-ju-tong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><table><thead><tr><th>日期</th><th>比赛名称</th><th>得分</th></tr></thead><tbody><tr><td>2019.5.中旬</td><td>学院院内赛-基准方中篮球赛(学院内不同年级组成的队伍)</td><td>具体数据忘了，但是场均应该能有个六七分，一共打了三场，大一非土木</td></tr><tr><td>2019.4.19</td><td>学工部篮球赛</td><td>17分、九投八中、一个三分、一个二加一</td></tr><tr><td>2021.5.9</td><td>Scuba(学校各个学院之间比赛)</td><td>对阵外国语 只得3分 三分六投一中，两个失误</td></tr><tr><td>2021.5.22</td><td>Scuba</td><td>对阵商学院、0分、两个失误</td></tr><tr><td>2021.5.28</td><td>Scuba</td><td>对阵软件 10分、五次启动走步、0助攻、中投3中2、两个上篮、一个二加一</td></tr></tbody></table><h1 id="记录没有别的目的，一方面是留念，但更多地是激励，希望自己能永远对🏀充满热情。—-2021-5-28"><a href="#记录没有别的目的，一方面是留念，但更多地是激励，希望自己能永远对🏀充满热情。—-2021-5-28" class="headerlink" title="记录没有别的目的，一方面是留念，但更多地是激励，希望自己能永远对🏀充满热情。—-2021.5.28"></a>记录没有别的目的，一方面是留念，但更多地是激励，希望自己能永远对🏀充满热情。—-2021.5.28</h1>]]></content>
      
      
      <categories>
          
          <category> 数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grafana iframe嵌入不显示的问题</title>
      <link href="/2021/05/26/grafana-iframe-qian-ru-bu-xian-shi-de-wen-ti/"/>
      <url>/2021/05/26/grafana-iframe-qian-ru-bu-xian-shi-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="grafana-iframe嵌入不显示的问题"><a href="#grafana-iframe嵌入不显示的问题" class="headerlink" title="grafana iframe嵌入不显示的问题"></a>grafana iframe嵌入不显示的问题</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><code>grafana\grafana\conf</code>目录下有两个配置文件<code>defaults.ini</code>、<code>sample.ini</code></p><ul><li><code>defaults.ini</code> 这个才是grafana服务器真正运行时的配置文件</li><li><code>sample.ini</code> 只是个样例，别改错了</li></ul><h2 id="开启匿名登录"><a href="#开启匿名登录" class="headerlink" title="开启匿名登录"></a>开启匿名登录</h2><p>修改<code>grafana\grafana\conf</code>目录下的<code>defaults.ini</code>文件中的 <code>[auth.anonymous]中的enabled = true</code></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528084634.png" alt="20210528084634"></p><h2 id="允许浏览器渲染iframe"><a href="#允许浏览器渲染iframe" class="headerlink" title="允许浏览器渲染iframe"></a>允许浏览器渲染iframe</h2><p>修改上述文件中的<code>allow_embedding = true</code></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528085103.png" alt="20210528085103"></p><h1 id="windows-server重启grafana服务"><a href="#windows-server重启grafana服务" class="headerlink" title="windows server重启grafana服务"></a>windows server重启grafana服务</h1><p>由于grafana在运行之后已经被当作一个服务，可以在服务管理页面对其进行重启</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528085716.png" alt="20210528085716"></p><h1 id="不显示的原因"><a href="#不显示的原因" class="headerlink" title="不显示的原因"></a>不显示的原因</h1><p>grafana服务器响应头里面有一个<code>X-Frame-Options:deny</code></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528085945.png" alt="20210528085945"></p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p>The X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 <code>&lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 或者 &lt;object&gt;</code> 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 clickjacking 攻击。</p><p>有三个可能值</p><pre class="line-numbers language-none"><code class="language-none">X-Frame-Options: denyX-Frame-Options: sameoriginX-Frame-Options: allow-from https:&#x2F;&#x2F;example.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果设置为 deny，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为sameorigin，那么页面就可以在同域名页面的 frame 中嵌套。</p><ul><li>deny <br><br>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li><li>sameorigin <br><br>表示该页面可以在相同域名页面的 frame 中展示。</li><li>allow-from url <br><br>表示该页面可以在指定来源的 frame 中展示。</li></ul><h2 id="修改之后，grafana服务器的响应头里不再包含这个字段"><a href="#修改之后，grafana服务器的响应头里不再包含这个字段" class="headerlink" title="修改之后，grafana服务器的响应头里不再包含这个字段"></a>修改之后，grafana服务器的响应头里不再包含这个字段</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528091108.png" alt="20210528091108"><br>就可以显示了<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210528091142.png" alt="20210528091142"></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用github托管网页，用到的工具总结</title>
      <link href="/2021/05/26/li-yong-github-tuo-guan-wang-ye-yong-dao-de-gong-ju-zong-lan/"/>
      <url>/2021/05/26/li-yong-github-tuo-guan-wang-ye-yong-dao-de-gong-ju-zong-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h2><ul><li><input checked="" disabled="" type="checkbox"> 更改网页中js文件的cdn路径</li><li><input checked="" disabled="" type="checkbox"> 添加头像或者壁纸，看看作者的标语和文字是如何切换的</li><li><input disabled="" type="checkbox"> 想办法关一下背景音乐</li><li><input disabled="" type="checkbox"> 分析原因Travis 中运行hexo deloy总是<code>remote: Invalid username or password.fatal: Authentication failed fo</code></li><li><input checked="" disabled="" type="checkbox"> 续费腾讯的对象存储cos，方便传输图片</li><li><input disabled="" type="checkbox"> 将csdn上面的文件转过来</li></ul><h2 id="每一部分的作用详见首页-文章-Hexo主题LiveForCode介绍"><a href="#每一部分的作用详见首页-文章-Hexo主题LiveForCode介绍" class="headerlink" title="每一部分的作用详见首页 文章 Hexo主题LiveForCode介绍"></a>每一部分的作用详见首页 文章 Hexo主题LiveForCode介绍</h2><ul><li>Travis 就是方便部署hexo博客，不用每次自己在本地运行hexo deploy在上传GitHub, 检测到设定分支有push操作后，Travis会启动虚拟机帮你完成hexo generate和deploy的操作。关于这部分的配置参数，可以参考main分支的.travis.yml文件</li><li>LeanCloud 通过api把评论、留言、文章数据统计放到数据库里面，进入博客的时候，会再次请求数据库把这些数据显示在网页上。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210527113453.png" alt="20210527113453"></li><li>Algolia 搜索操作，会统计博客文章的标题和url相对路径。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210527113220.png" alt="20210527113220"></li><li>jsDelivr 免费的cdn加速。</li></ul><h2 id="利用github托管网页，用到的工具总结"><a href="#利用github托管网页，用到的工具总结" class="headerlink" title="利用github托管网页，用到的工具总结"></a>利用github托管网页，用到的工具总结</h2><h3 id="Hexo-博客框架"><a href="#Hexo-博客框架" class="headerlink" title="Hexo(博客框架)"></a>Hexo(博客框架)</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="Travis-CI-方便对博客更改，自动渲染"><a href="#Travis-CI-方便对博客更改，自动渲染" class="headerlink" title="Travis CI(方便对博客更改，自动渲染)"></a>Travis CI(方便对博客更改，自动渲染)</h3><p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p><p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码”集成”到主干。</p><p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p><h3 id="Valine-一款快速、简洁且高效的无后端评论系统。"><a href="#Valine-一款快速、简洁且高效的无后端评论系统。" class="headerlink" title="Valine - 一款快速、简洁且高效的无后端评论系统。"></a>Valine - 一款快速、简洁且高效的无后端评论系统。</h3><p>Valine 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。</p><p>理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。</p><h3 id="LeanCloud-（数据库-—评论、留言、文章数据统计"><a href="#LeanCloud-（数据库-—评论、留言、文章数据统计" class="headerlink" title="LeanCloud （数据库)—评论、留言、文章数据统计"></a>LeanCloud （数据库)—评论、留言、文章数据统计</h3><p>LeanCloud（原 AVOS Cloud） 是针对移动应用的一站式云端服务，专注于为应用开发者提供工具和平台。提供包括LeanStorage 数据存储、LeanMessage 通信服务、LeanAnalytics 统计分析、LeanModules 拓展模块等四大类型的后端云服务，加速应用开发。</p><h3 id="Algolia-Search-数据库-–文章标签、分类统计"><a href="#Algolia-Search-数据库-–文章标签、分类统计" class="headerlink" title="Algolia Search(数据库)–文章标签、分类统计"></a>Algolia Search(数据库)–文章标签、分类统计</h3><p>可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有 10,000 条记录，每月有 100,000 的可以操作数</p><h3 id="jsDelivr–js文件的cdn-free"><a href="#jsDelivr–js文件的cdn-free" class="headerlink" title="jsDelivr–js文件的cdn free"></a>jsDelivr–js文件的cdn free</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p>]]></content>
      
      
      <categories>
          
          <category> 待办 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题LiveForCode介绍</title>
      <link href="/2020/08/01/hexo-zhu-ti-liveforcode-jie-shao/"/>
      <url>/2020/08/01/hexo-zhu-ti-liveforcode-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a> 是高效的静态站点生成框架，他基于 <a href="https://nodejs.org/en/">Node.js</a>。通过 Hexo 你可以轻松地使用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a> 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html">标签插件</a> 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。  </p><blockquote><p>你可以访问 <a href="https://hexo.io/zh-cn/docs/">Hexo 的文档</a> 了解如何安装 Hexo  </p></blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。其中，一份位于 Hexo 根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong> ， 后者称为 <strong>主题配置文件</strong> 。  </p><h2 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h2><p><a href="https://www.notes.worstone.cn/">Hexo - Live For Code</a>  </p><h2 id="安装Live-For-Code"><a href="#安装Live-For-Code" class="headerlink" title="安装Live For Code"></a>安装Live For Code</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至 Hexo 根目录的 themes 目录下，然后修改下配置文件即可。具体到 LiveForCode 来说，安装步骤如下。  </p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>如果你熟悉 Git，建议你使用 <code>克隆最新版本</code> 的方式，之后的更新可以通过 <code>git pull</code> 来快速更新，而不用再次下载压缩包替换。  </p><ol><li><p>克隆最新版本<br>在终端窗口下，定位到 Hexo 站点目录下。使用 Git Checkout 代码：  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd your-hexo-sitegit clone https:&#x2F;&#x2F;github.com&#x2F;first19326&#x2F;hexo-liveforcode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将克隆下来的文件夹中的 <code>LiveForCode</code> 文件夹移动至站点的 <code>themes</code> 目录下，并将 <code>source</code> 文件夹中的 <code>about</code>、<code>category</code>、<code>comment</code>、<code>donate</code>、<code>friend</code> 以及 <code>tag</code> 文件夹移动至 Hexo 站点目录下的 <code>source</code> 文件夹中。这些文件夹分别对应着 <strong>关于</strong> 、 <strong>标签</strong> 、 <strong>留言板</strong> 、 <strong>赞赏</strong> 、 <strong>友情链接</strong> 以及 <strong>分类</strong> 页面，其中的 <code>index.md</code> 中的内容为各个页面显示的内容，大家可以根据自己的情况进行修改。  </p></li><li><p>下载稳定版本<br>前往 LiveForCode 版本发布页面。<br>选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。<br>解压所下载的压缩包，并将解压后的文件夹中的 <code>LiveForCode</code> 文件夹移动至站点的 <code>themes</code> 目录下，并将 <code>source</code> 文件夹中的 <code>about</code>、<code>category</code>、<code>comment</code>、<code>donate</code>、<code>friend</code> 以及 <code>tag</code> 文件夹移动至 Hexo 站点目录下的 <code>source</code> 文件夹中。这些文件夹分别对应着 <strong>关于</strong> 、 <strong>标签</strong> 、 <strong>留言板</strong> 、 <strong>赞赏</strong> 、 <strong>友情链接</strong> 以及 <strong>分类</strong> 页面，其中的 <code>index.md</code> 中的内容为各个页面显示的内容，大家可以根据自己的情况进行修改。  </p></li></ol><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。当 克隆/下载 完成后，打开 <strong>站点配置文件</strong> ，找到 theme 字段，并将其值更改为 <code>LiveForCode</code>。  </p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">theme: LiveForCode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。  </p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。<br>当命令行输出中提示出： <code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code> 此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。  </p><h2 id="站点设定"><a href="#站点设定" class="headerlink" title="站点设定"></a>站点设定</h2><p>在 <strong>站点配置文件</strong> 中，我修改了标签归档页面、分类归档页面以及文章归档页面的路径，如果大家使用默认的路径，则需要修改 <strong>主题配置文件</strong> 中的菜单设置。  </p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">tag_dir: tagarchive_dir: archivecategory_dir: category<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h2><p>由于 <strong>主题配置文件</strong> 可能有所改动，就不在这里给大家详细说明，我会在 <strong>主题配置文件</strong> 中添加适当的注释，麻烦大家参考页面以及注释内容进行修改。  </p><h2 id="404-页面设定"><a href="#404-页面设定" class="headerlink" title="404 页面设定"></a>404 页面设定</h2><p>主题中有相应的 <code>404</code> 错误页面，是单独的静态页面，没有添加到模板中。在使用主题的时候，需要大家将其中的 <strong>返回首页</strong> 的跳转链接 <code>https://notes.worstone.cn</code> 替换为自己网站的地址。<br>404 错误页面在主题文件夹 <code>LiveForCode</code> 中的 <code>source</code> 文件夹中。  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>buttons<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:;<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>刷新页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://notes.worstone.cn<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_self<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>返回首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><h3 id="Algolia-Search"><a href="#Algolia-Search" class="headerlink" title="Algolia Search"></a>Algolia Search</h3><p>1.前往 <a href="https://www.algolia.com/">Algolia</a> 注册页面，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。<br>2.Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 <code>Hexo Algolia</code> 扩展，这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save hexo-algolia<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.编辑 <strong>站点配置文件</strong> ，新增以下配置：  </p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">algolia:  applicationID: &#39;applicationID&#39;  apiKey: &#39;apiKey&#39;  indexName: &#39;...&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：这里的 applicationID 为 <code>Search-Only API Key</code><br>4.当配置完成，在站点根目录下执行一下命令更新 Index。请注意观察命令的输出。  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export HEXO_ALGOLIA_INDEXING_KEY&#x3D;Admin API Keyhexo algolia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5.Hexo Algolia 命令设置选项  </p><pre class="line-numbers language-none"><code class="language-none">Options:  --dry-run       Does not push content to Algolia (default: false).  --flush         Resets the Algolia index before starting the indexation (default: false).  --indexing-key  An algolia API key with add&#x2F;delete records permissions.              It should be different than the search-only API key configured in _config.yml.  --layouts       A comma-separated list of page layouts to index (default: &quot;page&quot;).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<br><code>--flush</code> 如果是 <code>false</code> 则每一次都会直接添加内容到 Algolia 相关的 Index 中，如果不是第一次提交，则将其设置为 <code>true</code><br><code>--layouts</code> 如果使用默认设置，提交的时候会将分类归档、标签归档、赞赏、留言板等页面内容提交到 Algolia， 在搜索的时候，将会搜索到分类归档、标签归档、赞赏、留言板等页面内容，建议使用时将其设置为 <code>post</code>。  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo algolia --flush true --layouts post<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置-RSS"><a href="#设置-RSS" class="headerlink" title="设置 RSS"></a>设置 RSS</h3><p>1.安装 <code>Hexo-Feed</code> 插件。前往站点根目录，执行命令安装：  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install --save hexo-generator-feed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.根据个人需求，编辑 <strong>站点配置文件</strong> ：  </p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">feed:  type: atom  path: atom.xml  limit: 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文章数据统计"><a href="#文章数据统计" class="headerlink" title="文章数据统计"></a>文章数据统计</h3><p>文章数据统计基于 <code>Valine.js</code> 插件实现。<br>实现方式：在文章列表页面加载 <code>Valine.js</code>， 只要 Valine 配置项中的 <code>el</code> 元素不存在即不会加载评论框相关内容。  </p><p>1.文章评论数统计<br>Valine 会自动查找页面中 class 值为 <code>valine-comment-count</code> 的元素，获取其 <code>data-xid</code> 为查询条件。并将得到的值填充到其 class 的值为 <code>valine-comment-count</code> 的元素里：  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- data-xid 将作为查询条件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>valine-comment-count<span class="token punctuation">"</span></span> <span class="token attr-name">data-xid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;Your/Path/Name><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.文章阅读量统计<br>Valine 从 <code>v1.2.0</code> 开始支持文章阅读量统计。  </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Valine</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    el<span class="token operator">:</span> <span class="token string">'#vcomments'</span><span class="token punctuation">,</span>    <span class="token operator">...</span>    visitor<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 阅读量统计</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果开启了阅读量统计，Valine 会自动检测 LeanCloud 应用中是否存在 <code>Counter</code> 类，如果不存在会自动创建，无需手动创建。<br>Valine 会自动查找页面中 class 值为 <code>leancloud_visitors</code> 的元素，获取其 <code>id</code> 为查询条件。并将得到的值填充到其 class 的值为 <code>leancloud-visitors-count</code> 的子元素里：  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- id 将作为查询条件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;Your/Path/Name><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>leancloud_visitors<span class="token punctuation">"</span></span> <span class="token attr-name">data-flag-title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Your Article Title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>leancloud-visitors-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="评论列表"><a href="#评论列表" class="headerlink" title="评论列表"></a>评论列表</h3><p>评论功能使用的是 <code>Valine.js</code> 插件，配置详情请参见 <a href="https://valine.js.org/">Valine</a>。  </p><blockquote><p>特别说明 <strong>主题配置文件</strong> 中的 Valine 的 <code>appId</code> 与 <code>appKey</code> 请大家自行配置自己的参数。如果评论数据提交到我的 LeanCloud 工作空间，我并不能保证数据的完整性。  </p></blockquote><h3 id="赞赏页面"><a href="#赞赏页面" class="headerlink" title="赞赏页面"></a>赞赏页面</h3><p>赞赏页面使用了 <a href="https://github.com/Kaiyuan/sponsor-page">Sponsor Page</a>，并做了相关修改使其适应博客样式。感兴趣的小伙伴自行去了解吧。  </p><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><p>音乐播放器功能是使用 <code>APlayer.js</code> 以及 <code>Meting.js</code> 实现，配置详情参见 <a href="https://aplayer.js.org/#/home">APlayer</a>、<a href="https://github.com/metowolf/MetingJS">Meting</a>。<br>主题中有两种实现方式，一种是 <code>APlayer.js</code> 结合 <code>Meting.js</code> 的实现方式，另外一种是 <code>APlayer.js</code> 单独的实现方式，两种实现方式各有优缺点：<br>第一种实现方式配置简单，并且可以从各个音乐平台解析音乐。由于是从各个平台解析，故而不是特别稳定，并且在 <code>IE</code> 浏览器中需要特殊设置。<br>第二种实现方式配置相对复杂，需要单独提供音乐相关信息，但是十分稳定，且对于 <code>IE</code> 浏览器也可兼容，无需特殊配置。<br>主题中默认以 <strong>第一种实现方式</strong> 实现，第二种实现方式为备选方案，在第一种实现方式出现问题的时候，可以切换到第二种实现方式，保证网站的稳定运行。<br>针对第二种实现方式需要 <strong>注意</strong> 的地方：<br><code>APlayer.js</code> 是基于 <code>HTML 5 Audio</code> 实现的一款音乐播放器插件，故而支持的音频格式有限，包括：<code>MP3</code>、<code>Wav</code> 以及 <code>Ogg</code> 格式，并且不同浏览器对这三种音频格式的支持也各有不同，详细信息大家参考 <a href="https://www.runoob.com/html/html5-audio.html">HTML5 Audio(音频)</a>。如果音频格式不支持，可以通过音频转换工具进行格式转换。<br><code>APlayer.js</code> 是通过 <code>XMLHttpRequest</code> 获取歌词文件，所以存在 <strong>跨域</strong> 问题。可以考虑将歌词文件放在主题文件夹 <code>LiveForCode</code> 的 <code>source</code> 文件夹下（ <strong>注意</strong> ：这里的 <code>source</code> 文件夹不是 <code>Hexo</code> 站点目录下的 <code>source</code> 文件夹），解决跨域的问题。由于 <code>jsDelivr</code> 在响应请求的时候，会添加 <code>access-control-allow-origin: *</code> 的响应标头信息，故而不存在跨域问题，也可以使用这种方式。不过需要注意的是，<code>jsDelivr</code> 对资源的大小有所限制，不可以超过 <strong>50M</strong> 。<br><code>APlayer.js</code> 获取到歌词后会将歌词中的空白行去掉，由于是单行显示歌词，所以有译文的双行歌词，只会显示下面一行歌词，可以将译文歌词拼接在歌词原文的后面解决这个问题。  </p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="关于-jQuery-版本"><a href="#关于-jQuery-版本" class="headerlink" title="关于 jQuery 版本"></a>关于 jQuery 版本</h3><p>mCustomScroll 目前暂不支持 <code>jQuery3.5</code> 以及以上版本，否则会导致代码块中的滚动条失效。  </p><h3 id="Position-fixed-定位问题"><a href="#Position-fixed-定位问题" class="headerlink" title="Position: fixed 定位问题"></a>Position: fixed 定位问题</h3><p>由于背景动画的 <code>z-index</code> 为 <code>-1</code>，导致在IE浏览器中，菜单等多处 <code>position: fixed</code> 样式的部件出现闪烁抖动的问题，所以默认在IE浏览器中关闭了背景动画。如果是高版本IE，例如IE11则可在设置 -&gt; Internet选项 -&gt; 高级，将浏览中的’使用平滑滚动’选项勾掉，也可以解决这个问题。  </p><h3 id="关于-Github-Page-的使用"><a href="#关于-Github-Page-的使用" class="headerlink" title="关于 Github Page 的使用"></a>关于 Github Page 的使用</h3><p>详情请参见 <a href="https://hexo.io/zh-cn/docs/github-pages">将 Hexo 部署到 GitHub Pages</a>。<br>Github Page 支持设置自己的域名，建议在 Hexo 主题的 source 文件夹下新增一个 CNAME 的文件，将自己的域名配置进去，否则每次提交的时候会覆盖掉相关域名设置。<br>在域名的解析设置中，可以使用 CNAME 解析方式，也可以使用 A记录 的方式。如果是 A记录 的方式，则需要检索当前 Github Page 对应的服务器 IP 地址。  </p><h3 id="关于-CDN"><a href="#关于-CDN" class="headerlink" title="关于 CDN"></a>关于 CDN</h3><p>CDN 可以在阿里云购买相关的 CDN 服务器，效果肯定是更好，这里使用的是 <a href="https://www.jsdelivr.com/">jsDelivr</a> 免费的 CDN 加速服务。但是有一个弊端，如果修改代码的时候没有Github的相关版本信息，则很容易读取到 jsDelivr 的缓存数据，而不是修改后的最新代码。至于这个缓存时间，我也拿捏不准。不过免费而且效果不错的东西，大家就不要要求太多了。  </p><h2 id="阶段计划"><a href="#阶段计划" class="headerlink" title="阶段计划"></a>阶段计划</h2><p>1.使用 Vue.js 重构项目<br>2.整理模板的样式文件<br>3.加入 Pjax，优化页面加载速度<br>4.补充国际化支持语言<br>5.考虑是否加入黑夜模式  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于我还是一名小白，可能还有很多问题无法解决，这个主题也可能存在很多不尽如人意的地方，在细节方面我也会尽力地去修改，也欢迎大家提出自己的问题，以及主题的相关建议，也欢迎大家提交代码。如果觉得这个主题不错，欢迎大家去使用。当然了，如果能赞赏我一下，我也是不介意的。(●ˇ∀ˇ●)  </p><p>这个主题可定制的地方目前可能比较少，欢迎大家修改，也希望这个主题能够越来越好看，也希望越来越多的人能够喜欢。  </p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/01/helloworld/"/>
      <url>/2020/01/01/helloworld/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
