<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  <subtitle>永远热爱生活</subtitle>
  <link href="https://laobameishijia.github.io/atom.xml" rel="self"/>
  
  <link href="https://laobameishijia.github.io/"/>
  <updated>2021-09-30T06:52:32.029Z</updated>
  <id>https://laobameishijia.github.io/</id>
  
  <author>
    <name>老叭美食家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构--线性表</title>
    <link href="https://laobameishijia.github.io/2021/07/02/shu-ju-jie-gou-xian-xing-biao-1/"/>
    <id>https://laobameishijia.github.io/2021/07/02/shu-ju-jie-gou-xian-xing-biao-1/</id>
    <published>2021-07-02T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>直接放代码了，题目就是王道2022线性表那节的题目。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 线性表.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span><span class="token comment" spellcheck="true">//</span><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"># <span class="token directive keyword">define</span> LIST_INIT_SIZE 100 </span><span class="token comment" spellcheck="true">// 线性表存储空间的初始分配量</span><span class="token macro property"># <span class="token directive keyword">define</span> LISTINCREMENT 10</span><span class="token comment" spellcheck="true">//线性表存储空间的分配增量</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> elem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存储空间基址</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前长度</span>    <span class="token keyword">int</span> listsize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前分配的存储容量(以sizeof(int)为单位)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>SqList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    初始化创建*/</span>bool <span class="token function">InitList_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>LIST_INIT_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> LIST_INIT_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>listsize <span class="token operator">=</span> LIST_INIT_SIZE<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ListPrint_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token function">printf_s</span><span class="token punctuation">(</span><span class="token string">"该顺序表为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf_s</span><span class="token punctuation">(</span><span class="token string">"%d->"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf_s</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    在固定位置插入元素*/</span>bool <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在顺序线性表L中第i个位置之前插入新的元素e</span>    <span class="token comment" spellcheck="true">//i的合法值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> i<span class="token operator">></span>L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">></span> L<span class="token punctuation">.</span>listsize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前存储空间已满，增加分配</span>        <span class="token keyword">int</span><span class="token operator">*</span> newbase <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>listsize <span class="token operator">+</span> LISTINCREMENT<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newbase<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>elem <span class="token operator">=</span> newbase<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新基址</span>        L<span class="token punctuation">.</span>listsize  <span class="token operator">=</span> L<span class="token punctuation">.</span>listsize <span class="token operator">+</span> LISTINCREMENT<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//q为插入位置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> q<span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>        <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入位置的元素后移</span>    <span class="token operator">*</span>q <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token operator">++</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    删除固定位置的元素*/</span>bool <span class="token function">ListDelete_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在顺序线性表L中删除第i个元素，并用e返回值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> i<span class="token operator">></span>L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//被删除元素的位置</span>    e <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> q <span class="token operator">=</span> L<span class="token punctuation">.</span>elem <span class="token operator">+</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token operator">++</span>p<span class="token punctuation">;</span> p <span class="token operator">&lt;=</span> q<span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//被删除元素之后的元素左移</span>    <span class="token operator">--</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    删除顺序表中最小的元素 √*/</span>bool <span class="token function">ListDeleteMin_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span> <span class="token operator">||</span> L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token function">printf_s</span><span class="token punctuation">(</span><span class="token string">"长度为零"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> q <span class="token operator">=</span> L<span class="token punctuation">.</span>elem <span class="token operator">+</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> tag <span class="token operator">=</span> L<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">&lt;=</span> q<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">&lt;</span> <span class="token operator">*</span>tag<span class="token punctuation">)</span> tag <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    e <span class="token operator">=</span> <span class="token operator">*</span>tag<span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    顺序表逆置 √*/</span>bool <span class="token function">ListReverse_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> temp<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++不允许空指针，定义只是定义int*,定义了并没有实际的指向。习惯上一定要进行初始指针的初始化操作。</span>    temp <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//也或者在这里直接用int类型的test即可。</span>    <span class="token keyword">int</span> test<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token punctuation">.</span>length<span class="token operator">/</span> <span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">;</span>        q <span class="token operator">=</span> L<span class="token punctuation">.</span>elem <span class="token operator">+</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>        test <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>        <span class="token operator">*</span>q <span class="token operator">=</span> test<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    删除顺序表中所有值为x的元素 √     ----无论是有序表还是无序表用这个都行，有序表可以先找到所有的元素，然后一起移动，但是从时间复杂度上面来讲是一样的    从逻辑上讲，2这个值的确被删除了    但是从存储的结构上讲，2这个值还在存储空间里，只不过在逻辑上，这个位置已经是不合法的了。(改变了顺序表的长度)*/</span>bool <span class="token function">ListDeleValue</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    删除值在s和t之间的节点 √    跟上面的方法很像了*/</span>bool <span class="token function">ListDeleValueBetween</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf_s</span><span class="token punctuation">(</span><span class="token string">"请检查参数设置\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;</span>s <span class="token operator">||</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    删除有序线性表中所有的重复值*/</span>bool <span class="token function">ListDeleteDuplicateValueInOrder</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    SqList test<span class="token punctuation">;</span>    <span class="token function">InitList_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//测试删除最小的元素</span>    <span class="token comment" spellcheck="true">//int tag;</span>    <span class="token comment" spellcheck="true">//ListDeleteMin_Sq(test, tag);</span>    <span class="token comment" spellcheck="true">//printf_s("%d", tag);</span>    <span class="token comment" spellcheck="true">//测试元素逆序</span>    <span class="token comment" spellcheck="true">//ListReverse_Sq(test);</span>    <span class="token comment" spellcheck="true">//ListPrint_Sq(test);</span>    <span class="token comment" spellcheck="true">//测试删除所有值为x的元素</span>    <span class="token comment" spellcheck="true">//ListDeleValue(test, 2);</span>    <span class="token comment" spellcheck="true">//ListPrint_Sq(test);</span>    <span class="token comment" spellcheck="true">//测试删除区间内的值</span>    <span class="token comment" spellcheck="true">//ListDeleValueBetween(test,2, 5);</span>    <span class="token comment" spellcheck="true">//ListPrint_Sq(test);</span>    <span class="token comment" spellcheck="true">//测试删除有序表中的重复值</span>    <span class="token function">ListDeleteDuplicateValueInOrder</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ListPrint_Sq</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单</span><span class="token comment" spellcheck="true">// 调试程序: F5 或调试 >“开始调试”菜单</span><span class="token comment" spellcheck="true">// 入门使用技巧: </span><span class="token comment" spellcheck="true">//   1. 使用解决方案资源管理器窗口添加/管理文件</span><span class="token comment" spellcheck="true">//   2. 使用团队资源管理器窗口连接到源代码管理</span><span class="token comment" spellcheck="true">//   3. 使用输出窗口查看生成输出和其他消息</span><span class="token comment" spellcheck="true">//   4. 使用错误列表窗口查看错误</span><span class="token comment" spellcheck="true">//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目</span><span class="token comment" spellcheck="true">//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件</span></code></pre>]]></content>
    
    
    <summary type="html">线性表之顺序表手敲代码</summary>
    
    
    
    <category term="数据结构" scheme="https://laobameishijia.github.io/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="考研" scheme="https://laobameishijia.github.io/tag/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>斐波拉契数列时间复杂度分析</title>
    <link href="https://laobameishijia.github.io/2021/06/30/fei-bo-la-qi-shu-lie-shi-jian-fu-za-du-fen-xi/"/>
    <id>https://laobameishijia.github.io/2021/06/30/fei-bo-la-qi-shu-lie-shi-jian-fu-za-du-fen-xi/</id>
    <published>2021-06-30T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">斐波拉契数列时间复杂度分析</a><ul><li><a href="#%E9%80%92%E5%BD%92%E7%89%88">递归版</a><ul><li><a href="#%E8%AF%81%E6%98%8E1">证明1</a></li><li><a href="#%E8%AF%81%E6%98%8E2">证明2</a></li></ul></li></ul></li></ul><h1 id="斐波拉契数列时间复杂度分析"><a href="#斐波拉契数列时间复杂度分析" class="headerlink" title="斐波拉契数列时间复杂度分析"></a>斐波拉契数列时间复杂度分析</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>递归版本的时间复杂度分析，真的不知道怎么分析，需要根据<code>f(n) = f(n-1) + f(n-2)</code>推出通解。这显然是个数学问题。<br>不知道为什么他们会给出这结果，难道不管通项公式的后一项了？</p><p>通项公式如下:<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630173631.png" alt="20210630173631"></p><h3 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630173802.png" alt="20210630173802"></p><h3 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h3><p>还是看不太懂，为什么要给加法加个1呢？<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210630174145.png" alt="20210630174145"></p>]]></content>
    
    
    <summary type="html">关于斐波拉契数列递归和</summary>
    
    
    
    <category term="数据结构" scheme="https://laobameishijia.github.io/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="考研" scheme="https://laobameishijia.github.io/tag/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>实训day11</title>
    <link href="https://laobameishijia.github.io/2021/06/23/shi-xun-day11/"/>
    <id>https://laobameishijia.github.io/2021/06/23/shi-xun-day11/</id>
    <published>2021-06-23T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#test">Test</a></li><li><a href="#%E4%BD%9C%E4%B8%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">作业功能实现</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF">修改代码思路</a></li><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li></ul></li></ul><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>关于git 中rebase和merge的区别<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210621145651.png" alt="20210621145651"></p><h1 id="作业功能实现"><a href="#作业功能实现" class="headerlink" title="作业功能实现"></a>作业功能实现</h1><ul><li><input checked="" disabled="" type="checkbox"> 增加时间搜索</li><li><input checked="" disabled="" type="checkbox"> 增加时间更新修改</li><li><input checked="" disabled="" type="checkbox"> 增加个人页面 并且展示当前登录用户的名称和此用户的个人信息，增加修改</li><li><input disabled="" type="checkbox"> (扩展)用户可以自定义上传头像更新 实现退出效果</li></ul><h2 id="修改代码思路"><a href="#修改代码思路" class="headerlink" title="修改代码思路"></a>修改代码思路</h2><ul><li><input disabled="" type="checkbox"> 更改前端代码，增加相应的板块</li><li><input disabled="" type="checkbox"> Mapper 添加相应的查询</li><li><input disabled="" type="checkbox"> Controller接口</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p><input checked="" disabled="" type="checkbox">  用户更新里面的时间输入框无法渲染,就像是个普通的input, —-是不是跟js代码的渲染顺序有关系？？？？</p><pre><code>在回调函数里面继续写js代码就行啦</code></pre></li><li><p><input checked="" disabled="" type="checkbox">  在用户个人页面把详细的信息以pojo对应的方式传进去</p></li><li><p><input checked="" disabled="" type="checkbox">  修改了代码后记得重新打包哦！！！  否则上传到服务器的包还是之前的jar包，就会恼火很长时间。</p></li></ul>]]></content>
    
    
    <summary type="html">云服务</summary>
    
    
    
    <category term="国信安" scheme="https://laobameishijia.github.io/category/%E5%9B%BD%E4%BF%A1%E5%AE%89/"/>
    
    
    <category term="实训" scheme="https://laobameishijia.github.io/tag/%E5%AE%9E%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>leetcode7/8-找链表交点/合并有序链表</title>
    <link href="https://laobameishijia.github.io/2021/06/15/leetcode78-zhao-lian-biao-jiao-dian-he-bing-you-xu-lian-biao/"/>
    <id>https://laobameishijia.github.io/2021/06/15/leetcode78-zhao-lian-biao-jiao-dian-he-bing-you-xu-lian-biao/</id>
    <published>2021-06-15T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#leetcode7-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9">leetcode7-找链表交点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li></ul></li><li><a href="#leetcode8-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">leetcode8-合并有序链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">复杂度分析</a></li></ul></li></ul></li></ul><h1 id="leetcode7-找链表交点"><a href="#leetcode7-找链表交点" class="headerlink" title="leetcode7-找链表交点"></a>leetcode7-找链表交点</h1><p>这个题目又没有好好审题，我以为的交点可以是这样的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113259.png" alt="20210615113259"></p><p>没想到交点以后的所有节点应该都是重合的！</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113350.png" alt="20210615113350"></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果有相交的结点D的话,每条链的头结点先走完自己的链表长度,然后回头走另外的一条链表,那么两结点一定为相交于D点,因为这时每个头结点走的距离是一样的,都是 AD + BD + DC,而他们每次又都是前进1,所以距离相同,速度又相同,固然一定会在相同的时间走到相同的结点上,即D点。</p><ul><li><p>如果不相交 ： 如果不相交的话 假设两个链表长度不相等 一个为A 一个为B ，指针第一次走完A会去走B,另一个走完B再去走A，两个指针走的路程都是A+B。会同时为NULL 跳出循环</p></li><li><p>如果不相交且链表长度相等: 那么一个指针走A,一个指针走B，它俩同时走到NULL，相等，跳出循环</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-C"><code class="language-C">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    struct ListNode* A, * B;    A = headA;    B = headB;    while(A!=B)&#123;        A = A == NULL ? headB : A->next;        B = B == NULL ? headA : B->next;    &#125;    return A;&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(N)</code> 最差依次访问一遍 <code>A+B</code> 中的所有节点 <br><br>空间复杂度 <code>O(1)</code> 就用两个指针</p><h1 id="leetcode8-合并有序链表"><a href="#leetcode8-合并有序链表" class="headerlink" title="leetcode8-合并有序链表"></a>leetcode8-合并有序链表</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><pre class=" language-C"><code class="language-C">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。示例1：输入：1->2->4, 1->3->4输出：1->1->2->3->4->4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>leetcode的题解</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615164632.png" alt="20210615164632"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-C"><code class="language-C">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123;    struct ListNode* a, *b,*c,*d;    a = l1;    b = l2;    d = c = (struct ListNode*)malloc(sizeof(struct ListNode));    while(a&&b)&#123;        if(a->val < b->val) &#123;            c->next = a;            a = a->next;            c = c->next;        &#125;        else if(a->val>=b->val)&#123;            c->next = b;            b = b->next;            c = c->next;        &#125;    &#125;    if(a == NULL) c->next = b;    else c->next = a;    return d->next;&#125;</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(M+N)</code> M为l1链表的长度 N为l2链表的长度 <br><br>空间复杂度 O(1)</p>]]></content>
    
    
    <summary type="html">找链表交点/合并有序链表</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5-反向输出链表</title>
    <link href="https://laobameishijia.github.io/2021/06/14/leetcode5-fan-xiang-shu-chu-lian-biao/"/>
    <id>https://laobameishijia.github.io/2021/06/14/leetcode5-fan-xiang-shu-chu-lian-biao/</id>
    <published>2021-06-14T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反向输出链表"><a href="#反向输出链表" class="headerlink" title="反向输出链表"></a>反向输出链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1：输入：head = [1,3,2]输出：[2,3,1] 限制：0 &lt;= 链表长度 &lt;= 10000</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>第一遍遍历找到一共的个数</li><li>malloc</li><li>倒序赋值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-C"><code class="language-C">//反序打印链表int* reversePrint(struct ListNode* head, int* returnSize) &#123;    //第一遍遍历获取数目    int num = 0;    struct ListNode* temp = head;    while (temp)    &#123;        num++;        temp = temp->next;    &#125;    int* ret = (int*)malloc(num * sizeof(int));    memset(ret, -1, num * sizeof(int));        temp = head;    int i = 1;    while (temp)    &#123;        ret[num - i] = temp->val;        i++;        temp = temp->next;    &#125;    *returnSize = num;    return ret;&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(n)<br>空间复杂度 O(n)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>差不多跟我一样</p><pre class=" language-C"><code class="language-C">int* reversePrint(struct ListNode* head, int* returnSize)&#123;    struct ListNode *p = head;    int n = 0;    while(p != NULL) &#123;        p = p->next;        n++;    &#125;    int *arr = (int *)malloc(sizeof(int) * n);    struct ListNode *q = head;    *returnSize = n;    for(int i = n - 1; i >= 0; i--)&#123;        arr[i] = q->val;        q = q->next;    &#125;    return arr;&#125;</code></pre>]]></content>
    
    
    <summary type="html">反向输出链表</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode6-判断链表中是否存在环</title>
    <link href="https://laobameishijia.github.io/2021/06/14/leetcode6-pan-duan-lian-biao-zhong-shi-fou-cun-zai-huan/"/>
    <id>https://laobameishijia.github.io/2021/06/14/leetcode6-pan-duan-lian-biao-zhong-shi-fou-cun-zai-huan/</id>
    <published>2021-06-14T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode6-判断链表中是否存在环"><a href="#leetcode6-判断链表中是否存在环" class="headerlink" title="leetcode6-判断链表中是否存在环"></a>leetcode6-判断链表中是否存在环</h1><p>这道题感觉很难嗷！ 但是确实是属于简单题的行列( 我是fw )，全程都在看解析。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><pre class=" language-c"><code class="language-c">bool <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> fast<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点数。</p><ul><li><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p></li><li><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p></li></ul></li><li><p>空间复杂度：<code>O(1)</code> 我们只使用了两个指针的额外空间。</p></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p>重要的是哈希表的原理<br>知乎的文章： 具体还是你后面去看看相应的源码，会比较方便一些。</p><p><a href="https://zhuanlan.zhihu.com/p/144296454">https://zhuanlan.zhihu.com/p/144296454</a></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p></li><li><p>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p></li></ul>]]></content>
    
    
    <summary type="html">判断链表中是否存在环</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4-删除链表节点</title>
    <link href="https://laobameishijia.github.io/2021/06/11/leetcode4-shan-chu-lian-biao-jie-dian/"/>
    <id>https://laobameishijia.github.io/2021/06/11/leetcode4-shan-chu-lian-biao-jie-dian/</id>
    <published>2021-06-11T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leecode4-删除链表节点"><a href="#leecode4-删除链表节点" class="headerlink" title="leecode4-删除链表节点"></a>leecode4-删除链表节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>说明：文章中的优秀思路均来自优秀题解的第一个，之所以截图是因为懒。。</p><pre class=" language-C"><code class="language-C">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。注意：此题对比原题有改动示例 1:输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.示例 2:输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里借鉴了前面看到优秀思路中的<strong>虚拟节点 virtualNode</strong> ,即在头节点head前再增加一个虚拟节点，可以避免讨论 <strong>tag</strong> 节点是否是头节点的情况。最后统一返回 <strong>virtualNode-&gt;next</strong></p><ul><li>遍历链表找到值相等的节点</li><li>保留节点的前驱节点 <strong>prev</strong></li><li>前驱节点 <strong>prev</strong> 指向删除节点 <strong>tag</strong> 的下一节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-C"><code class="language-C">struct ListNode* deleteNode(struct ListNode* head, int val) &#123;    struct ListNode* tag = head, * prev=NULL;    struct ListNode* virtualNode = (ListNode*)malloc(sizeof(ListNode));    virtualNode->next = head;    virtualNode->val = -1;    prev = virtualNode;    while (tag->next)    &#123;        if (tag->val == val) break;        prev = tag;        tag = tag->next;    &#125;    prev->next = tag->next;    return virtualNode->next;&#125;</code></pre><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果理解递归很困难，可以采用一种叫做<strong>坚定信念</strong>的理解方式。即假设<strong>deleteNode返回的值就是对应节点的下一个节点</strong>，那下面这个java版的递归就不难理解了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611093444.png" alt="20210611093444"></p>]]></content>
    
    
    <summary type="html">删除链表节点</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>py如何根据字符串来创建对应的类</title>
    <link href="https://laobameishijia.github.io/2021/06/11/py-ru-he-gen-ju-zi-fu-chuan-lai-chuang-jian-dui-ying-de-lei/"/>
    <id>https://laobameishijia.github.io/2021/06/11/py-ru-he-gen-ju-zi-fu-chuan-lai-chuang-jian-dui-ying-de-lei/</id>
    <published>2021-06-11T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="py如何根据字符串来创建对应的类"><a href="#py如何根据字符串来创建对应的类" class="headerlink" title="py如何根据字符串来创建对应的类"></a>py如何根据字符串来创建对应的类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>py的反射原理，简单来说，反射就是能实现动态地调用方法\实例化对象。</p><p>举个例子:<br></p><p>创建一个学生类Student的对象 person1、创建一个老师类Teacher的对象person1</p><pre class=" language-py"><code class="language-py">person1 = Student(name="张三")orperson1 = Teacher(name="张三")</code></pre><p>试想一下，假如，你并不是先前(在写程序之前)就知道这个person1的身份到底是学生还是老师，那你该如何创建这个对象？</p><p>或者说你要 <strong>根据这个人的输入: 职业:老师,姓名:张三</strong> 来动态的创建对象。</p><p>这里就要用到py的反射</p><p>对应到web路由可能更容易理解。详细请看 <a href="https://www.liujiangblog.com/course/python/48">https://www.liujiangblog.com/course/python/48</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在本次实训的过程中，由于是基线检查，但是对于每个审查条目的规则(存储在数据库)是不一样的。</p><p>关键的是，所用的validator中预制的规则rule无法满足特定的需求。然后，除了使用他文档中的规则意外，我根据他自定义规则的写法，自定义如下三种规则</p><ul><li>AuditRule-判断前后集合是否一致</li><li>AuditRuleInclude-判断前面集合是否是后面集合的子集</li><li>AuditRuleSame-判断两个字符串是否相等。</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AuditRule</span><span class="token punctuation">(</span>Rule<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    TestCode:        rules = &amp;#123;"age": AuditRule('test,test')&amp;#125;        req = &amp;#123;"age": 'test,test'&amp;#125;        print(validate(req, rules,return_info=True))    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> string<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        Rule<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>string <span class="token operator">=</span> string        self<span class="token punctuation">.</span>value <span class="token operator">=</span> string<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arg <span class="token keyword">is</span> None<span class="token punctuation">:</span>            arg <span class="token operator">=</span> <span class="token string">"Null"</span>            self<span class="token punctuation">.</span>set_error<span class="token punctuation">(</span><span class="token string">"excepted get |"</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>string <span class="token operator">+</span> <span class="token string">"| but get |"</span> <span class="token operator">+</span> arg<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        exit_value_list <span class="token operator">=</span> arg<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 判断两个集合是否一样  前面是否是后面的子集</span>        self<span class="token punctuation">.</span>set_error<span class="token punctuation">(</span><span class="token string">"excepted get |"</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>string <span class="token operator">+</span> <span class="token string">"| but get |"</span> <span class="token operator">+</span> arg<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> set<span class="token punctuation">(</span>exit_value_list<span class="token punctuation">)</span> <span class="token operator">==</span> set<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span></code></pre><p>其实，我所用的validator这个包，就已经利用了反射。因为他就是根据我输入的字符串，去动态地翻译和创建成对应的类。所以我也想实现根据数据库中存储的规则，来动态地创建。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611161640.png" alt="20210611161640"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="使用的函数"><a href="#使用的函数" class="headerlink" title="使用的函数"></a>使用的函数</h3><p>我就只用到了<strong>getattr</strong>函数。其对应的文档解释如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">getattr</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> name<span class="token punctuation">,</span> default<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># known special case of getattr</span>    <span class="token triple-quoted-string string">"""    getattr(object, name[, default]) -> value        Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.    When a default argument is given, it is returned when the attribute doesn't    exist; without it, an exception is raised in that case.    """</span>    <span class="token keyword">pass</span></code></pre><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ul><li><p>创建package rules 将自定义的三个类分别以.py的形式放进去</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162135.png" alt="20210611162135"></p></li><li><p>在package中创建rules.py的文件，将自定义类，导入。<strong>第一行不要也可以</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162237.png" alt="20210611162237"></p></li><li><p>在要使用的文件中，以<strong>from rules import rules as Custom</strong>的形式导入</p></li><li><p>编写相应的代码</p><pre class=" language-py"><code class="language-py">  for item in results:  if item[3].startswith("Audit"):      rules[item[0]] = getattr(Custom, item[3])(item[2])  else:      rules[item[0]] = item[1] + ":" + item[2]</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>它对应的原理通过debug我猜测如下:<br>通过 <code>from rules import rules as Custom</code> 的方式其实是已经创建了<code>Custom</code>这个对象，其拥有三个自定义类的属性。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162753.png" alt="20210611162753"></p><p>然后通过<code>getattr</code>得到字符串对应的属性(类),并通过后面括号里面的字符串进行实例化。</p>]]></content>
    
    
    <summary type="html">根据字符串来创建对应的类</summary>
    
    
    
    <category term="反射" scheme="https://laobameishijia.github.io/category/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="python" scheme="https://laobameishijia.github.io/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode3-反转链表II</title>
    <link href="https://laobameishijia.github.io/2021/06/10/leetcode3-fan-zhuan-lian-biao-ii/"/>
    <id>https://laobameishijia.github.io/2021/06/10/leetcode3-fan-zhuan-lian-biao-ii/</id>
    <published>2021-06-10T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<p>目录:</p><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii">反转链表II</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li><li><a href="#%E4%BC%98%E7%A7%80%E6%80%9D%E8%B7%AF">优秀思路</a><ul><li><a href="#%E6%96%B9%E6%B3%951">方法1:</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">时间复杂度分析</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C">方法二</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">时间复杂度分析</a></li></ul></li></ul></li></ul></li></ul><h1 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a>反转链表II</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><pre><code>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1：输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]示例 2：输入：head = [5], left = 1, right = 1输出：[5] 提示：链表中节点数目为 n1 &lt;= n &lt;= 500-500 &lt;= Node.val &lt;= 5001 &lt;= left &lt;= right &lt;= n</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>左端节点不是起始节点</li></ol><ul><li>找到左端点的前一个节点 <strong>leftpointer_1</strong> + 左端点 <strong>leftpointer</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端点的前一个节点 <strong>leftpointer_1</strong> 的next指向右端点 </li><li><strong>返回 head 头节点</strong></li></ul><ol start="2"><li>左端节点是起始节点(head)</li></ol><ul><li>左端点的前一个节点 <strong>leftpointer_1</strong> 为 <strong>null</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li><strong>返回右端节点 <strong>prev</strong></strong></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-C"><code class="language-C">struct ListNode* reverseBetween(struct ListNode* head, int left, int right) &#123;    struct ListNode* leftpointer_1, * rightpointer_1;    leftpointer_1 = rightpointer_1 = head;    int leftmove = left - 2;    int rigthmove = right - left;    int temp = rigthmove;    if (temp == 0 || temp < 0) return head;    if (leftmove == -1) leftpointer_1 = NULL;    else    &#123;        while (leftmove > 0 && leftpointer_1->next)        &#123;            leftpointer_1 = leftpointer_1->next;            leftmove--;        &#125;    &#125;    struct ListNode* prev = leftpointer_1;    struct ListNode* curr, * leftpointer;    if (leftpointer_1)     curr = leftpointer = leftpointer_1->next;    else curr = leftpointer = head;    while (curr && temp >= 0) &#123;        struct ListNode* next = curr->next;        curr->next = prev;        prev = curr;        curr = next;        temp--;        rightpointer_1 = curr;    &#125;    if (leftpointer_1) &#123;        leftpointer_1->next = prev;        leftpointer->next = rightpointer_1;        return head;    &#125;    else &#123;        leftpointer->next = rightpointer_1;        return prev;    &#125;&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>与我们的方法非常类似，但在编码的过程中，采用了虚拟头节点的方式，避免了左端点是否是起始点的分类讨论。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610143526.png" alt="20210610143526"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-C"><code class="language-C">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));    dummyNode->val = -1;    dummyNode->next = head;    struct ListNode *pre = dummyNode;    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点    // 建议写在 for 循环里，语义清晰    for (int i = 0; i < left - 1; i++) &#123;        pre = pre->next;    &#125;    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点    struct ListNode *rightNode = pre;    for (int i = 0; i < right - left + 1; i++) &#123;        rightNode = rightNode->next;    &#125;    // 第 3 步：切断出一个子链表（截取链表）    struct ListNode *leftNode = pre->next;    struct ListNode *curr = rightNode->next;    // 注意：切断链接    pre->next = NULL;    rightNode->next = NULL;    // 第 4 步：同第 206 题，反转链表的子区间    reverseLinkedList(leftNode);    // 第 5 步：接回到原来的链表中    pre->next = rightNode;    leftNode->next = curr;    return dummyNode->next;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/来源：力扣（LeetCode）</code></pre><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610144049.png" alt="20210610144049"></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class=" language-C"><code class="language-C">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));    dummyNode->val = -1;    dummyNode->next = head;    struct ListNode *pre = dummyNode;    for (int i = 0; i < left - 1; i++) &#123;        pre = pre->next;    &#125;    struct ListNode *cur = pre->next;    struct ListNode *next;    for (int i = 0; i < right - left; i++) &#123;        next = cur->next;        cur->next = next->next;        next->next = pre->next;        pre->next = next;    &#125;    return dummyNode->next;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p>]]></content>
    
    
    <summary type="html">反转链表II</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode2-反转链表</title>
    <link href="https://laobameishijia.github.io/2021/06/08/leetcode2-fan-zhuan-lian-biao/"/>
    <id>https://laobameishijia.github.io/2021/06/08/leetcode2-fan-zhuan-lian-biao/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-09-30T06:52:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><pre class=" language-c"><code class="language-c">示例<span class="token punctuation">:</span>输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-></span><span class="token number">2</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">4</span><span class="token operator">-></span><span class="token number">5</span><span class="token operator">-></span><span class="token constant">NULL</span>输出<span class="token punctuation">:</span> <span class="token number">5</span><span class="token operator">-></span><span class="token number">4</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">2</span><span class="token operator">-></span><span class="token number">1</span><span class="token operator">-></span><span class="token constant">NULL</span> 限制：<span class="token number">0</span> <span class="token operator">&lt;=</span> 节点个数 <span class="token operator">&lt;=</span> <span class="token number">5000</span>来源：力扣（LeetCode）链接：https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>leetcode<span class="token operator">-</span>cn<span class="token punctuation">.</span>com<span class="token operator">/</span>problems<span class="token operator">/</span>fan<span class="token operator">-</span>zhuan<span class="token operator">-</span>lian<span class="token operator">-</span>biao<span class="token operator">-</span>lcof</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>链表没有节点</li><li>链表只有一个节点</li><li>链表有两个节点</li><li>链表有三个及三个以上的节点</li></ol><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/%E7%94%A8ipad%E6%8A%8A%E6%80%9D%E8%B7%AF%E7%9A%84%E5%9B%BE%E7%94%BB%E5%9C%A8%E8%BF%99.png" alt="用ipad把思路的图画在这"></p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>由于只用遍历一遍链 <br><br>时间复杂度为<strong>O(n) n 为链表的长度</strong> <br><br>以上代码，<strong>分配的空间不会随着处理数据量的变化而变化，因此得到空间复杂度为 O空间复杂度为O(1</strong>)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>这次优秀思路其实跟我思路差不多，但是优秀思路的代码写的要更简洁。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210608172423.png" alt="20210608172423"></p><h2 id="我思路的代码"><a href="#我思路的代码" class="headerlink" title="我思路的代码"></a>我思路的代码</h2><pre class=" language-C"><code class="language-C">struct ListNode* reverseList(struct ListNode* head) &#123;    ListNode* first,*second,*third;        // 0个节点    if (head == NULL) return NULL;    // 1个节点    if (head->next == NULL) return head;    // 2个节点    if (head->next->next == NULL) &#123;        first = head;        second = head->next;        first->next = NULL;        second->next = first;        return second;    &#125;    // 3个以上的节点    first = head;    second = head->next;    third = head->next->next;        while (1) &#123;        second->next = first;        if (third == NULL) break;        first = second;        second = third;        third = third->next;    &#125;    //把第一个节点的next指向null    head->next = NULL;    //返回头节点    return second;&#125;</code></pre>]]></content>
    
    
    <summary type="html">反转链表</summary>
    
    
    
    <category term="链表" scheme="https://laobameishijia.github.io/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="https://laobameishijia.github.io/tag/leetcode/"/>
    
  </entry>
  
</feed>
