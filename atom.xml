<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  <subtitle>永远热爱生活</subtitle>
  <link href="https://laobameishijia.github.io/atom.xml" rel="self"/>
  
  <link href="https://laobameishijia.github.io/"/>
  <updated>2022-01-18T13:57:57.720Z</updated>
  <id>https://laobameishijia.github.io/</id>
  
  <author>
    <name>老叭美食家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OneToOne-1</title>
    <link href="https://laobameishijia.github.io/2022/01/06/onetoone-1/"/>
    <id>https://laobameishijia.github.io/2022/01/06/onetoone-1/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OneToOne-1"><a href="#OneToOne-1" class="headerlink" title="OneToOne-1"></a>OneToOne-1</h1><p>比赛时间：2022/1/4</p><p>不知不觉，已经到了大四上学期结束的时候了。跟狗子的单挑也从大一持续到了现在。 这学期的单挑，真的是没赢过啊。确实是有机会赢，但是自己没有把握住。虽然自己矮十几厘米，但是我还算比较有韧性把。很多时候，我都会怀疑自己会输。可总是会咬牙坚持到最后。尤其是最近刚刚打过的这次。</p><p>5局3胜制，我开局以0比2落后。面对比自己高比自己壮的人，我很难不产生一种要服输的心理。三分真的算是我位数不多的得分手段了，如果三分球投不进，我真的很难赢。我不断在心里默默地给自己加油，鼓励自己坚持下去。果然，连续翻了2局。</p><p>最后一局，也是打到了10比10平(11分制)。首先的球权是在我手里，但是我没有把握住机会。不知道为什么，在习惯了以三分作为自己的得分手段之后，以前我非常擅长的中距离变得非常陌生。没办法判断到底什么时机是合适的出手机会。所以啊，还是要继续努力才行。生活中比较庆幸地也是有这样的朋友把，大家就不断互相进步。</p><p>其实把，想赢的心理在我心中一直都有。只不过，确实有的时候会动摇。你会怀疑自己到底能不能赢。就像在面对生活中的困难一样，我觉得正常的人可能都会质疑自己是否能挺过难关，是否能真正地坚持下去。但无疑，坚持下去大多时候会有一个比自己预期要好的结果。就像这次单挑一样，0比2落后，我真的怀疑自己了。但是我心里告诉自己，一定要坚持下去，没有结束，凭什么就这么服输，三分不可能一直投不进。</p><p>我经常会以这些看似鸡汤话鼓励一些在生活中过的不那么如意的人，<strong>有些人总是会说: 只不过是你运气好罢了。</strong> 我觉得他们说的很正确，之所以我有今天的价值观，无非是在我的经历中，坚持下去的做法带来了较多积极的效果。 即使是这样，我仍不觉得我鼓励别人积极乐观地生活是错的，因为我觉得，坚持下去的结果总比放弃的结果好。<strong>哪怕你这次说我没有站在你的角度上思考问题，下次我还是会这么鼓励你。</strong></p><p>回想一下，从刚上大学到现在，坚持练球的过程真的带给我很多生活中的道理。从习惯性一个人为了自己的目标努力，到不因为眼前的困难而放弃，到如何在别人的嘲笑下依旧坚持自己，再到学会把眼光放得长远。我不知道是不是每个打球的人都能体会到这些，但显然善于体味生活的人一定会从中得到很多属于自己的故事。</p><p><strong>我的高中班主任曾经说我打球的原因，就是想耍帅。</strong>但事实是，我经常性地自己练球。 也并没有因此获得什么可以拿的出手的成绩。 可这些并没有影响到我对于篮球的喜爱。 还是那句话，我不是为了打败谁，也不是想成为像NBA球星一样的人物。 我的目标很简单：就是完成自己给自己设定的目标，也许这个目标在有些人看来不值一提。 可是我相信，慢慢地努力，总会达到我想要的效果。现实也正是如此。</p><p>很幸运，我遇到了篮球。要真的追想的话，也不知道具体自己什么时间就喜欢上了篮球。那种不求任何结果，慢慢享受打球过程和眼看着自己慢慢进步的感觉真的很美妙。 可惜，我在我专业课程的学习上并没有这种劲头。 我也喜欢，但没有那种痴迷式的喜欢。 造成的结果也清楚， 我只是比一部分人做得好，但成为不了那种比绝大部分人做得好的人。 哪怕我自己清楚这一点， 还是跟篮球一样， 我不是为了要比谁强，比谁更优秀，我只是像完成自己对自己设定的目标。</p><hr><p>老早就想写这样的总结了，还是往后拖了几天…. 也不知道自己写了点啥， 反正就当给生活留个纪念吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OneToOne-1&quot;&gt;&lt;a href=&quot;#OneToOne-1&quot; class=&quot;headerlink&quot; title=&quot;OneToOne-1&quot;&gt;&lt;/a&gt;OneToOne-1&lt;/h1&gt;&lt;p&gt;比赛时间：2022/1/4&lt;/p&gt;
&lt;p&gt;不知不觉，已经到了大四上学期结束的</summary>
      
    
    
    
    <category term="篮球" scheme="https://laobameishijia.github.io/category/%E7%AF%AE%E7%90%83/"/>
    
    
    <category term="OneToOne" scheme="https://laobameishijia.github.io/tag/OneToOne/"/>
    
  </entry>
  
  <entry>
    <title>大四上学期总结</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<p>既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。</p><p>首先。还是没有找到女朋友，<strong>一 我接触的女生确实不多</strong>，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的是没有男女的情感在里面。于是我拒绝了她，不过好在大家的关系也并没有因此显的很尴尬。<strong>二 我并没有很想谈恋爱</strong> 我有我自己的生活，习惯了一个人做事情，反倒不太习惯两个人。 <strong>三 缺乏勇气</strong>  我必须承认自己是一个缺乏勇气的人，在路上看到有些稍微心动的女生，不敢上去要个微信。也许要了也是白要，我总是这样告诉自己。</p><p>接着。就是保研，这个东西确实是个惊喜吧，也确实有运气成分再里面。 我并不认为自己和优秀能扯上关系，至少在学习方面是这样的。</p><p>然后。自己把三分球慢慢地练出来了，也找到了算是比较合适的训练方法。虽然命中率还是不稳定，有的时候还是比较准的。</p><p>还有。 学着去看书，以前我总觉得看书没啥用，在静下心来去阅读一些书籍的生活，才发现，书真的是跟优秀人交流非常好的方式。如果你的生活中没有一些很厉害的人能和你交流，我觉得看他写的书，多多少少还是有些收获的。那就不能不提我看书最大的一个收获就是:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 因为感觉很多事情，远远比我想象中的要复杂，或者即使它很简单，在执行的过程中依然会遇到各种非常难以解决和调和的问题。 另外就是哲学家真的很厉害，尤其是罗素*–ps 看过&lt;幸福之路&gt;，虽然没记住多少，心灵还是很受震撼的*</p><p>emm。 结交了一个非常优秀的朋友，人长得又高又帅。努力拼搏，对自己未来有规划。不像俺，没啥清晰的目标，还不如人家勤奋。</p><p>最后。 2021年的最后一天去欢乐谷体验了一把大摆锤。就是那种摆上去又把你摆下来的，不得不说，要不是没有我朋友鼓励，我还真的不敢坐。也算是挑战了自己一把，不过我还是暗暗发誓：我再也不做了。</p><p>至于活动方面，参与过学校人大换届选举，也当过核酸检测的志愿者。这些活动也更加证实我从书中获得的收获—:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 动不动就开始吐槽和埋怨，既不利于事情的解决，也容易陷入片面思考的误区。</p><p>至于照片，寒假有空就把自己手机当中的照片整理一下把。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。&lt;/p&gt;
&lt;p&gt;首先。还是没有找到女朋友，&lt;strong&gt;一 我接触的女生确实不多&lt;/strong&gt;，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的</summary>
      
    
    
    
    <category term="学期总结" scheme="https://laobameishijia.github.io/category/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>大四上寒假计划</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<p>寒假计划</p><ul><li><input disabled="" type="checkbox"> 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动</li><li><input disabled="" type="checkbox"> 毕设一定要稳步推进</li><li><input disabled="" type="checkbox"> 学会做更多的菜，尝试去做蛋糕</li><li><input disabled="" type="checkbox"> 多跟着奶奶置办一些年货</li><li><input disabled="" type="checkbox"> 去走动亲戚，尤其是那种好几年都没回来过的。<strong>不要找一些冠冕堂皇的借口，其实你就是懒！</strong></li><li><input disabled="" type="checkbox"> 不要跟家里人生气，争取一次都不要</li><li><input disabled="" type="checkbox"> 再配一副眼镜，去体育公园打打球</li><li><input disabled="" type="checkbox"> 买到自己想要的新年衣服</li><li><input disabled="" type="checkbox"> 留意一下家里有没有什么合适的女朋友 😀~~~ (？！我劝你好自为之)</li></ul><p>暂时就是这些，希望寒假回来的时候，能都打上√</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寒假计划&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 毕设一定要稳步推进</summary>
      
    
    
    
    <category term="寒假计划" scheme="https://laobameishijia.github.io/category/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-3</title>
    <link href="https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/"/>
    <id>https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/</id>
    <published>2022-01-02T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-3"><a href="#毕设-Fuzz-AFLGo源码阅读-3" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-3"></a>毕设-Fuzz-AFLGo源码阅读-3</h1><h2 id="AFL框架"><a href="#AFL框架" class="headerlink" title="AFL框架"></a>AFL框架</h2><h3 id="共享内存中的bitmap结构-amp-amp-forkserver机制"><a href="#共享内存中的bitmap结构-amp-amp-forkserver机制" class="headerlink" title="共享内存中的bitmap结构 &amp;&amp; forkserver机制"></a>共享内存中的bitmap结构 &amp;&amp; forkserver机制</h3><p>不太好描述，就直接放图上来了。  —其他的都写到注释里面了</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220118215515.jpg" alt="共享内存中的bitmap结构&amp;&amp;forkserver机制"></p><h2 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux C"></a>Linux C</h2><h3 id="进程之间的信号是如何进行传递的"><a href="#进程之间的信号是如何进行传递的" class="headerlink" title="进程之间的信号是如何进行传递的"></a>进程之间的信号是如何进行传递的</h3><p>直接看下面的链接把</p><p><a href="https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b">https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b</a></p><h3 id="控制台和终端的关系"><a href="#控制台和终端的关系" class="headerlink" title="控制台和终端的关系"></a>控制台和终端的关系</h3><p><a href="https://www.cnblogs.com/sparkdev/p/11460821.html">https://www.cnblogs.com/sparkdev/p/11460821.html</a></p><p>在计算机里，把那套直接连接在电脑上的键盘和显示器就叫做控制台。而终端是通过串口连接上的，不是计算机自身的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。这同样说明，控制台是计算机的基本设备，而终端是附加设备。计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。比如在启动和关闭 Linux 系统时，我们可以在控制台上看到很多的内核信息(下图来自 vSphere Client 中的 “Virtual Machine Console”)</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103170553.png" alt="控制台"></p><p>现在终端和控制台都由硬件概念，逐渐演化成了软件的概念。<strong>简单的说，能直接显示系统消息的那个终端称为控制台，其他的则称为终端(控制台也是一个终端)。或者我们在平时的使用中压根就不区分 Linux 中的终端与控制台。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103171552.png" alt="Linux上的终端"></p><h3 id="dev-urandom-dev-null"><a href="#dev-urandom-dev-null" class="headerlink" title="/dev/urandom /dev/null"></a>/dev/urandom /dev/null</h3><p>一个是随机数生成器, 另一个相当于空文件, 所有定向到这个地方的输入都会消失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-3&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-3&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-2</title>
    <link href="https://laobameishijia.github.io/2021/12/22/bi-she-fuzz-aflgo-yuan-ma-yue-du-2/"/>
    <id>https://laobameishijia.github.io/2021/12/22/bi-she-fuzz-aflgo-yuan-ma-yue-du-2/</id>
    <published>2021-12-22T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-2"><a href="#毕设-Fuzz-AFLGo源码阅读-2" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-2"></a>毕设-Fuzz-AFLGo源码阅读-2</h1><h2 id="AFL框架"><a href="#AFL框架" class="headerlink" title="AFL框架"></a>AFL框架</h2><h3 id="共享内存中的bitmap结构"><a href="#共享内存中的bitmap结构" class="headerlink" title="共享内存中的bitmap结构"></a>共享内存中的bitmap结构</h3><p>TODO</p><h3 id="forkserver机制"><a href="#forkserver机制" class="headerlink" title="forkserver机制"></a>forkserver机制</h3><p>TODO </p><h2 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux C"></a>Linux C</h2><h3 id="read-amp-amp-write"><a href="#read-amp-amp-write" class="headerlink" title="read &amp;&amp; write"></a>read &amp;&amp; write</h3><p>看这个书，这个上面写的很详细</p><p><a href="https://www.bookstack.cn/read/linux-c/c917e635f91d4a4f.md">https://www.bookstack.cn/read/linux-c/c917e635f91d4a4f.md</a></p><h3 id="itimerval"><a href="#itimerval" class="headerlink" title="itimerval"></a>itimerval</h3><p> <a href="https://beachboyy.blog.csdn.net/article/details/35569229?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn">参考</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct itimerval &#123;    struct timeval it_interval; &#x2F;* 计时器重启动的间歇值 *&#x2F;    struct timeval it_value;    &#x2F;* 计时器安装后首先启动的初始值 *&#x2F;&#125;; struct timeval &#123;    long tv_sec;                &#x2F;* 秒 *&#x2F;    long tv_usec;               &#x2F;* 微妙(1&#x2F;1000000) *&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码实现的功能：3秒钟后启动定时器，然后每隔1秒钟向终端打印count的递增值，当count到10时程序退出。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;sys&#x2F;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;  static int count &#x3D; 0;  void set_timer()&#123;struct itimerval itv;  itv.it_value.tv_sec &#x3D; 3;    &#x2F;&#x2F;timer start after 3 seconds lateritv.it_value.tv_usec &#x3D; 0;  itv.it_interval.tv_sec &#x3D; 1;itv.it_interval.tv_usec &#x3D; 0;  setitimer(ITIMER_REAL,&amp;itv,NULL);&#125;  void signal_handler(int m)&#123;count ++;printf(&quot;%d\n&quot;,count);&#125;  int main()&#123;signal(SIGALRM,signal_handler);set_timer();while(count &lt; 10);exit(0);return 0; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="setsid"><a href="#setsid" class="headerlink" title="setsid()"></a>setsid()</h3><p>setsid主要是重新创建一个session,子进程从父进程继承了SessionID、进程组ID和打开的终端,子进程如果要脱离父进程，不受父进程控制，我们可以用这个setsid命令</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211223200534.png" alt="setsid ping 127.0.0.1"></p><p>可以发现即使我们按下<code>ctrl+c</code> ping命令依然在执行，也就是说ping命令脱离了父进程shell的控制。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211223200711.png" alt="ps -ef | grep ping"></p><h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><p>去看csdn这篇博客 <a href="https://blog.csdn.net/silent123go/article/details/71108501">https://blog.csdn.net/silent123go/article/details/71108501</a></p><p>从shell中运行一个进程，默认会有3个文件描述符存在(0、１、2)，0与进程的标准输入相关联，１与进程的标准输出相关联，2与进程的标准错误输出相关联，一个进程当前有哪些打开的文件描述符可以通过/proc/进程ID/fd目录查看。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>很清楚</p><p><a href="https://www.bookstack.cn/read/linux-c/f72a2171d262cc79.md#783frj">https://www.bookstack.cn/read/linux-c/f72a2171d262cc79.md#783frj</a></p><h3 id="builtin-expect"><a href="#builtin-expect" class="headerlink" title="__builtin_expect"></a>__builtin_expect</h3><p>链接：<a href="https://www.jianshu.com/p/2684613a300f">https://www.jianshu.com/p/2684613a300f</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define likely(x) __builtin_expect(!!(x), 1) &#x2F;&#x2F;x很可能为真       #define unlikely(x) __builtin_expect(!!(x), 0) &#x2F;&#x2F;x很可能为假if(likely(value))  &#x2F;&#x2F;等价于 if(value)if(unlikely(value))  &#x2F;&#x2F;也等价于 if(value)example上面的代码中 gcc 编译的指令会预先读取 y &#x3D; -1 这条指令，这适合 x 的值大于 0 的概率比较小的情况。如果 x 的值在大部分情况下是大于 0 的，就应该用 likely(x &gt; 0)，这样编译出的指令是预先读取 y &#x3D; 1 这条指令了。这样系统在运行时就会减少重新取指了int x, y; if(unlikely(x &gt; 0))    y &#x3D; 1; else     y &#x3D; -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211224190553.png" alt="fprintf"></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="零碎的知识"><a href="#零碎的知识" class="headerlink" title="零碎的知识"></a>零碎的知识</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220102144443.png" alt="mov指令"></p><p><a href="https://www.cnblogs.com/lsgxeva/p/11176000.html">深入浅出GNU X86-64 汇编</a></p><p><a href="https://www.cnblogs.com/yanghong-hnu/p/4705755.html">bss段，data段、text段、堆(heap)和栈(stack)</a></p><h3 id="XMM寄存器组"><a href="#XMM寄存器组" class="headerlink" title="XMM寄存器组"></a>XMM寄存器组</h3><p>除了我们已经讨论过的寄存器，现代处理器还有一些扩展。这些扩展体现在电路上，指令集上，有时候也会扩展一些很有用的寄存器。比较著名的扩展叫作 SSE (Streaming SIMD Extensions)，该扩展加入了新的 xmm 寄存器集合：xmm0，xmm1，…，xmm15。这些寄存器为 128 位宽，常用于两种任务：</p><ul><li>浮点数运算；以及</li><li>SIMD 指令集(这种指令一条指令可以操作多条数据)<br>常用的 mov 指令没有办法操作 xmm 寄存器。movq 指令可以代替用来拷贝 xmm 寄存器的低位(128 位中的低 64 位)，操作数的其中一个可以也是 xmm 寄存器，或者通用寄存器，或者内存(也得是 64 位)。</li></ul><p>为了填满 xmm 寄存器，你有两个选择：movdqa 和 movdqu。前者可以解释为“ move aligned double quad word”，移动两个对齐的 qword。后者是未对齐的版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-2&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-2&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-2&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-2&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-1</title>
    <link href="https://laobameishijia.github.io/2021/12/15/bi-she-fuzz-aflgo-yuan-ma-yue-du-1/"/>
    <id>https://laobameishijia.github.io/2021/12/15/bi-she-fuzz-aflgo-yuan-ma-yue-du-1/</id>
    <published>2021-12-15T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFLGo源码阅读-1"><a href="#AFLGo源码阅读-1" class="headerlink" title="AFLGo源码阅读-1"></a>AFLGo源码阅读-1</h1><p>首先还是要从基础的C语言语句开始补起。</p><h2 id="AFL-代码覆盖率及其相关概念"><a href="#AFL-代码覆盖率及其相关概念" class="headerlink" title="AFL-代码覆盖率及其相关概念"></a>AFL-代码覆盖率及其相关概念</h2><p>原文：<a href="https://www.freebuf.com/vuls/197672.html">https://www.freebuf.com/vuls/197672.html</a></p><h3 id="1-代码覆盖率（Code-Coverage）"><a href="#1-代码覆盖率（Code-Coverage）" class="headerlink" title="1. 代码覆盖率（Code Coverage）"></a>1. 代码覆盖率（Code Coverage）</h3><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的官方文档。</p><h3 id="2-基本块（Basic-Block）"><a href="#2-基本块（Basic-Block）" class="headerlink" title="2. 基本块（Basic Block）"></a>2. 基本块（Basic Block）</h3><p>缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征：</p><ul><li>只有一个入口点，BB中的指令不是任何跳转指令的目标。</li><li>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</li></ul><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151025.png" alt="基本块"></p><h3 id="3-边（edge）"><a href="#3-边（edge）" class="headerlink" title="3. 边（edge）"></a>3. 边（edge）</h3><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151136.png" alt="CFG"></p><h3 id="4-元组（tuple）"><a href="#4-元组（tuple）" class="headerlink" title="4. 元组（tuple）"></a>4. 元组（tuple）</h3><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录当前基本块 + 前一基本块 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cur_location <span class="token operator">=</span> <span class="token operator">&lt;</span>COMPILE_TIME_RANDOM<span class="token operator">></span><span class="token punctuation">;</span>           <span class="token comment">//用一个随机数标记当前基本块</span>shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//将当前块和前一块异或保存到shared_mem[]</span>prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">//cur_location右移1位区分从当前块到当前块的转跳</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx/rcx，然后调用__afl_maybe_log，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151618.png" alt="IDA中的汇编代码"></p><blockquote><p>关于这个过程后续肯定要弄的非常清楚才行， 因为要添加一个基于基本块覆盖率的模拟退火算法，这样的扩展应该加在什么地方，以及怎么实现都需要把这个过程弄清楚。</p></blockquote><h2 id="C-知识"><a href="#C-知识" class="headerlink" title="C 知识"></a>C 知识</h2><h3 id="C-预处理"><a href="#C-预处理" class="headerlink" title="C 预处理"></a>C 预处理</h3><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p><p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211215211258.png" alt="预处理指令列表"></p><p>其他的详见菜鸟教程。<br><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">https://www.runoob.com/cprogramming/c-preprocessors.html</a></p><h3 id="C-C-中-volatile-关键字详解"><a href="#C-C-中-volatile-关键字详解" class="headerlink" title="C/C++ 中 volatile 关键字详解"></a>C/C++ 中 volatile 关键字详解</h3><p>C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。这是 BS 在 “The C++ Programming Language” 对 volatile 修饰词的说明：</p><blockquote><p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p></blockquote><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">volatile</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><span class="token keyword">int</span> b <span class="token operator">=</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而<strong>优化</strong>做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说<strong>volatile 可以保证对特殊地址的稳定访问</strong>。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="程序处理中的控制流图和调用图"><a href="#程序处理中的控制流图和调用图" class="headerlink" title="程序处理中的控制流图和调用图"></a>程序处理中的控制流图和调用图</h3><h4 id="控制流图–Control-Flow-Graph"><a href="#控制流图–Control-Flow-Graph" class="headerlink" title="控制流图–Control Flow Graph"></a>控制流图–Control Flow Graph</h4><p>控制流图(Control Flow Graph, CFG)也叫控制流程图，是一个过程或程序的抽象表现，是用在编译器中的一个抽象数据结构，由编译器在内部维护，代表了一个程序执行过程中会遍历到的所有路径。它用图的形式表示一个过程内所有基本块执行的可能流向, 也能反映一个过程的实时执行过程。Frances E. Allen于1970年提出控制流图的概念。此后，控制流图成为了编译器优化和静态分析的重要工具。</p><p>原文：<br>In a control-flow graph each node in the graph represents a basic block, i.e. a straight-line piece of code without any jumps or jump targets; jump targets start a block, and jumps end a block. Directed edges are used to represent jumps in the control flow. There are, in most presentations, two specially designated blocks: the entry block, through which control enters into the flow graph, and the exit block, through which all control flow leaves.<br>译文：<br>在控制流图中，图中的每个节点代表一个基本块，即一段没有任何跳转或跳转目标的直线代码；跳转目标开始一个块，而跳转结束一个块。有向边用来表示控制流中的跳转。在大多数演示中，有两个特别指定的块：入口块，控制通过它进入流程图；出口块，所有控制流通过它离开。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211219105935.png" alt="控制流图的几种结构"></p><p><strong>特点</strong>:</p><ul><li>控制流程图是过程导向的</li><li>控制流程图显示了程序执行过程中可以遍历的所有路径</li><li>控制流程图是一个有向图</li><li>CFG 中的边描述控制流路径，节点描述基本块</li><li>每个控制流图都存在2个指定的块：Entry Block(输入块)，Exit Block(输出块)</li></ul><h4 id="函数调用图-Function-Call-Graph"><a href="#函数调用图-Function-Call-Graph" class="headerlink" title="函数调用图 Function Call Graph"></a>函数调用图 Function Call Graph</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211219111655.png" alt="函数调用图"></p><h3 id="插桩怎么实现"><a href="#插桩怎么实现" class="headerlink" title="插桩怎么实现"></a>插桩怎么实现</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="make-和-make-install-的区别"><a href="#make-和-make-install-的区别" class="headerlink" title="make 和 make install 的区别"></a>make 和 make install 的区别</h3><p>简单来说，make 是编译，make install 是安装。</p><p>总结：linux编译安装中configure、make和make install各自的作用</p><p>./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p><p>make是用来编译的，它从Makefile中读取指令，然后编译。</p><p>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>1、configure</p><p>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr上面的意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin.同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><p>2、make</p><p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或Python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。<br>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。一般情况下，他所使用的 Makefile 控制代码，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><p>3、make install</p><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）</p><blockquote><p>作者：cuteximi_1995 链接：<a href="https://www.jianshu.com/p/c70afbbf5172">https://www.jianshu.com/p/c70afbbf5172</a> 来源：简书</p></blockquote><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>Makefile给我的感觉，就好像是另一种编程语言一样。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFLGo源码阅读-1&quot;&gt;&lt;a href=&quot;#AFLGo源码阅读-1&quot; class=&quot;headerlink&quot; title=&quot;AFLGo源码阅读-1&quot;&gt;&lt;/a&gt;AFLGo源码阅读-1&lt;/h1&gt;&lt;p&gt;首先还是要从基础的C语言语句开始补起。&lt;/p&gt;
&lt;h2 id=&quot;AF</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-论文1</title>
    <link href="https://laobameishijia.github.io/2021/12/09/bi-she-fuzz-lun-wen-1/"/>
    <id>https://laobameishijia.github.io/2021/12/09/bi-she-fuzz-lun-wen-1/</id>
    <published>2021-12-09T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Directed-Greybox-Fuzzing"><a href="#Directed-Greybox-Fuzzing" class="headerlink" title="Directed Greybox Fuzzing"></a>Directed Greybox Fuzzing</h1><p>第一次完全从头看到尾的十六页的论文, 一方面是为了清楚AFLGo实现的原理, 另一方面是为开题报告积累一些材料. 后面, 还需要再把介绍AFL框架的论文看一遍. 因为AFLGo是以其为基础进行扩展的. 那想要了解地更深入, 就不可避免地要把基础搞懂.</p><p>这篇论文读下来, 发现AFLGo是在AFL的基础上添加了模拟退火算法. 其他的,因为看论文的时间过去了一段时间, 居然就都忘记了.</p><p>AFL重要的设计思想因为没有论文只能是去看项目中的txt, 很多东西也是看不太懂. 只能慢慢地硬啃了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Directed-Greybox-Fuzzing&quot;&gt;&lt;a href=&quot;#Directed-Greybox-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;Directed Greybox Fuzzing&quot;&gt;&lt;/a&gt;Directed Greyb</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-8</title>
    <link href="https://laobameishijia.github.io/2021/12/06/bi-she-fuzz-8/"/>
    <id>https://laobameishijia.github.io/2021/12/06/bi-she-fuzz-8/</id>
    <published>2021-12-06T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoteBook阅读"><a href="#NoteBook阅读" class="headerlink" title="NoteBook阅读"></a>NoteBook阅读</h1><h1 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h1><p>最近看的部分都是语法部分的, 从开始我们通过<strong>语法来表述各种语言</strong>. 到后面<strong>用设计好的语法来生成字符串.</strong></p><p>但是呢, 其实也可以反过来. 就是先给一个字符串, 用这个字符串分解成语法部分—也就是前面所说的<code>the derivation tree of that string</code>.然后我们再用这个tree去生成其他的测试数据.</p><blockquote><p>不过看了后面的例子, 他的意思是这样的. 我先已经有一个语法了, 但是呢, 这个语法的效果不是很好. 那么我们就需要从样本数据中提取模板. 然后在反过头去修改我们的语法. 这样可以使产生的数据更符合我们的要求. 换句话说, 就是有效的数据占比要更大.</p></blockquote><p><strong>这部分后面的代码就不看了. 我觉得我当下的重点, 也并不是完全读懂所有的代码逻辑. 而是清楚并了解fuzz相关的背景知识, 然后再去针对性的看论文和代码. 这样效率会更高一点吧.</strong></p><hr><p>看到后面这个部分的时候, 我突然感觉对于之前语法结构的理解有一些偏差.</p><p><code>noterminal</code> <code>terminal</code> <code>symbol</code>之间的关系和区别</p><p>原文中是这么说:</p><p>In the above expression, the rule <code>&lt;expr&gt;</code> : <code>[&lt;expr&gt; + &lt;expr&gt;, &lt;expr&gt; - &lt;expr&gt;, &lt;integer&gt;] </code> corresponds to how the nonterminal <code>&lt;expr&gt;</code> might be expanded. The expression <code>&lt;expr&gt; + &lt;expr&gt;</code> corresponds to one of the alternative choices. We call this an alternative expansion for the nonterminal <code>&lt;expr&gt;</code>. Finally, in an expression <code>&lt;expr&gt; + &lt;expr&gt;</code>, each of <code>&lt;expr&gt;</code>, <code>+</code>, and <code>&lt;expr&gt;</code> are symbols in that expansion. A symbol could be either a nonterminal or a terminal symbol based on whether its expansion is available in the grammar.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoteBook阅读&quot;&gt;&lt;a href=&quot;#NoteBook阅读&quot; class=&quot;headerlink&quot; title=&quot;NoteBook阅读&quot;&gt;&lt;/a&gt;NoteBook阅读&lt;/h1&gt;&lt;h1 id=&quot;Parser&quot;&gt;&lt;a href=&quot;#Parser&quot; class=&quot;</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-9</title>
    <link href="https://laobameishijia.github.io/2021/12/06/bi-she-fuzz-9/"/>
    <id>https://laobameishijia.github.io/2021/12/06/bi-she-fuzz-9/</id>
    <published>2021-12-06T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoteBook阅读"><a href="#NoteBook阅读" class="headerlink" title="NoteBook阅读"></a>NoteBook阅读</h1><h2 id="Probabilistic-Grammar-Fuzzing"><a href="#Probabilistic-Grammar-Fuzzing" class="headerlink" title="Probabilistic Grammar Fuzzing"></a>Probabilistic Grammar Fuzzing</h2><p>我们可以根据我们的需要去生成测试数据, 可以给某个<code>expansion</code>很高的权重, 这样的话, 在生成的数据过程中, 这个<code>expansion</code>被选择的概率就很高. 最终数据中的占比也就比较高.</p><blockquote><p>下面原文的意思也就是上面所说的</p></blockquote><h3 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h3><p>To <a href="Importing.ipynb">use the code provided in this chapter</a>, write</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fuzzingbook<span class="token punctuation">.</span>ProbabilisticGrammarFuzzer <span class="token keyword">import</span> <span class="token operator">&lt;</span>identifier<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>and then make use of the following features.</p><p>A <em>probabilistic</em> grammar allows to attach individual <em>probabilities</em> to production rules.  To set the probability of an individual expansion <code>S</code> to the value <code>X</code> (between 0 and 1), replace it with a pair</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span>S<span class="token punctuation">,</span> opts<span class="token punctuation">(</span>prob<span class="token operator">=</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If we want to ensure that 90% of phone numbers generated have an area code starting with <code>9</code>, we can write:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> Grammars <span class="token keyword">import</span> US_PHONE_GRAMMAR<span class="token punctuation">,</span> extend_grammar<span class="token punctuation">,</span> opts<span class="token operator">>></span><span class="token operator">></span> PROBABILISTIC_US_PHONE_GRAMMAR<span class="token punctuation">:</span> Grammar <span class="token operator">=</span> extend_grammar<span class="token punctuation">(</span>US_PHONE_GRAMMAR<span class="token punctuation">,</span><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token operator">>></span><span class="token operator">></span>       <span class="token string">"&lt;lead-digit>"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">>></span><span class="token operator">></span>                           <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">,</span> <span class="token string">"7"</span><span class="token punctuation">,</span> <span class="token string">"8"</span><span class="token punctuation">,</span><span class="token operator">>></span><span class="token operator">></span>                           <span class="token punctuation">(</span><span class="token string">"9"</span><span class="token punctuation">,</span> opts<span class="token punctuation">(</span>prob<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>                       <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A <code>ProbabilisticGrammarFuzzer</code> will extract and interpret these options.  Here is an example:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> probabilistic_us_phone_fuzzer <span class="token operator">=</span> ProbabilisticGrammarFuzzer<span class="token punctuation">(</span>PROBABILISTIC_US_PHONE_GRAMMAR<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>probabilistic_us_phone_fuzzer<span class="token punctuation">.</span>fuzz<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'(918)925-2501'</span><span class="token punctuation">,</span> <span class="token string">'(981)925-0792'</span><span class="token punctuation">,</span> <span class="token string">'(934)995-5029'</span><span class="token punctuation">,</span> <span class="token string">'(955)999-7801'</span><span class="token punctuation">,</span> <span class="token string">'(964)927-0877'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>As you can see, the large majority of area codes now starts with <code>9</code>.</p><h3 id="Learning-Probabilities-from-Samples"><a href="#Learning-Probabilities-from-Samples" class="headerlink" title="Learning Probabilities from Samples"></a>Learning Probabilities from Samples</h3><p>对于<code>expasion</code>的权重来讲, 必须要通过人工设定. 我们可以通过学习样本数据来设定这样的权重.</p><p>Probabilities need not be set manually all the time.  They can also be <em>learned</em> from other sources, notably by counting <em>how frequently individual expansions occur in a given set of inputs</em>.  This is useful in a number of situations, including:</p><ol><li>Test <em>common</em> features.  The idea is that during testing, one may want to focus on frequently occurring (or frequently used) features first, to ensure correct functionality for the most common usages.</li><li>Test <em>uncommon</em> features.  Here, the idea is to have test generation focus on features that are rarely seen (or not seen at all) in inputs.  This is the same motivation as with <a href="GrammarCoverageFuzzer.ipynb">grammar coverage</a>, but from a probabilistic standpoint.</li><li>Focus on specific <em>slices</em>.  One may have a set of inputs that is of particular interest (for instance, because they exercise a critical functionality, or recently have discovered bugs).  Using this learned distribution for fuzzing allows us to <em>focus</em> on precisely these functionalities of interest.</li></ol><h3 id="Lessons-Learned"><a href="#Lessons-Learned" class="headerlink" title="Lessons Learned"></a>Lessons Learned</h3><ul><li>By specifying probabilities, one can steer fuzzing towards input features of interest.</li><li>Learning probabilities from samples allows one to focus on features that are common or uncommon in input samples.</li><li>Learning probabilities from a subset of samples allows one to produce more similar inputs.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoteBook阅读&quot;&gt;&lt;a href=&quot;#NoteBook阅读&quot; class=&quot;headerlink&quot; title=&quot;NoteBook阅读&quot;&gt;&lt;/a&gt;NoteBook阅读&lt;/h1&gt;&lt;h2 id=&quot;Probabilistic-Grammar-Fuzzing&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-7</title>
    <link href="https://laobameishijia.github.io/2021/12/05/bi-she-fuzz-7/"/>
    <id>https://laobameishijia.github.io/2021/12/05/bi-she-fuzz-7/</id>
    <published>2021-12-05T09:25:00.000Z</published>
    <updated>2022-01-18T13:57:57.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoteBook阅读"><a href="#NoteBook阅读" class="headerlink" title="NoteBook阅读"></a>NoteBook阅读</h1><h2 id="Grammar-Coverage"><a href="#Grammar-Coverage" class="headerlink" title="Grammar Coverage"></a>Grammar Coverage</h2><p>在之前, 按照语法去去扩展生成字符串的时候, <strong>总是把各种扩展被选择的可能性相等化</strong>. 但是呢, 对于产生详细的综合性测试数据来说, <strong>更看重种类的最大化.(不一次又一次地重复相同的扩展)</strong></p><p>所以, 这小节就是为了解决这个问题. 当然, 在我们上一节的扩展中, 我们使用了<code>maxcost</code>和<code>mincost</code>两种方法, 也确实在一定程度上, 增大了种类的多样性,同时也避免了无限扩展的发生. 可能这一节会对这个问题展开更详细地解答把.</p><blockquote><p>毕竟从理论上来说, 更多地对产生输入数据路径的覆盖(<code>更高的语法覆盖率</code>)理论上会产生更高的<code>代码覆盖率</code>, 也就更有可能触发新的bug. 这也是这部分工作的意义</p></blockquote><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211205200902.png" alt="三种方法的效果对比"></p><h3 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h3><p>This chapter introduces <code>GrammarCoverageFuzzer</code>, an efficient grammar fuzzer extending <code>GrammarFuzzer</code> from the <a href="GrammarFuzzer.ipynb">chapter on efficient grammar fuzzing</a>.  It strives to <em>cover all expansions at least once,</em> thus ensuring coverage of functionality.</p><p>In the following example, for instance, we use <code>GrammarCoverageFuzzer</code> to produce an expression. We see that the resulting expression <strong>covers all digits and all operators in a single expression.</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">>></span> <span class="token string">'-(2 + 3) * 4.5 / 6 - 2.0 / +8 + 7 + 3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Lessons-Learned"><a href="#Lessons-Learned" class="headerlink" title="Lessons Learned"></a>Lessons Learned</h3><ul><li>Achieving <em>grammar coverage</em> quickly results in a large variety of inputs.</li><li>Duplicating grammar rules allows to cover elements in specific <em>contexts</em>.–这个点,我是真的不太理解, 相当于复制了很多副本进来. 这样就能实现很覆盖语法路径?</li><li>Achieving grammar coverage can help in obtaining <em>code coverage</em>.—这个东西, 要具体问题具体分析, 在有些问题上面, 语法覆盖率和代码覆盖率是正相关. 但并不代表所有的问题都是这样.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoteBook阅读&quot;&gt;&lt;a href=&quot;#NoteBook阅读&quot; class=&quot;headerlink&quot; title=&quot;NoteBook阅读&quot;&gt;&lt;/a&gt;NoteBook阅读&lt;/h1&gt;&lt;h2 id=&quot;Grammar-Coverage&quot;&gt;&lt;a href=&quot;#Gramm</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
  </entry>
  
</feed>
