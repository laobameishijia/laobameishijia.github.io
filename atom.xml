<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-15T08:58:48.173Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode4-删除链表节点</title>
    <link href="http://example.com/2021/06/11/leetcode4-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2021/06/11/leetcode4-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/</id>
    <published>2021-06-11T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leecode4-删除链表节点"><a href="#leecode4-删除链表节点" class="headerlink" title="leecode4-删除链表节点"></a>leecode4-删除链表节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>说明：文章中的优秀思路均来自优秀题解的第一个，之所以截图是因为懒。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span><br><span class="line"></span><br><span class="line">返回删除后的链表的头节点。</span><br><span class="line"></span><br><span class="line">注意：此题对比原题有改动</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里借鉴了前面看到优秀思路中的<strong>虚拟节点 virtualNode</strong> ,即在头节点head前再增加一个虚拟节点，可以避免讨论 <strong>tag</strong> 节点是否是头节点的情况。最后统一返回 <strong>virtualNode-&gt;next</strong></p><ul><li>遍历链表找到值相等的节点</li><li>保留节点的前驱节点 <strong>prev</strong></li><li>前驱节点 <strong>prev</strong> 指向删除节点 <strong>tag</strong> 的下一节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteNode</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tag</span> =</span> head, * prev=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">virtualNode</span> =</span> (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    virtualNode-&gt;next = head;</span><br><span class="line">    virtualNode-&gt;val = <span class="number">-1</span>;</span><br><span class="line">    prev = virtualNode;</span><br><span class="line">    <span class="keyword">while</span> (tag-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">        prev = tag;</span><br><span class="line">        tag = tag-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = tag-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> virtualNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果理解递归很困难，可以采用一种叫做<strong>坚定信念</strong>的理解方式。即假设<strong>deleteNode返回的值就是对应节点的下一个节点</strong>，那下面这个java版的递归就不难理解了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611093444.png" alt="20210611093444"></p>]]></content>
    
    
    <summary type="html">删除链表节点</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>py如何根据字符串来创建对应的类</title>
    <link href="http://example.com/2021/06/11/py%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB/"/>
    <id>http://example.com/2021/06/11/py%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB/</id>
    <published>2021-06-11T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="py如何根据字符串来创建对应的类"><a href="#py如何根据字符串来创建对应的类" class="headerlink" title="py如何根据字符串来创建对应的类"></a>py如何根据字符串来创建对应的类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>py的反射原理，简单来说，反射就是能实现动态地调用方法\实例化对象。</p><p>举个例子:<br></p><p>创建一个学生类Student的对象 person1、创建一个老师类Teacher的对象person1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1 = Student(name=<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">person1 = Teacher(name=<span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure><p>试想一下，假如，你并不是先前(在写程序之前)就知道这个person1的身份到底是学生还是老师，那你该如何创建这个对象？</p><p>或者说你要 <strong>根据这个人的输入: 职业:老师,姓名:张三</strong> 来动态的创建对象。</p><p>这里就要用到py的反射</p><p>对应到web路由可能更容易理解。详细请看 <a href="https://www.liujiangblog.com/course/python/48">https://www.liujiangblog.com/course/python/48</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在本次实训的过程中，由于是基线检查，但是对于每个审查条目的规则(存储在数据库)是不一样的。</p><p>关键的是，所用的validator中预制的规则rule无法满足特定的需求。然后，除了使用他文档中的规则意外，我根据他自定义规则的写法，自定义如下三种规则</p><ul><li>AuditRule-判断前后集合是否一致</li><li>AuditRuleInclude-判断前面集合是否是后面集合的子集</li><li>AuditRuleSame-判断两个字符串是否相等。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuditRule</span>(<span class="params">Rule</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TestCode:</span></span><br><span class="line"><span class="string">        rules = &#123;&quot;age&quot;: AuditRule(&#x27;test,test&#x27;)&#125;</span></span><br><span class="line"><span class="string">        req = &#123;&quot;age&quot;: &#x27;test,test&#x27;&#125;</span></span><br><span class="line"><span class="string">        print(validate(req, rules,return_info=True))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, string: <span class="built_in">str</span></span>):</span></span><br><span class="line">        Rule.__init__(self)</span><br><span class="line">        self.string = string</span><br><span class="line">        self.value = string.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, arg: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> arg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            arg = <span class="string">&quot;Null&quot;</span></span><br><span class="line">            self.set_error(<span class="string">&quot;excepted get |&quot;</span> + self.string + <span class="string">&quot;| but get |&quot;</span> + arg.replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>) + <span class="string">&quot;|&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        exit_value_list = arg.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断两个集合是否一样  前面是否是后面的子集</span></span><br><span class="line">        self.set_error(<span class="string">&quot;excepted get |&quot;</span> + self.string + <span class="string">&quot;| but get |&quot;</span> + arg.replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>) + <span class="string">&quot;|&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(exit_value_list) == <span class="built_in">set</span>(self.value)</span><br></pre></td></tr></table></figure><p>其实，我所用的validator这个包，就已经利用了反射。因为他就是根据我输入的字符串，去动态地翻译和创建成对应的类。所以我也想实现根据数据库中存储的规则，来动态地创建。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611161640.png" alt="20210611161640"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="使用的函数"><a href="#使用的函数" class="headerlink" title="使用的函数"></a>使用的函数</h3><p>我就只用到了<strong>getattr</strong>函数。其对应的文档解释如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getattr</span>(<span class="params"><span class="built_in">object</span>, name, default=<span class="literal">None</span></span>):</span> <span class="comment"># known special case of getattr</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    getattr(object, name[, default]) -&gt; value</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Get a named attribute from an object; getattr(x, &#x27;y&#x27;) is equivalent to x.y.</span></span><br><span class="line"><span class="string">    When a default argument is given, it is returned when the attribute doesn&#x27;t</span></span><br><span class="line"><span class="string">    exist; without it, an exception is raised in that case.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ul><li><p>创建package rules 将自定义的三个类分别以.py的形式放进去</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162135.png" alt="20210611162135"></p></li><li><p>在package中创建rules.py的文件，将自定义类，导入。<strong>第一行不要也可以</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162237.png" alt="20210611162237"></p></li><li><p>在要使用的文件中，以<strong>from rules import rules as Custom</strong>的形式导入</p></li><li><p>编写相应的代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line"><span class="keyword">if</span> item[<span class="number">3</span>].startswith(<span class="string">&quot;Audit&quot;</span>):</span><br><span class="line">    rules[item[<span class="number">0</span>]] = <span class="built_in">getattr</span>(Custom, item[<span class="number">3</span>])(item[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    rules[item[<span class="number">0</span>]] = item[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + item[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>它对应的原理通过debug我猜测如下:<br>通过 <code>from rules import rules as Custom</code> 的方式其实是已经创建了<code>Custom</code>这个对象，其拥有三个自定义类的属性。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210611162753.png" alt="20210611162753"></p><p>然后通过<code>getattr</code>得到字符串对应的属性(类),并通过后面括号里面的字符串进行实例化。</p>]]></content>
    
    
    <summary type="html">根据字符串来创建对应的类</summary>
    
    
    
    <category term="反射" scheme="http://example.com/category/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="python" scheme="http://example.com/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode3-反转链表II</title>
    <link href="http://example.com/2021/06/10/leetcode3-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://example.com/2021/06/10/leetcode3-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</id>
    <published>2021-06-10T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<p>目录:</p><ul><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii">反转链表II</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li><li><a href="#%E4%BC%98%E7%A7%80%E6%80%9D%E8%B7%AF">优秀思路</a><ul><li><a href="#%E6%96%B9%E6%B3%951">方法1:</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">时间复杂度分析</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C">方法二</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">时间复杂度分析</a></li></ul></li></ul></li></ul></li></ul><h1 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a>反转链表II</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目为 n</span><br><span class="line">1 &lt;= n &lt;= 500</span><br><span class="line">-500 &lt;= Node.val &lt;= 500</span><br><span class="line">1 &lt;= left &lt;= right &lt;= n</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>左端节点不是起始节点</li></ol><ul><li>找到左端点的前一个节点 <strong>leftpointer_1</strong> + 左端点 <strong>leftpointer</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端点的前一个节点 <strong>leftpointer_1</strong> 的next指向右端点 </li><li><strong>返回 head 头节点</strong></li></ul><ol start="2"><li>左端节点是起始节点(head)</li></ol><ul><li>左端点的前一个节点 <strong>leftpointer_1</strong> 为 <strong>null</strong></li><li>反转从左端点开始的 <strong>righ-left</strong> 个节点,并保留右端点 <strong>prev</strong>、右端点的下一个节点 <strong>rightpointer_1</strong></li><li>左端节点 <strong>leftpointer</strong> 的next指向右端点的下一个节点 <strong>rightpointer_1</strong></li><li><strong>返回右端节点 <strong>prev</strong></strong></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">leftpointer_1</span>, * <span class="title">rightpointer_1</span>;</span></span><br><span class="line">    leftpointer_1 = rightpointer_1 = head;</span><br><span class="line">    <span class="keyword">int</span> leftmove = left - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> rigthmove = right - left;</span><br><span class="line">    <span class="keyword">int</span> temp = rigthmove;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="number">0</span> || temp &lt; <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (leftmove == <span class="number">-1</span>) leftpointer_1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (leftmove &gt; <span class="number">0</span> &amp;&amp; leftpointer_1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            leftpointer_1 = leftpointer_1-&gt;next;</span><br><span class="line">            leftmove--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> leftpointer_1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>, * <span class="title">leftpointer</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (leftpointer_1)     curr = leftpointer = leftpointer_1-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> curr = leftpointer = head;</span><br><span class="line">    <span class="keyword">while</span> (curr &amp;&amp; temp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">        temp--;</span><br><span class="line">        rightpointer_1 = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftpointer_1) &#123;</span><br><span class="line">        leftpointer_1-&gt;next = prev;</span><br><span class="line">        leftpointer-&gt;next = rightpointer_1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        leftpointer-&gt;next = rightpointer_1;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>与我们的方法非常类似，但在编码的过程中，采用了虚拟头节点的方式，避免了左端点是否是起始点的分类讨论。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610143526.png" alt="20210610143526"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyNode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = <span class="number">-1</span>;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> dummyNode;</span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rightNode</span> =</span> pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        rightNode = rightNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">leftNode</span> =</span> pre-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curr</span> =</span> rightNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rightNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre-&gt;next = rightNode;</span><br><span class="line">    leftNode-&gt;next = curr;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210610144049.png" alt="20210610144049"></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyNode</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = <span class="number">-1</span>;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> pre-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>时间复杂度 O(N) 其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。<br>空间复杂度 O(1) 只使用到常数个变量</p>]]></content>
    
    
    <summary type="html">反转链表II</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode2-反转链表</title>
    <link href="http://example.com/2021/06/08/leetcode2-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/06/08/leetcode2-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="literal">NULL</span></span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="literal">NULL</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= 节点个数 &lt;= <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>链表没有节点</li><li>链表只有一个节点</li><li>链表有两个节点</li><li>链表有三个及三个以上的节点</li></ol><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/%E7%94%A8ipad%E6%8A%8A%E6%80%9D%E8%B7%AF%E7%9A%84%E5%9B%BE%E7%94%BB%E5%9C%A8%E8%BF%99.png" alt="用ipad把思路的图画在这"></p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>由于只用遍历一遍链 <br><br>时间复杂度为<strong>O(n) n 为链表的长度</strong> <br><br>以上代码，<strong>分配的空间不会随着处理数据量的变化而变化，因此得到空间复杂度为 O空间复杂度为O(1</strong>)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>这次优秀思路其实跟我思路差不多，但是优秀思路的代码写的要更简洁。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210608172423.png" alt="20210608172423"></p><h2 id="我思路的代码"><a href="#我思路的代码" class="headerlink" title="我思路的代码"></a>我思路的代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* first,*second,*third;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 2个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        first = head;</span><br><span class="line">        second = head-&gt;next;</span><br><span class="line">        first-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        second-&gt;next = first;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3个以上的节点</span></span><br><span class="line">    first = head;</span><br><span class="line">    second = head-&gt;next;</span><br><span class="line">    third = head-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        second-&gt;next = first;</span><br><span class="line">        <span class="keyword">if</span> (third == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        first = second;</span><br><span class="line">        second = third;</span><br><span class="line">        third = third-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把第一个节点的next指向null</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">反转链表</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5-反向输出链表</title>
    <link href="http://example.com/2021/06/08/leetcode5-%E5%8F%8D%E5%90%91%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/06/08/leetcode5-%E5%8F%8D%E5%90%91%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反向输出链表"><a href="#反向输出链表" class="headerlink" title="反向输出链表"></a>反向输出链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>第一遍遍历找到一共的个数</li><li>malloc</li><li>倒序赋值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一遍遍历获取数目</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">-1</span>, num * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">        ret[num - i] = temp-&gt;val;</span><br><span class="line">        i++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = num;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 O(n)<br>空间复杂度 O(n)</p><h2 id="优秀思路"><a href="#优秀思路" class="headerlink" title="优秀思路"></a>优秀思路</h2><p>差不多跟我一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">q</span> =</span> head;</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        arr[i] = q-&gt;val;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">反向输出链表</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode6-判断链表中是否存在环</title>
    <link href="http://example.com/2021/06/08/leetcode6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF/"/>
    <id>http://example.com/2021/06/08/leetcode6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode6-判断链表中是否存在环"><a href="#leetcode6-判断链表中是否存在环" class="headerlink" title="leetcode6-判断链表中是否存在环"></a>leetcode6-判断链表中是否存在环</h1><p>这道题感觉很难嗷！ 但是确实是属于简单题的行列( 我是fw )，全程都在看解析。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点数。</p><ul><li><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p></li><li><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p></li></ul></li><li><p>空间复杂度：<code>O(1)</code> 我们只使用了两个指针的额外空间。</p></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p>重要的是哈希表的原理<br>知乎的文章： 具体还是你后面去看看相应的源码，会比较方便一些。</p><p><a href="https://zhuanlan.zhihu.com/p/144296454">https://zhuanlan.zhihu.com/p/144296454</a></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p></li><li><p>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p></li></ul>]]></content>
    
    
    <summary type="html">判断链表中是否存在环</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode7/8-找链表交点/合并有序链表</title>
    <link href="http://example.com/2021/06/08/leetcode78-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9+%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/06/08/leetcode78-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9+%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#leetcode7-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E7%82%B9">leetcode7-找链表交点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></li></ul></li></ul></li><li><a href="#leetcode8-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">leetcode8-合并有序链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a><ul><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1">复杂度分析</a></li></ul></li></ul></li></ul><h1 id="leetcode7-找链表交点"><a href="#leetcode7-找链表交点" class="headerlink" title="leetcode7-找链表交点"></a>leetcode7-找链表交点</h1><p>这个题目又没有好好审题，我以为的交点可以是这样的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113259.png" alt="20210615113259"></p><p>没想到交点以后的所有节点应该都是重合的！</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615113350.png" alt="20210615113350"></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果有相交的结点D的话,每条链的头结点先走完自己的链表长度,然后回头走另外的一条链表,那么两结点一定为相交于D点,因为这时每个头结点走的距离是一样的,都是 AD + BD + DC,而他们每次又都是前进1,所以距离相同,速度又相同,固然一定会在相同的时间走到相同的结点上,即D点。</p><ul><li><p>如果不相交 ： 如果不相交的话 假设两个链表长度不相等 一个为A 一个为B ，指针第一次走完A会去走B,另一个走完B再去走A，两个指针走的路程都是A+B。会同时为NULL 跳出循环</p></li><li><p>如果不相交且链表长度相等: 那么一个指针走A,一个指针走B，它俩同时走到NULL，相等，跳出循环</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">A</span>, * <span class="title">B</span>;</span></span><br><span class="line">    A = headA;</span><br><span class="line">    B = headB;</span><br><span class="line">    <span class="keyword">while</span>(A!=B)&#123;</span><br><span class="line">        A = A == <span class="literal">NULL</span> ? headB : A-&gt;next;</span><br><span class="line">        B = B == <span class="literal">NULL</span> ? headA : B-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(N)</code> 最差依次访问一遍 <code>A+B</code> 中的所有节点 <br><br>空间复杂度 <code>O(1)</code> 就用两个指针</p><h1 id="leetcode8-合并有序链表"><a href="#leetcode8-合并有序链表" class="headerlink" title="leetcode8-合并有序链表"></a>leetcode8-合并有序链表</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class="line"></span><br><span class="line">示例<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>leetcode的题解</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210615164632.png" alt="20210615164632"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span>, *<span class="title">b</span>,*<span class="title">c</span>,*<span class="title">d</span>;</span></span><br><span class="line">    a = l1;</span><br><span class="line">    b = l2;</span><br><span class="line">    d = c = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="keyword">while</span>(a&amp;&amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val &lt; b-&gt;val) &#123;</span><br><span class="line">            c-&gt;next = a;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">            c = c-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;val&gt;=b-&gt;val)&#123;</span><br><span class="line">            c-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            c = c-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>) c-&gt;next = b;</span><br><span class="line">    <span class="keyword">else</span> c-&gt;next = a;</span><br><span class="line">    <span class="keyword">return</span> d-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度 <code>O(M+N)</code> M为l1链表的长度 N为l2链表的长度 <br><br>空间复杂度 O(1)</p>]]></content>
    
    
    <summary type="html">找链表交点/合并有序链表</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>validator使用</title>
    <link href="http://example.com/2021/06/08/validator%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/06/08/validator%E4%BD%BF%E7%94%A8/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="validator使用"><a href="#validator使用" class="headerlink" title="validator使用"></a>validator使用</h1><p>看清楚使用的是哪个包，去找相应的文档就行。</p><p>我使用的是这个validator包 :<a href="https://github.com/CSenshi/Validator">https://github.com/CSenshi/Validator</a></p><p>网上的教程很多都是 <a href="https://github.com/mansam/validator.py%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E7%9C%8B%E4%BA%86%E6%96%87%E6%A1%A3%E5%92%8C%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8A%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E3%80%82">https://github.com/mansam/validator.py，所以在看了文档和源码之后，把使用方法整理一下。</a></p><p>本来是要整理一下，但是发现人家文档写的很清楚了。</p><p>链接：<a href="https://github.com/CSenshi/Validator">https://github.com/CSenshi/Validator</a></p>]]></content>
    
    
    <summary type="html">python validtor包的使用</summary>
    
    
    
    <category term="包使用" scheme="http://example.com/category/%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>实训day6-day10</title>
    <link href="http://example.com/2021/06/07/%E5%AE%9E%E8%AE%ADday6-10/"/>
    <id>http://example.com/2021/06/07/%E5%AE%9E%E8%AE%ADday6-10/</id>
    <published>2021-06-07T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h1><p>总体来说这一周相较于上一周来说没有学到太多东西，最有收获的还是初步地应用了一下反射，还有就是关于编码的简洁性。</p><p>诸如向安全组审核的东西，不过是读文件审核再写回数据库，可以说没有什么难度，只是工作的过程相对来说要繁琐一些，要去跟英文的文档做一个对应，复制粘贴本地安全组中的说明内容等等。</p><h1 id="circular-import"><a href="#circular-import" class="headerlink" title="circular import"></a>circular import</h1><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20210607095716.png" alt="20210607095716"></p><h1 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h1><p>RFC（Request For Comments）意即“请求评论”，包含了关于Internet的几乎所有重要的文字资料</p><h1 id="用户权限分配"><a href="#用户权限分配" class="headerlink" title="用户权限分配"></a>用户权限分配</h1><p>或者直接去微软的网站上面翻译：<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221963%28v%3dws.11%29">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221963%28v%3dws.11%29</a></p><h2 id="对应中文"><a href="#对应中文" class="headerlink" title="对应中文"></a>对应中文</h2><table><thead><tr><th>常量值</th><th>组策略</th></tr></thead><tbody><tr><td>SeNetworkLogonRight</td><td>从网络访问此计算机</td></tr><tr><td>SeBackupPrivilege</td><td>备份文件和目录</td></tr><tr><td>SeChangeNotifyPrivilege</td><td>绕过遍历检查</td></tr><tr><td>SeSystemtimePrivilege</td><td>更改系统时间</td></tr><tr><td>SeCreatePagefilePrivilege</td><td>创建一个页面文件</td></tr><tr><td>SeDebugPrivilege</td><td>调试程序</td></tr><tr><td>SeRemoteShutdownPrivilege</td><td>从远程系统强制关机</td></tr><tr><td>SeAuditPrivilege</td><td>管理审核安全日志</td></tr><tr><td>SeIncreaseQuotaPrivilege</td><td>信任计算机和用户帐户可以执行委派</td></tr><tr><td>SeIncreaseBasePriorityPrivilege</td><td>提高计划优先级</td></tr><tr><td>SeLoadDriverPrivilege</td><td>加载和卸载设备驱动程序</td></tr><tr><td>SeBatchLogonRight</td><td>作为批处理作业登录</td></tr><tr><td>SeServiceLogonRight</td><td>拒绝作为服务登录</td></tr><tr><td>SeInteractiveLogonRight</td><td>本地登录</td></tr><tr><td>SeSecurityPrivilege</td><td>管理审核和安全日志</td></tr><tr><td>SeSystemEnvironmentPrivilege</td><td>修改固件环境值</td></tr><tr><td>SeProfileSingleProcessPrivilege</td><td>配置文件单一进程</td></tr><tr><td>SeSystemProfilePrivilege</td><td>配置文件系统性能</td></tr><tr><td>SeAssignPrimaryTokenPrivilege</td><td>创建令牌对象</td></tr><tr><td>SeRestorePrivilege</td><td>还原文件和目录</td></tr><tr><td>SeShutdownPrivilege</td><td>关闭系统</td></tr><tr><td>SeTakeOwnershipPrivilege</td><td>取得文件或其他对象的所有权</td></tr><tr><td>SeUndockPrivilege</td><td>从扩展坞上移除计算机</td></tr><tr><td>SeManageVolumePrivilege</td><td>执行卷维护任务</td></tr><tr><td>SeRemoteInteractiveLogonRight</td><td>允许通过远程桌面服务登录</td></tr><tr><td>SeImpersonatePrivilege</td><td>身份验证后模拟客户端</td></tr><tr><td>SeCreateGlobalPrivilege</td><td>创建全局对象</td></tr><tr><td>SeIncreaseWorkingSetPrivilege</td><td>增加进程工作集</td></tr><tr><td>SeTimeZonePrivilege</td><td>更改时区</td></tr><tr><td>SeCreateSymbolicLinkPrivilege</td><td>创建符号链接</td></tr><tr><td>SeDelegateSessionUserImpersonatePrivilege</td><td>信任计算机和用户帐户可以执行委派</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">pyhon</summary>
    
    
    
    <category term="国信安实训" scheme="http://example.com/category/%E5%9B%BD%E4%BF%A1%E5%AE%89%E5%AE%9E%E8%AE%AD/"/>
    
    
    <category term="实训" scheme="http://example.com/tag/%E5%AE%9E%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1-单链表输出倒数第k个节点</title>
    <link href="http://example.com/2021/06/06/leetcode1-%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2021/06/06/leetcode1-%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2021-06-06T00:00:00.000Z</published>
    <updated>2021-06-15T08:58:48.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表输出倒数第k个节点"><a href="#单链表输出倒数第k个节点" class="headerlink" title="单链表输出倒数第k个节点"></a>单链表输出倒数第k个节点</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>遍历得到链表的节点个数</li><li>再根据节点个数和k得到目标节点的正向序号</li><li>遍历链表找到该节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="单链表版"><a href="#单链表版" class="headerlink" title="单链表版"></a>单链表版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        all++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    all = all + <span class="number">1</span>;<span class="comment">//加上最后一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = all - k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *ahead, *after, *head, *result, *temp;</span><br><span class="line">    ahead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    ahead-&gt;val = <span class="number">1</span>;</span><br><span class="line">    head = ahead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i=i+<span class="number">1</span>) &#123;</span><br><span class="line">        after = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        after-&gt;val = i + <span class="number">1</span>;</span><br><span class="line">        after-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ahead-&gt;next = after;</span><br><span class="line">        ahead = after;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        printf_s(<span class="string">&quot;%d-&gt;&quot;</span>, temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">            printf_s(<span class="string">&quot;\n%s&quot;</span>, <span class="string">&quot;跳出循环&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = getKthFromEnd(head, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (result-&gt;next) &#123;</span><br><span class="line">        printf_s(<span class="string">&quot;\n%d-&gt;%d&quot;</span>, result-&gt;val, result-&gt;next-&gt;val);<span class="comment">//这里有可能result没有next节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        printf_s(<span class="string">&quot;\n%d&quot;</span>, result-&gt;val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表版"><a href="#双链表版" class="headerlink" title="双链表版"></a>双链表版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表版</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span><span class="comment">//前向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">previous</span>;</span><span class="comment">//后向指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;previous;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* ahead, * after, * head, * result, * temp;</span><br><span class="line">    ahead = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    ahead-&gt;val = <span class="number">1</span>;</span><br><span class="line">    ahead-&gt;previous = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    head = ahead;</span><br><span class="line">    <span class="comment">//temp = ahead;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">        after = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        after-&gt;val = i + <span class="number">1</span>;</span><br><span class="line">        after-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        after-&gt;previous = ahead;</span><br><span class="line">        </span><br><span class="line">        ahead-&gt;next = after;</span><br><span class="line">        ahead = after;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        printf_s(<span class="string">&quot;%d-&gt;&quot;</span>, temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            printf_s(<span class="string">&quot;\n%s&quot;</span>, <span class="string">&quot;跳出循环&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = getKthFromEnd(head, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (result-&gt;next) &#123;</span><br><span class="line">        printf_s(<span class="string">&quot;\n%d-&gt;%d&quot;</span>, result-&gt;val, result-&gt;next-&gt;val);<span class="comment">//这里有可能result没有next节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printf_s(<span class="string">&quot;\n%d&quot;</span>, result-&gt;val);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优秀解题思路"><a href="#优秀解题思路" class="headerlink" title="优秀解题思路"></a>优秀解题思路</h2><ul><li>初始化两个指针a,b 指向头节点</li><li>b指针先往前走k个节点</li><li>a,b指针同时向前走，直到b为空指针</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span>, *<span class="title">cur</span>;</span></span><br><span class="line">    prev = head;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span>(k=k<span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">单链表输出倒数第k个节点</summary>
    
    
    
    <category term="链表" scheme="http://example.com/category/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tag/leetcode/"/>
    
  </entry>
  
</feed>
