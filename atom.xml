<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  <subtitle>永远热爱生活</subtitle>
  <link href="https://laobameishijia.github.io/atom.xml" rel="self"/>
  
  <link href="https://laobameishijia.github.io/"/>
  <updated>2022-03-16T10:16:03.788Z</updated>
  <id>https://laobameishijia.github.io/</id>
  
  <author>
    <name>老叭美食家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码修改.md</title>
    <link href="https://laobameishijia.github.io/2022/02/25/bi-she-fuzz-aflgo-yuan-ma-xiu-gai-1/"/>
    <id>https://laobameishijia.github.io/2022/02/25/bi-she-fuzz-aflgo-yuan-ma-xiu-gai-1/</id>
    <published>2022-02-25T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>最初就是把算法跑通了，然后也没有什么bug了。</p><blockquote><p><strong>效果可以说是惨不忍睹</strong>, 跑三个半小时，还不如AFLGo跑十几分钟。</p></blockquote><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220304205907.png" alt="1"></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>在fuzz_one中是有概率跳过代码的。我把这部分概率跳过的代码限制<strong>只在无差别探索阶段使用</strong>，效率提升了一些，但还远没有达到想要的效果。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220304210159.png" alt="2"></p><p>既然这样的话，我又想着，应该是把概率跳过的代码限制在 <strong>无差别探索阶段</strong> 和 <strong>短路径优先阶段</strong> 都使用才对。</p><blockquote><p>这样的效果也一般，跟上面的差不多。</p></blockquote><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>先从select_the_shortest开始优化,先优化寻找fuzz过的和没有fuzz过的。 </p><p>用新的指针 temp_queue_fuzzed在第一遍循环的时候，就找到的已经被fuzzed过的种子。</p><p>直接把所有的handle函数都更换了，顺便修改if语句的条件控制，尽量让条件尽可能的为真。–<strong>但是真并不意味着一定是你想要的</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220305112237.png" alt="3"></p><blockquote><p>longest和shortest_longest两个阶段运行的次数太少，速度也很慢。 尤其是那个trim阶段，stage execs后面那个数很大。会有700多或者是800多。</p></blockquote><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>鉴于，之前的算法非常慢。而且没有完全符合论文中的描述。所以我决定重新设计算法。</p><p>在算法的编写过程中，尤其是复用其他函数中的代码段时，总是会出现一些变量名忘记更改的问题。导致出现访问空指针的情况。(段错误)</p><p>还有，在加入队列(<code>add_to_queue</code>)的时候，对最大最小值进行判定没有问题。 可是我忽略了，在队列(<code>calibrate_case</code>)当中进行最大和最小值的更替。</p><p>我dnmd，速度上确实是快了一些，但是效率上咋变低了呢？</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220306142106.png" alt="4"></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>把论文中描述的在短路径优先阶段中，给予种子最大的能量给加进去了。效果依然不是很好。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220306153337.png" alt="5"></p><h3 id="验证crash"><a href="#验证crash" class="headerlink" title="验证crash"></a>验证crash</h3><p>pwndebug</p><p>即使是用正常的afl-fuzz跑出来的, 依然也只是有问题的输入样例。并不能产生像之前说的那种崩溃。 这种crash是如何计算的呢？</p><h3 id="下一步思路"><a href="#下一步思路" class="headerlink" title="下一步思路"></a>下一步思路</h3><p>下一步:</p><ul><li><p>继续优化短路径优先阶段。提高这个阶段的效率。</p></li><li><p>增加没有最短路径/最大基本块数的情况， 就是种子的值都还是-1的情况。</p></li><li><p>第二轮的效果，远远没有第一轮的效果好。</p></li></ul><p><strong>还有一个想法，我觉得我甚至可以把AFLGo的原理都写到毕业论文中。包括编译插桩是如何进行的，在运行的时候又是如何体现出来的。甚至包括forkserver与主进程之间的切换等等。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220313105014.png" alt="5.2"></p><blockquote><p>图片当中的54个crash甚至都是第一轮跑出来的。 想一想为什么第二轮的效果远远不如第一轮呢？</p></blockquote><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>把短路径优先阶段的概率跳过给删去，再试一试。 —-但是这个好像不解决，第二轮的问题呀！</p><p>在最长的路径里面挑选最短的，又是段错误，我不知道为什么？？</p><p>这样把，明天把时间管理的指针重新写一下。 尽量就是不要让他第一次就进入到第一个循环里面去。</p><h3 id="为什么queue-max-bb-和queue-min-distance-有的时候为空指针？"><a href="#为什么queue-max-bb-和queue-min-distance-有的时候为空指针？" class="headerlink" title="为什么queue_max_bb 和queue_min_distance 有的时候为空指针？"></a>为什么queue_max_bb 和queue_min_distance 有的时候为空指针？</h3><p>因为下面这些代码—**has_new_bits()**函数里面的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (*total_count &gt; 0) &#123;  cur_distance &#x3D; (double)(*total_distance) &#x2F; (double)(*total_count);  cur_bb &#x3D; (double)(*total_count);&#125;else&#123;  cur_distance &#x3D; -1.0;  cur_bb &#x3D; -1.0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看到只有在 <strong>total_count &gt; 0</strong> 的情况下，<code>cur_distance</code>和<code>cur_bb</code>的值才会更新。否则他们就一直是-1。</p></blockquote><p>而如果他们一直保持-1的值的话, 在calibrate_case()这个函数里面没有办法，更新 <code>queue_max_bb</code> 和 <code>queue_min_distance</code> 的指针 所以这两个指针就一直是空，就容易产生段错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (q-&gt;distance &lt;&#x3D; 0) &#123;  &#x2F;* This calculates cur_distance *&#x2F;  has_new_bits(virgin_bits);  q-&gt;distance &#x3D; cur_distance;  q-&gt;bb &#x3D; cur_bb;  if (cur_distance &gt; 0) &#123;    if (max_distance &lt;&#x3D; 0) &#123;      max_distance &#x3D; cur_distance;      min_distance &#x3D; cur_distance;      queue_min_distance &#x3D; q;    &#125;    if (cur_distance &gt; max_distance) max_distance &#x3D; cur_distance;    if (cur_distance &lt; min_distance) &#123; queue_min_distance &#x3D; q; min_distance &#x3D; cur_distance; &#125;  &#125;  if (cur_bb &gt; 0) &#123;      if (max_bb &lt;&#x3D; 0) &#123;          max_bb &#x3D; cur_bb;          min_bb &#x3D; cur_bb;          queue_max_bb &#x3D; q;      &#125;      if (cur_bb &gt; max_bb) &#123; queue_max_bb &#x3D; q; max_bb &#x3D; cur_bb; &#125;      if (cur_bb &lt; min_bb) min_bb &#x3D; cur_bb;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么问题就又来了，在什么情况下 <code>total_count</code> 的值会 <code>&gt;0</code> ? 这个问题恐怕要回到插桩代码中去了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (auto &amp;F : M) &#123;&#x2F;&#x2F;文件中的所有函数  int distance &#x3D; -1;  for (auto &amp;BB : F) &#123;&#x2F;&#x2F;函数中的所有基本块    distance &#x3D; -1;    if (is_aflgo) &#123;      &#x2F;*      这里获取每个基本块名字的方法和预处理阶段一样，取第一个有效指令的位置信息作为基本块名字      *&#x2F;      std::string bb_name;      for (auto &amp;I : BB) &#123;        std::string filename;        unsigned line;        getDebugLoc(&amp;I, filename, line);&#x2F;&#x2F;获取指令所在的文件名和行数        if (filename.empty() || line &#x3D;&#x3D; 0)          continue;        std::size_t found &#x3D; filename.find_last_of(&quot;&#x2F;\\&quot;);        if (found !&#x3D; std::string::npos)          filename &#x3D; filename.substr(found + 1);        bb_name &#x3D; filename + &quot;:&quot; + std::to_string(line);        break;      &#125;      if (!bb_name.empty()) &#123;        &#x2F;*         比较名字是否相同判断是否是需要插桩的基本块        *&#x2F;        if (find(basic_blocks.begin(), basic_blocks.end(), bb_name) &#x3D;&#x3D; basic_blocks.end()) &#123;          &#x2F;* 如果开启AFLGO_SELECTIVE选项，则不进入后面插桩的逻辑部分，即AFL的逻辑也只对AFLGo选择的基本块插桩           *&#x2F;          if (is_selective)            continue;        &#125; else &#123;          &#x2F;* Find distance for BB *&#x2F;          &#x2F;* 找到对应基本块的距离          *&#x2F;          if (AFL_R(100) &lt; dinst_ratio) &#123;            std::map&lt;std::string,int&gt;::iterator it;            for (it &#x3D; bb_to_dis.begin(); it !&#x3D; bb_to_dis.end(); ++it)              if (it-&gt;first.compare(bb_name) &#x3D;&#x3D; 0)                distance &#x3D; it-&gt;second;          &#125;        &#125;      &#125;    &#125;    &#x2F;* 进入插桩的逻辑部分，前面的部分是AFL的basicblock edge插桩逻辑    *&#x2F;    BasicBlock::iterator IP &#x3D; BB.getFirstInsertionPt();    IRBuilder&lt;&gt; IRB(&amp;(*IP));    if (AFL_R(100) &gt;&#x3D; inst_ratio) continue;    &#x2F;* Make up cur_loc *&#x2F;    unsigned int cur_loc &#x3D; AFL_R(MAP_SIZE);    ConstantInt *CurLoc &#x3D; ConstantInt::get(Int32Ty, cur_loc);    &#x2F;* Load prev_loc *&#x2F;    LoadInst *PrevLoc &#x3D; IRB.CreateLoad(AFLPrevLoc);    PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *PrevLocCasted &#x3D; IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());    &#x2F;* Load SHM pointer *&#x2F;    LoadInst *MapPtr &#x3D; IRB.CreateLoad(AFLMapPtr);    MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *MapPtrIdx &#x3D;        IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));    &#x2F;* Update bitmap *&#x2F;    LoadInst *Counter &#x3D; IRB.CreateLoad(MapPtrIdx);    Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    Value *Incr &#x3D; IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));    IRB.CreateStore(Incr, MapPtrIdx)       -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    &#x2F;* Set prev_loc to cur_loc &gt;&gt; 1 *&#x2F;    StoreInst *Store &#x3D;        IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);    Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));        &#x2F;*     下面是AFLGo的距离插桩部分，将该基本块的距离累加到MapDistLoc的位置上，再递增MapCntLoc位置的值，     即：MapDistLoc上的值表示seed经过所有的基本块的距离累加和，MapCntLoc上的值表示seed经过的基本块的数量。    *&#x2F;    if (distance &gt;&#x3D; 0) &#123;      ConstantInt *Distance &#x3D;          ConstantInt::get(LargestType, (unsigned) distance);      &#x2F;* Add distance to shm[MAPSIZE] *&#x2F;      Value *MapDistPtr &#x3D; IRB.CreateBitCast(          IRB.CreateGEP(MapPtr, MapDistLoc), LargestType-&gt;getPointerTo());      LoadInst *MapDist &#x3D; IRB.CreateLoad(MapDistPtr);      MapDist-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      Value *IncrDist &#x3D; IRB.CreateAdd(MapDist, Distance);      IRB.CreateStore(IncrDist, MapDistPtr)          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      &#x2F;* Increase count at shm[MAPSIZE + (4 or 8)] *&#x2F;      Value *MapCntPtr &#x3D; IRB.CreateBitCast(          IRB.CreateGEP(MapPtr, MapCntLoc), LargestType-&gt;getPointerTo());      LoadInst *MapCnt &#x3D; IRB.CreateLoad(MapCntPtr);      MapCnt-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));      Value *IncrCnt &#x3D; IRB.CreateAdd(MapCnt, One);      IRB.CreateStore(IncrCnt, MapCntPtr)          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));    &#125;    inst_blocks++;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>那如果total_count 的值为零的话，是不是说明这个种子压根就没有进入到程序中去?</p></blockquote><p>我又尝试了一下对libxml2的调试, 因为对这个库进行fuzz的时候，种子是仓库中包含的。与预期的符合，可以看出<code>distance</code>和<code>bb</code>都是有值的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220316111631.png" alt="调试libxml2"></p><hr><p><strong>解决方案就是, 当你在使用这两个指针的时候，记得判断一下是否为空。</strong></p><p>如果都为空的话，直接返回上一个被选中的种子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;效率提升&quot;&gt;&lt;a href=&quot;#效率提升&quot; class=&quot;headerlink&quot; title=&quot;效率提升&quot;&gt;&lt;/a&gt;效率提升&lt;/h1&gt;&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-5</title>
    <link href="https://laobameishijia.github.io/2022/02/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-5/"/>
    <id>https://laobameishijia.github.io/2022/02/21/bi-she-fuzz-aflgo-yuan-ma-yue-du-5/</id>
    <published>2022-02-21T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFLGo源码阅读"><a href="#AFLGo源码阅读" class="headerlink" title="AFLGo源码阅读"></a>AFLGo源码阅读</h1><ul><li><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">AFLGo源码阅读</a><ul><li><a href="#%E6%8C%89%E7%85%A7main%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F">按照Main函数中的顺序</a><ul><li><a href="#setup_signal_handlers">setup_signal_handlers</a></li><li><a href="#check_asan_opts">check_asan_opts()</a></li><li><a href="#fix_up_sync--%E4%B8%8D%E7%9F%A5%E9%81%93%E5%85%B7%E4%BD%93%E7%94%A8%E9%80%94">fix_up_sync()–不知道具体用途</a></li><li><a href="#save_cmdlineargc-argv">save_cmdline(argc, argv)</a></li><li><a href="#fix_up_bannerargvoptind">fix_up_banner(argv[optind])</a></li><li><a href="#check_if_tty">check_if_tty()</a></li><li><a href="#get_core_count">get_core_count()</a></li><li><a href="#bind_to_free_cpu">bind_to_free_cpu()</a></li><li><a href="#check_crash_handling">check_crash_handling()</a></li><li><a href="#check_cpu_governor">check_cpu_governor()</a></li><li><a href="#setup_post">setup_post()</a></li><li><a href="#setup_shm">setup_shm()</a></li><li><a href="#init_count_class16">init_count_class16()</a></li><li><a href="#setup_dirs_fds">setup_dirs_fds()</a></li><li><a href="#read_testcases">read_testcases()</a></li><li><a href="#load_auto">load_auto()</a></li><li><a href="#pivot_inputs">pivot_inputs()</a><ul><li><a href="#c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86">C语言知识</a></li></ul></li><li><a href="#load_extras">load_extras()</a></li><li><a href="#find_timeout">find_timeout()</a></li><li><a href="#detect_file_args">detect_file_args()</a><ul><li><a href="#c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86-1">C语言知识</a></li></ul></li><li><a href="#setup_stdio_file">setup_stdio_file()</a></li><li><a href="#check_binary">check_binary()</a></li><li><a href="#get_qemu_argv">get_qemu_argv()</a></li><li><a href="#perform_dry_run">perform_dry_run()</a><ul><li><a href="#calibrate_case">calibrate_case()</a><ul><li><a href="#count_bytes">count_bytes()</a></li><li><a href="#update_bitmap_score">update_bitmap_score()</a></li><li><a href="#minimize_bits">minimize_bits()</a></li></ul></li></ul></li><li><a href="#cull_queue">cull_queue()</a><ul><li><a href="#mark_as_redundant">mark_as_redundant</a></li></ul></li><li><a href="#show_init_stats">show_init_stats()</a></li><li><a href="#find_start_position">find_start_position()</a></li><li><a href="#write_stats_file">write_stats_file()</a></li><li><a href="#save_auto">save_auto()</a></li><li><a href="#fuzz_one--while%E5%BE%AA%E7%8E%AF">fuzz_one &amp;&amp; while循环</a><ul><li><a href="#calculate_score">calculate_score()</a></li><li><a href="#common_fuzz_stuff">common_fuzz_stuff()</a></li><li><a href="#run_target">run_target()</a><ul><li><a href="#c-%E7%9F%A5%E8%AF%86">C 知识</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a></li><li><a href="#setitimer">setitimer</a></li></ul></li></ul></li><li><a href="#save_if_interesting">save_if_interesting</a></li></ul></li><li><a href="#write_bitmap">write_bitmap()</a></li><li><a href="#write_stats_file-1">write_stats_file()</a></li><li><a href="#stop_fuzzing">stop_fuzzing:</a></li></ul></li><li><a href="#aflgo%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0">AFLgo命令行启动参数</a></li><li><a href="#linux%E5%91%BD%E4%BB%A4">Linux命令</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h2 id="按照Main函数中的顺序"><a href="#按照Main函数中的顺序" class="headerlink" title="按照Main函数中的顺序"></a>按照Main函数中的顺序</h2><h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>初始化各种信号量</p><p>终止进程的、超时的等等</p><h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts()"></a>check_asan_opts()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>通过检查环境变量中的值来判断–检查ASAN设置</p><h3 id="fix-up-sync-–不知道具体用途"><a href="#fix-up-sync-–不知道具体用途" class="headerlink" title="fix_up_sync()–不知道具体用途"></a>fix_up_sync()–不知道具体用途</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>没理解</p><h3 id="save-cmdline-argc-argv"><a href="#save-cmdline-argc-argv" class="headerlink" title="save_cmdline(argc, argv)"></a>save_cmdline(argc, argv)</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>用<code>orig_cmdline</code>保存复制当前命令行</p><h3 id="fix-up-banner-argv-optind"><a href="#fix-up-banner-argv-optind" class="headerlink" title="fix_up_banner(argv[optind])"></a>fix_up_banner(argv[optind])</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>根据最后一个参数设置标头(banner)?</p><h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty()"></a>check_if_tty()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>检查是不是在终端运行</p><h3 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count()"></a>get_core_count()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>从系统文件中获取cpu核的相关信息</p><h3 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu()"></a>bind_to_free_cpu()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把进程绑定在具体的内核上？</p><h3 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling()"></a>check_crash_handling()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>保证core dumps不会进入程序, 否则会增加将崩溃信息通过waitpid传递给fuzzer的延迟。</p><h3 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor()"></a>check_cpu_governor()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>要把CPU频率调节的算法(可能忽视fuzz产生的短进程)关了，以提高aflgo-fuzz的效率。</p><h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post()"></a>setup_post()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>不理解</p><h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm()"></a>setup_shm()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>配置共享内存和<code>virgin_bits</code>, 并且将共享内存的首地址赋值给<code>trace_bits</code>.</p><h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16()"></a>init_count_class16()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>之所以用左移是为了加快速度</p><p>最终初始化是下面这个样子。16位一个<br>        0-0 ….      128-0  -256个元素   :0-1-2-4-8-16-32-64-128<br>      ⬇ 0-1 ….<br>        0-2 ….<br>        0-2 ….<br>        0-4 ….<br>        0-4 ….<br>        ………….<br>        0-128….    128-128         一共 65536个 16bit</p><h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds()"></a>setup_dirs_fds()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ol><li><p>flock 了 out_dir_fd</p></li><li><p>创建了跟下面有关的目录</p><ul><li>queue </li><li>crashes</li><li>hangs<br>…. </li></ul></li><li><p>还创建其他的fd(/dev/null&amp;/dev/urandom)方便后续使用</p></li></ol><h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases()"></a>read_testcases()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>从<code>input directory</code>中读取所有的测试用例，检测测试用例的大小，以及是否已经完成了<code>deterministic fuzzing</code>阶段，然后添加到queue中。</p><p>初始化</p><ul><li>queued_at_start  Total number of initial inputs</li><li>last_path_time   Time for most recent path (ms)</li></ul><h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto()"></a>load_auto()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>加载自动生成的附加组件</p><h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs()"></a>pivot_inputs()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ul><li>首先检查是不是之前跑过的<ul><li>如果是的话，看一下id是不是一致。<ul><li>id一致, 要改变对应entry的depth</li></ul></li><li>如果不是，就起新名字 <code>id:%06u,orig:%s</code></li><li>然后就是重新命名文件，并且更改<code>q-&gt;fname=nfn</code></li></ul></li></ul><h4 id="C语言知识"><a href="#C语言知识" class="headerlink" title="C语言知识"></a>C语言知识</h4><p>strrchr和strchr类似，但是从右向左找字符c，找到字符c第一次出现的位置就返回，函数名中间多了一个字母r可以理解为Right-to-left。</p><h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras()"></a>load_extras()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>这个没看懂是干啥的。<br>跟这些有关，但是不知道具体在fuzz的过程中起到了什么作用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct extra_data &#123;  u8* data;                           &#x2F;* Dictionary token data            *&#x2F;  u32 len;                            &#x2F;* Dictionary token length          *&#x2F;  u32 hit_cnt;                        &#x2F;* Use count in the corpus          *&#x2F;&#125;;static struct extra_data* extras;     &#x2F;* Extra tokens to fuzz with        *&#x2F;static u32 extras_cnt;                &#x2F;* Total number of tokens read      *&#x2F;static struct extra_data* a_extras;   &#x2F;* Automatically selected extras    *&#x2F;static u32 a_extras_cnt;              &#x2F;* Total number of tokens available *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout()"></a>find_timeout()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>只有在Resuming an older fuzzing job的情况下，才会使用。</p><p>从状态目录中读取文件名, 并把<code>exec_timeout :</code>后面的值复制给<code>exec_tmout</code>, 将timeout_given赋值为3.</p><h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args()"></a>detect_file_args()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>根据参数@@后面带的东西，更改文件名. 看的也不是很懂。</p><h4 id="C语言知识-1"><a href="#C语言知识-1" class="headerlink" title="C语言知识"></a>C语言知识</h4><p>定义函数：char * getcwd(char * buf, size_t size);</p><p>函数说明：getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。</p><p>注：<br>1、在调用此函数时，buf 所指的内存空间要足够大。若工作目录绝对路径的字符串长度超过参数size 大小，则返回NULL，errno 的值则为ERANGE。<br>2、倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进程可以在使用完次字符串后利用free()来释放此空间。</p><h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file()"></a>setup_stdio_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>如果没有用-f指定输出文件的话, 那就用默认的<code>.cur_input</code>创建</p><h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary()"></a>check_binary()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>具体代码没看。。</p><p>检查目标二进制文件是否存在，以及它是否是shell脚本。确保可以进行afl的插桩。</p><h3 id="get-qemu-argv"><a href="#get-qemu-argv" class="headerlink" title="get_qemu_argv()"></a>get_qemu_argv()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>不知道干啥的</p><h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run()"></a>perform_dry_run()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>简单的把所有的测试用例都提前运行一遍，确保程序像预期的那样运行。如果不是的话，会有一些相应的提示。</p><h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case()"></a>calibrate_case()</h4><p>测试一个entry，看看是不是有覆盖率、新的路径的添加等等变量是否正常工作啥的。 </p><p>这里会运行<code>run_target</code>来计算<code>distance</code>, 这是对已经加入队列的entry而言的。</p><p>关于<code>entry</code>属性里面的<code>var_behavior</code>的理解: 因为在<code>calibrate</code>的阶段中，是没有发生变异的，那么如果测试用例在经过不同次数的执行后，产生了不一样的<code>path</code>。那么就把这个<code>entry</code>标记为<code>variable</code>。<strong>这个属性并没有影响到后续的其他步骤</strong>。根据注释，应该只是简单的标注，方便能找到吧。</p><h5 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes()"></a>count_bytes()</h5><p>数一下有多少个字节不为零, 8位代表一个path, 不同的命中次数可能会导致8位中不同位置的bit置1</p><h5 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score()"></a>update_bitmap_score()</h5><p>当某个entry触发了新的path, 我们要与之前的同样触发这个path的”最优”的entry进行一个比较。看看到底谁更优秀。</p><p>所谓的<code>top_rated[]</code> 就是 <code>a minimal set of paths that trigger all the bits seen in the bitmap so far.</code></p><h5 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits()"></a>minimize_bits()</h5><p>把<code>trace_bits</code>压缩为一个占用空间更小的数组。1位代表一个<code>path</code>现在。所以刚好是分配了<code>MAP_SIZE&gt;&gt;3</code>的空间。</p><h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p><code>top_rated[i]</code> 代表的就是发现路径序号为i的最优entry(fav_factor最小的) 而且<strong>关键的是top_rated[i] 指针指向的是queue中的特定的entry</strong>。所以在将<code>top_rated[i]-&gt;favored = 1 </code>时，原来<code>queue</code>中的<code>entry</code>的<code>favored</code>也同样被设置为1</p><p>值得注意的是，并不是说<code>top_rated[]</code>中所有的<code>entry</code>都是<code>favored</code>的。当且仅当你发现的<code>path</code>是你之前<code>entry</code>都没有发现过的情况下，这个<code>entry</code>才会被设置为<code>favored</code></p><blockquote><p>我觉得这里有个值得深思的地方，程序这样设计的话，test_case的顺序会影响到其是否会被设置为favored. 这种随机性会不会对框架整体的性能产生一定的影响。</p></blockquote><h4 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h4><p>把对应的<code>entry</code>标记为<code>redundant</code>，其间还会创建一些目录，至于什么作用没看懂。</p><h3 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats()"></a>show_init_stats()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>显示统计数据 Total calibration cycles\max_bits\min_bits\exec_us\len等等</p><p>根据平均运行时间重新设置一个<code>timeout_given</code></p><h3 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position()"></a>find_start_position()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>当要恢复程序进程的时候，从<code>fuzzer_stats</code>目录的文件的文件名中读取相应的位置。</p><h3 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file()"></a>write_stats_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把用到的基本状态信息都写入到状态文件中，这些变量都会在终端页面显示中用到。</p><h3 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto()"></a>save_auto()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>自动保存生成的extras，这个跟token有关系，但没看懂token到底有什么作用。</p><h3 id="fuzz-one-amp-amp-while循环"><a href="#fuzz-one-amp-amp-while循环" class="headerlink" title="fuzz_one &amp;&amp; while循环"></a>fuzz_one &amp;&amp; while循环</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>接下来是循环中的函数</p><ul><li><p>首先在进入循环之前, 要先cull_queue, 把favor的entry标记出来</p></li><li><p>判断queue_cur是否为空</p><ul><li>如果为空的话，说明是第一次进入循环。进行必要的初始化。</li></ul></li><li><p>然后就是fuzz_one</p><ul><li>判断在当下的队列中，是否含有 <code>favored\non-fuzzed</code> 的<code>entry</code>，如果有那么会<strong>以99%的概率跳过那些已经被fuzz过或者不是favored</strong>的<code>entry</code>.</li><li>如果没有上面所说的那种类型的<code>entry</code> 会以75%跳过not fuzzed ，以95%跳过fuzzed的<code>entry</code>。 </li><li>然后将test case中的内容映射到内存中，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针来做而不需要<code>read</code>\<code>write</code>函数。</li><li>如果最初的calibration阶段失败了, 那现在要重新来一遍。</li><li><code>trimming</code>阶段，<strong>这个阶段的作用，没看懂</strong>。 不明白为什么这个函数会调用run_taget</li><li>计算entry分数</li><li>看看是否要跳过<code>deterministic</code>变异阶段<ul><li>如果skip_deterministic设置为1、或者entry fuzzed或者entry-&gt;passed_det设置为1)</li><li>如果执行路径校验将其置于该主实例的范围之外，则跳过确定性模糊处理。</li></ul></li><li>按照以下阶段进行变异 <ul><li>simple bitflip</li><li>arithmetic</li><li>interst</li><li>dictionary</li><li>havoc</li><li>splice<blockquote><p>当然在这些变异阶段中, 大多都是每变异一次就进行<code>common_fuzz_stuff</code>。 还有很多为了保证程序效率(比如: 当变异出现的结果在之前的变异阶段已经被运行过的时候可以跳过、当对于某个字节的变异没有出现效果，那在以后的变异阶段就不会变异该字节了-相当于认为该字节对于提高程序效果没有太大的意义)<br>还有<code>common_fuzz_stuff</code>阶段产生出来的<em>新的变异enrty</em>会根据<code>save_if_interetring</code>函数来决定是否加入到队列中。加入队列的方式是<strong>尾插法！</strong>只不过把刚刚添加进队列的<code>entry</code>看作是<code>queue_top</code></p></blockquote></li></ul></li></ul><p>循环结束后，回对sync_fuzzer进行一个操作，这个可以后面再看。</p></li></ul><h4 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score()"></a>calculate_score()</h4><p>计算得分,跟得分有关的因素</p><ul><li><code>exec_us</code> 和<code>avg_execc_us</code>的大小关系, <code>exec_us</code>相对越小, 得分肯定就越高</li><li><code>bitmap_size</code>(发现的路径数) 和 <code>avg_bitmap_size</code>大小关系, <code>bitmap_size</code>相对越高, 得分越高</li><li><code>handicap</code> 某个<code>testcase</code>可能是在程序运行的末尾才发现, 然后被添加到队列中。而这个时候，队列中前面的<code>entry</code>很有可能已经运行了很多<code>cycle</code>. 所以，这部分<strong>后来添加到队列中</strong>的<code>entry</code>得分更高。</li><li><code>depth</code> 原文 <em>under the assumption that fuzzing deeper test cases is more likely to reveal stuff that can’t be discovered with traditional fuzzers.</em> <code>depth</code>的值越大，得分也就越高。也就是说, 一些变异的<code>entry</code>较大可能会是后面才添加进来的。所以假设越往后添加进来的越高。<strong>这个要跟上面的handicap相区别，depth反映的是队列中的entry数量, handicap是整体队列变异的cycle</strong></li><li><code>cooling_schedule</code> 基于距离的模拟退火算法, 距离越近的随着时间的推移, <code>power_factor</code>会越来越高. 相对应的得分也就越高. <code>perf_score *= power_factor</code> </li></ul><blockquote><p>具体的得分，跟确定性变异阶段的时间没有关系，得分越高，随机性变异阶段的时间也就越长。</p></blockquote><h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff()"></a>common_fuzz_stuff()</h4><p>把经过变异修改的文件重新写入testcase, 然后在进行<code>run_target()</code>。接着运行<code>save_if_interesting()</code>判断是否对变异的testcase进行统计或者其他操作</p><h4 id="run-target"><a href="#run-target" class="headerlink" title="run_target()"></a>run_target()</h4><ul><li>第一种情况: 独自运行exec, 等待子进程结束</li><li>第二种情况: 通过管道和forkserver通信，forkserver fork出一个子进程进行fuzz，将子进程的状态写入通道。 父进程再通过通道中的信息, 对程序状态进行返回。<strong>当然在子进程进行fuzz的过程中 trace_bits会发生更新</strong></li></ul><h5 id="C-知识"><a href="#C-知识" class="headerlink" title="C 知识"></a>C 知识</h5><h6 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h6><ul><li>WIFSIGNALED(status)为非0 表明进程异常终止 <strong>用来判断crash</strong></li><li>WIFSTOPPED(status)为非0 表明进程处于暂停状态 <strong>用来判断fork server是否正常进行, 此时因为fork server是处于循环当中，所以对应的状态是处于暂停。</strong></li><li>WTERMSIG(status) 获取程序退出的信号(比如:<code>SIGKILL</code>)</li></ul><h6 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h6><p>关于这个，详细的内容网上都有。 但是没搞清楚这个时间定时到底是阻塞的还是非阻塞的。？？</p><h4 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h4><p>看一下当前的testcase是否触发了新的路径, 如果触发了新的路径，需要把这个testcase添加到当前的队列里面。并且要在queue中以<code>(&quot;%s/queue/id:%06u,%llu,%s&quot;, out_dir, queued_paths, get_cur_time() - start_time ,describe_op(hnb))</code>这样的形式命名。</p><p>根据<code>run_target()</code>的返回值，处理timeout、crash、error的情况</p><h3 id="write-bitmap"><a href="#write-bitmap" class="headerlink" title="write_bitmap()"></a>write_bitmap()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>把当前共享内存中的bitmap写到文件中去</p><h3 id="write-stats-file-1"><a href="#write-stats-file-1" class="headerlink" title="write_stats_file()"></a>write_stats_file()</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>更新状态文件中的数据</p><h3 id="stop-fuzzing"><a href="#stop-fuzzing" class="headerlink" title="stop_fuzzing:"></a>stop_fuzzing:</h3><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><p>程序的终止是需要用户自己按下<code>ctrl+c</code> 循环不会自己退出</p><p>对占有的内存空间进行释放, 退出程序</p><h2 id="AFLgo命令行启动参数"><a href="#AFLgo命令行启动参数" class="headerlink" title="AFLgo命令行启动参数"></a>AFLgo命令行启动参数</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>i</td><td>输入目录</td></tr><tr><td>o</td><td>输出目录</td></tr><tr><td>M</td><td>master sync ID</td></tr><tr><td>S</td><td>master sync ID</td></tr><tr><td>f</td><td>目标文件</td></tr><tr><td>x</td><td>字典目录</td></tr><tr><td>t</td><td>超时时间设定</td></tr><tr><td>m</td><td>内存限制</td></tr><tr><td>d</td><td>是否跳过确定性变异阶段</td></tr><tr><td>B</td><td>加载bitmap</td></tr><tr><td>C</td><td>Crash模式</td></tr><tr><td>T</td><td>banner</td></tr><tr><td>Q</td><td>QEMU模式</td></tr><tr><td>z</td><td>模拟退火算法选定</td></tr><tr><td>c</td><td>退火算法的运行时间</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Required parameters:  -i <span class="token function">dir</span>        - input directory with <span class="token builtin class-name">test</span> cases  -o <span class="token function">dir</span>        - output directory <span class="token keyword">for</span> fuzzer findingsDirected fuzzing specific settings:  -z schedule   - temperature-based power schedules                  <span class="token punctuation">&#123;</span>exp, log, lin, quad<span class="token punctuation">&#125;</span> <span class="token punctuation">(</span>Default: exp<span class="token punctuation">)</span>  -c min        - <span class="token function">time</span> from start when SA enters exploitation                  <span class="token keyword">in</span> secs <span class="token punctuation">(</span>s<span class="token punctuation">)</span>, mins <span class="token punctuation">(</span>m<span class="token punctuation">)</span>, hrs <span class="token punctuation">(</span>h<span class="token punctuation">)</span>, or days <span class="token punctuation">(</span>d<span class="token punctuation">)</span>Execution control settings:  -f <span class="token function">file</span>       - location <span class="token builtin class-name">read</span> by the fuzzed program <span class="token punctuation">(</span>stdin<span class="token punctuation">)</span>  -t msec       - <span class="token function">timeout</span> <span class="token keyword">for</span> each run <span class="token punctuation">(</span>auto-scaled, <span class="token number">50</span>-1000 ms<span class="token punctuation">)</span>  -m megs       - memory limit <span class="token keyword">for</span> child process <span class="token punctuation">(</span><span class="token number">50</span> MB<span class="token punctuation">)</span>  -Q            - use binary-only instrumentation <span class="token punctuation">(</span>QEMU mode<span class="token punctuation">)</span>Fuzzing behavior settings:  -d            - quick <span class="token operator">&amp;</span> dirty mode <span class="token punctuation">(</span>skips deterministic steps<span class="token punctuation">)</span>  -n            - fuzz without instrumentation <span class="token punctuation">(</span>dumb mode<span class="token punctuation">)</span>  -x <span class="token function">dir</span>        - optional fuzzer dictionary <span class="token punctuation">(</span>see README<span class="token punctuation">)</span>Other stuff:  -T text       - text banner to show on the <span class="token function">screen</span>  -M / -S <span class="token function">id</span>    - distributed mode <span class="token punctuation">(</span>see parallel_fuzzing.txt<span class="token punctuation">)</span>  -C            - crash exploration mode <span class="token punctuation">(</span>the peruvian rabbit thing<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ul><li><p><strong>export</strong></p><p>为shell变量或函数设置导出属性。它们会成为环境变量, 可以在脚本中访问它们，尤其是脚本中调用的子进程需要时。</p></li><li><p><strong>echo</strong></p><p>echo命令 用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。</p></li><li><p><strong>mkdir</strong></p><p>创建目录</p></li><li><p><strong>cat</strong></p><p>连接多个文件并打印到标准输出</p></li><li><p><strong>cut</strong></p><p>cut命令用来显示行中的指定部分，删除文件中指定字段。说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数 file 所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如cut fl f2 &gt; f3将把文件 fl 和 f2 的内容合并起来，然后通过输出重定向符“&gt;”的作用，将它们放入文件 f3 中。</p></li><li><p><strong>rev</strong></p><p>将文件内容以字符为单位反序输出—也就是每行的字符都到过来</p></li><li><p><strong>cp</strong></p><p>将源文件或目录复制到目标文件或目录中</p></li><li><p><strong>pushd&amp;&amp;popd</strong></p><p>倒可以简单地把这个命令理解为切换/再换回来目录的命令。</p></li><li><p><strong>chmod</strong></p><p>用来变更文件或目录的权限</p></li><li><p><strong>mv</strong></p><p>mv命令 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="#aflgo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">回到目录</a></p><ol><li><a href="http://rk700.github.io/2018/01/04/afl-mutations/">http://rk700.github.io/2018/01/04/afl-mutations/</a></li><li><a href="https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90">https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90</a></li><li><a href="https://paper.seebug.org/496/#_2">https://paper.seebug.org/496/#_2</a></li><li><a href="https://bbs.pediy.com/thread-265936.htm#msg_header_h1_2">https://bbs.pediy.com/thread-265936.htm#msg_header_h1_2</a>  </li><li><a href="https://paper.seebug.org/1732/#afl-afl-asc">https://paper.seebug.org/1732/#afl-afl-asc</a></li><li><a href="https://www.anquanke.com/post/id/250540#h2-5">https://www.anquanke.com/post/id/250540#h2-5</a></li><li><a href="https://linux.cmsblogs.cn/">https://linux.cmsblogs.cn/</a>    —-查询linux命令的网站</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFLGo源码阅读&quot;&gt;&lt;a href=&quot;#AFLGo源码阅读&quot; class=&quot;headerlink&quot; title=&quot;AFLGo源码阅读&quot;&gt;&lt;/a&gt;AFLGo源码阅读&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#aflgo%E6%BA%90%E7%A0%81%E9</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>中国政府与经济发展</title>
    <link href="https://laobameishijia.github.io/2022/01/20/zhong-guo-zheng-fu-yu-jing-ji-fa-zhan/"/>
    <id>https://laobameishijia.github.io/2022/01/20/zhong-guo-zheng-fu-yu-jing-ji-fa-zhan/</id>
    <published>2022-01-20T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中国政府与经济发展"><a href="#中国政府与经济发展" class="headerlink" title="中国政府与经济发展"></a>中国政府与经济发展</h1><p>探究中国经济的发展，不能割裂开政府的作用。因为在我国，政府不但影响蛋糕的分配，也参与蛋糕的生产。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220120193437.png" alt="财税与政府行为"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220123192820.png" alt="土地财政与土地金融"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="关于债务到底在中国经济发展中起到了什么作用？"><a href="#关于债务到底在中国经济发展中起到了什么作用？" class="headerlink" title="关于债务到底在中国经济发展中起到了什么作用？"></a>关于债务到底在中国经济发展中起到了什么作用？</h3><p>举个例子，假如说</p><ul><li>A用100买了B的某个产品</li><li>B用这100支付给了C作为孩子上学的学费</li><li>C又用100发给了A作为工资</li></ul><p>那在这个过程中，经济发展了吗？</p><p>再比如</p><ul><li>A用100买了B的某个产品</li><li>B用这100支付给了C, 因为B之前欠C 100</li><li>C又用100发给了A作为工资</li></ul><p>在这个过程中，流通的钱还是100, 但是B已经还清了自己的债务。那这个过程中经济发展了吗？</p><blockquote><p>我觉得从自己举出的这个例子中，并不是很能看出过程中是否有社会财富的积累。</p></blockquote><hr><p>关于债务在经济发展中的作用，我在知乎上找到了一个非常形象的描述。</p><p>作者的主页 <a href="https://www.zhihu.com/people/he-jia-lei-80">https://www.zhihu.com/people/he-jia-lei-80</a></p><p><strong>现代世界经济发展，主要是靠债务驱动，通过扩大信贷来扩大整个市场。</strong></p><p>怎么理解这句话呢？我们回过头看看贵金属货币时期，社会的经济规模直接取决于贵金属的总量，想想看，本来有一块地方，有丰富的资源，但因为没有足够的贵金属货币，所以只能晾在那，贵金属的开采量限制了经济的发展。</p><p>后来犹太人就发明了债务货币化，简单来讲就是以贵金属货币或贵金属本位纸币为锚，利用存款派生来撬动整个市场规模，我就直接拿现代的例子来解释说明吧：现在有个菜农，还有一个建筑师，菜农想要请建筑师建一个房子，需要100万元，但菜农没那么多钱于是找银行申请贷款，贷款了100万通过电子转账给建筑师，这时候银行并不需要真的用到100万的现金，只需要在账户上操作下，这时候建筑师的电子账户瞬间多了100万，于是他给菜农建了一套房子，而菜农接下来的30年时间为了还款，于是不停的种菜卖菜，而建筑师因为有了100万的收入于是每天都找菜农买菜（也是通过电子转账），30年过后，债务还清了。</p><p>而这债务从发生到消亡的过程，社会上多了一个价值100万的房子，跟总值100万的菜，总共200万的产值（GDP），数倍于债务本身的产值。</p><h4 id="经济发展"><a href="#经济发展" class="headerlink" title="经济发展"></a>经济发展</h4><p>就当代经济而言，发展的含义相当丰富复杂。发展总是与发达、与工业化、与现代化、与增长之间交替使用。 一般来说，经济发展包括三层含义：<br>1.经济量的增长，即一个国家或地区产品和劳务的增加，它构成了经济发展的物质基础；<br>2.经济结构的改进和优化，即一个国家或地区的技术结构、产业结构、收入分配结构、消费结构以及人口结构等经济结构的变化；<br>3.经济质量的改善和提高，即一个国家和地区经济效益的提高、经济稳定程度、卫生健康状况的改善、自然环境和生态平衡以及政治、文化和人的现代化进程。<br>经济发展是通过经济结构的改进和优化、经济质量的改善和提高达到经济量的增长。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220123200009.png" alt="图解GDP"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中国政府与经济发展&quot;&gt;&lt;a href=&quot;#中国政府与经济发展&quot; class=&quot;headerlink&quot; title=&quot;中国政府与经济发展&quot;&gt;&lt;/a&gt;中国政府与经济发展&lt;/h1&gt;&lt;p&gt;探究中国经济的发展，不能割裂开政府的作用。因为在我国，政府不但影响蛋糕的分配，也参与</summary>
      
    
    
    
    <category term="财经" scheme="https://laobameishijia.github.io/category/%E8%B4%A2%E7%BB%8F/"/>
    
    
    <category term="中国经济发展" scheme="https://laobameishijia.github.io/tag/%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-4</title>
    <link href="https://laobameishijia.github.io/2022/01/19/bi-she-fuzz-aflgo-yuan-ma-yue-du-4/"/>
    <id>https://laobameishijia.github.io/2022/01/19/bi-she-fuzz-aflgo-yuan-ma-yue-du-4/</id>
    <published>2022-01-19T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-4"><a href="#毕设-Fuzz-AFLGo源码阅读-4" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-4"></a>毕设-Fuzz-AFLGo源码阅读-4</h1><h2 id="AFLGo在AFL的基础上的改进"><a href="#AFLGo在AFL的基础上的改进" class="headerlink" title="AFLGo在AFL的基础上的改进"></a>AFLGo在AFL的基础上的改进</h2><p>添加了模拟退火算法, 根据种子距离目标节点的距离来</p><h3 id="1-具体的距离目标taget的距离是怎么计算的"><a href="#1-具体的距离目标taget的距离是怎么计算的" class="headerlink" title="1. 具体的距离目标taget的距离是怎么计算的"></a>1. 具体的距离目标taget的距离是怎么计算的</h3><h3 id="2-模拟退火算法-是如何逐步退火？-amp-amp-是怎么挑选种子的？"><a href="#2-模拟退火算法-是如何逐步退火？-amp-amp-是怎么挑选种子的？" class="headerlink" title="2. 模拟退火算法, 是如何逐步退火？&amp;&amp; 是怎么挑选种子的？"></a>2. 模拟退火算法, 是如何逐步退火？&amp;&amp; 是怎么挑选种子的？</h3><p>AFL 的calculate_score函数是对 seed 进行打分，打分的分数决定对 seed fuzzing的时间长度，按照直觉来说，距离越近的 seed，有更大的概率能够到达目标点，则应该分配更多的时间给这些 seed。但是这样就会陷入上面所说的局部最优的困局里，于是 AFLGo 采用时间作为一个划分阶段的 metric，当 fuzzing 的时间在预定的时间内时，让时间较为公平的分配给每个 seed 上，当 fuzzing 时间超过了预定的时间后，时间就集中分配给哪些距离较近的 seed 上。这样可以在前期避免还未广泛探索就过度集中的局部最优的情况。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> u64 cur_ms &#x3D; get_cur_time(); u64 t &#x3D; (cur_ms - start_time) &#x2F; 1000;&#x2F;&#x2F; 计算当前运行时间 double progress_to_tx &#x3D; ((double) t) &#x2F; ((double) t_x * 60.0);&#x2F;&#x2F; 进度条，距离利用阶段的比例还有多少 double T; &#x2F;&#x2F;TODO Substitute functions of exp and log with faster bitwise operations on integers&#x2F;&#x2F; 这里根据fuzzing前的选项选择冷却时间的模型，是log函数，还是线性，还是指数等等 switch (cooling_schedule) &#123;   case SAN_EXP:     T &#x3D; 1.0 &#x2F; pow(20.0, progress_to_tx);     break;   case SAN_LOG:     &#x2F;&#x2F; alpha &#x3D; 2 and exp(19&#x2F;2) - 1 &#x3D; 13358.7268297     T &#x3D; 1.0 &#x2F; (1.0 + 2.0 * log(1.0 + progress_to_tx * 13358.7268297));     break;   case SAN_LIN:     T &#x3D; 1.0 &#x2F; (1.0 + 19.0 * progress_to_tx);     break;   case SAN_QUAD:     T &#x3D; 1.0 &#x2F; (1.0 + 19.0 * pow(progress_to_tx, 2));     break;   default:     PFATAL (&quot;Unkown Power Schedule for Directed Fuzzing&quot;); &#125; double power_factor &#x3D; 1.0; if (q-&gt;distance &gt; 0) &#123;    &#x2F;&#x2F; 首先归一化距离   double normalized_d &#x3D; 0; &#x2F;&#x2F; when &quot;max_distance &#x3D;&#x3D; min_distance&quot;, we set the normalized_d to 0 so that we can sufficiently explore those testcases whose distance &gt;&#x3D; 0.   if (max_distance !&#x3D; min_distance)     normalized_d &#x3D; (q-&gt;distance - min_distance) &#x2F; (max_distance - min_distance);   if (normalized_d &gt;&#x3D; 0) &#123;       double p &#x3D; (1.0 - normalized_d) * (1.0 - T) + 0.5 * T;&#x2F;&#x2F; 计算p值，由距离和时间共同决定       power_factor &#x3D; pow(2.0, 2.0 * (double) log2(MAX_FACTOR) * (p - 0.5));&#x2F;&#x2F; 最后根据p值计算得到factor，   &#125;&#x2F;&#x2F; else WARNF (&quot;Normalized distance negative: %f&quot;, normalized_d); &#125; perf_score *&#x3D; power_factor;&#x2F;&#x2F; 乘上factor得到最后的score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也就是说，得分score计算的公式是由距离和时间共同决定的，你要搞清楚，<strong>并不是每一次fuzz都会选择score分数最高的种子，而是分配更多的havoc时间给这样的seed</strong>。刚开始种子是比较公平的分配到每个seed，这类似–无差别探索阶段。后来，当预定的时间已过。距离较近的seed就会拥有更高的分数，从而在固定的时间段内占有更长时间的havoc，以增加到达taget的几率。</p></blockquote><h3 id="3-一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？"><a href="#3-一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？" class="headerlink" title="3. 一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？"></a>3. 一个是函数距离，一个是基本块之间的距离，这两个距离之间是如何作用的呢？</h3><p>先看一下什么叫做控制流图</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207203351.png" alt="控制流图CFG(Control Flow Graph)"></p><p>这两个是从源码角度分析的</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207211040.png" alt="函数距离计算公式"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207211712.png" alt="BB-Distance距离计算公式"></p><blockquote><p>结合的地方<br>Also, for each basic block in control flow graph of current function, we collect all functions it calls using <code>BBcalls.txt</code>. Among these functions that have <code>cg_distance</code>, AFLGO get the minimum of these and set <code>bb_distance</code> to it.</p></blockquote><p>下面这两个估计是从论文角度分析的，那可能源码在实现上和论文有一定的区别。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207212823.png" alt="函数层面距离计算"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220207212850.png" alt="基本块层面距离计算"></p><h3 id="4-我应该怎么设计我的算法？"><a href="#4-我应该怎么设计我的算法？" class="headerlink" title="4. 我应该怎么设计我的算法？"></a>4. 我应该怎么设计我的算法？</h3><p>四个阶段</p><p>基于距离的模拟退火算法</p><ul><li>无差别探索阶段 Undifferentiated Exploration</li><li>短路径优先阶段 Short Path Priority</li></ul><p>基于基本块距离的模拟退火算法</p><ul><li>长路径探索    Long Path Exploration</li><li>长路径优先    Long Path Priority</li></ul><ol><li>设置<code>bb_passed</code> 记录当前种子经过的基本块的数量</li><li>设置<code>is_longpathexploration</code> 当前这个种子是不是在长路径探索阶段被探索过</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="calibrate-case-函数"><a href="#calibrate-case-函数" class="headerlink" title="calibrate_case 函数"></a>calibrate_case 函数</h3><p>里面 this calculates cur_distance这个看不懂啊，has_new_bits函数中包括了下面计算max_distance和min_distance的代码，为什么这里又再次包含了一遍。</p><h3 id="程序中所谓的seed到底是什么？"><a href="#程序中所谓的seed到底是什么？" class="headerlink" title="程序中所谓的seed到底是什么？"></a>程序中所谓的seed到底是什么？</h3><p><strong>是不同的测试文件</strong>，不是像你像的那样，从这个测试文件中读取内容然后再将一条条的内容进行测试</p><h3 id="为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？"><a href="#为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？" class="headerlink" title="为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？"></a>为什么按照步骤执行ReadMe中的测试步骤，却不能生成dot文件呢？</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220221171732.png" alt="无法生成dot文件"></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>Sudo 的全称为：super user do。 顾名思义：干超级用户才能干的事！所以Sudo最常用的功能就是提升一个命名的执行权限。</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h3 id="程序是如何保留debug信息的呢？"><a href="#程序是如何保留debug信息的呢？" class="headerlink" title="程序是如何保留debug信息的呢？"></a>程序是如何保留debug信息的呢？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-4&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-4&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-4&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-4&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>OneToOne-1</title>
    <link href="https://laobameishijia.github.io/2022/01/06/onetoone-1/"/>
    <id>https://laobameishijia.github.io/2022/01/06/onetoone-1/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OneToOne-1"><a href="#OneToOne-1" class="headerlink" title="OneToOne-1"></a>OneToOne-1</h1><p>比赛时间：2022/1/4</p><p>不知不觉，已经到了大四上学期结束的时候了。跟狗子的单挑也从大一持续到了现在。 这学期的单挑，真的是没赢过啊。确实是有机会赢，但是自己没有把握住。虽然自己矮十几厘米，但是我还算比较有韧性把。很多时候，我都会怀疑自己会输。可总是会咬牙坚持到最后。尤其是最近刚刚打过的这次。</p><p>5局3胜制，我开局以0比2落后。面对比自己高比自己壮的人，我很难不产生一种要服输的心理。三分真的算是我位数不多的得分手段了，如果三分球投不进，我真的很难赢。我不断在心里默默地给自己加油，鼓励自己坚持下去。果然，连续翻了2局。</p><p>最后一局，也是打到了10比10平(11分制)。首先的球权是在我手里，但是我没有把握住机会。不知道为什么，在习惯了以三分作为自己的得分手段之后，以前我非常擅长的中距离变得非常陌生。没办法判断到底什么时机是合适的出手机会。所以啊，还是要继续努力才行。生活中比较庆幸地也是有这样的朋友把，大家就不断互相进步。</p><p>其实把，想赢的心理在我心中一直都有。只不过，确实有的时候会动摇。你会怀疑自己到底能不能赢。就像在面对生活中的困难一样，我觉得正常的人可能都会质疑自己是否能挺过难关，是否能真正地坚持下去。但无疑，坚持下去大多时候会有一个比自己预期要好的结果。就像这次单挑一样，0比2落后，我真的怀疑自己了。但是我心里告诉自己，一定要坚持下去，没有结束，凭什么就这么服输，三分不可能一直投不进。</p><p>我经常会以这些看似鸡汤话鼓励一些在生活中过的不那么如意的人，<strong>有些人总是会说: 只不过是你运气好罢了。</strong> 我觉得他们说的很正确，之所以我有今天的价值观，无非是在我的经历中，坚持下去的做法带来了较多积极的效果。 即使是这样，我仍不觉得我鼓励别人积极乐观地生活是错的，因为我觉得，坚持下去的结果总比放弃的结果好。<strong>哪怕你这次说我没有站在你的角度上思考问题，下次我还是会这么鼓励你。</strong></p><p>回想一下，从刚上大学到现在，坚持练球的过程真的带给我很多生活中的道理。从习惯性一个人为了自己的目标努力，到不因为眼前的困难而放弃，到如何在别人的嘲笑下依旧坚持自己，再到学会把眼光放得长远。我不知道是不是每个打球的人都能体会到这些，但显然善于体味生活的人一定会从中得到很多属于自己的故事。</p><p><strong>我的高中班主任曾经说我打球的原因，就是想耍帅。</strong>但事实是，我经常性地自己练球。 也并没有因此获得什么可以拿的出手的成绩。 可这些并没有影响到我对于篮球的喜爱。 还是那句话，我不是为了打败谁，也不是想成为像NBA球星一样的人物。 我的目标很简单：就是完成自己给自己设定的目标，也许这个目标在有些人看来不值一提。 可是我相信，慢慢地努力，总会达到我想要的效果。现实也正是如此。</p><p>很幸运，我遇到了篮球。要真的追想的话，也不知道具体自己什么时间就喜欢上了篮球。那种不求任何结果，慢慢享受打球过程和眼看着自己慢慢进步的感觉真的很美妙。 可惜，我在我专业课程的学习上并没有这种劲头。 我也喜欢，但没有那种痴迷式的喜欢。 造成的结果也清楚， 我只是比一部分人做得好，但成为不了那种比绝大部分人做得好的人。 哪怕我自己清楚这一点， 还是跟篮球一样， 我不是为了要比谁强，比谁更优秀，我只是像完成自己对自己设定的目标。</p><hr><p>老早就想写这样的总结了，还是往后拖了几天…. 也不知道自己写了点啥， 反正就当给生活留个纪念吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OneToOne-1&quot;&gt;&lt;a href=&quot;#OneToOne-1&quot; class=&quot;headerlink&quot; title=&quot;OneToOne-1&quot;&gt;&lt;/a&gt;OneToOne-1&lt;/h1&gt;&lt;p&gt;比赛时间：2022/1/4&lt;/p&gt;
&lt;p&gt;不知不觉，已经到了大四上学期结束的</summary>
      
    
    
    
    <category term="篮球" scheme="https://laobameishijia.github.io/category/%E7%AF%AE%E7%90%83/"/>
    
    
    <category term="OneToOne" scheme="https://laobameishijia.github.io/tag/OneToOne/"/>
    
  </entry>
  
  <entry>
    <title>大四上学期总结</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-xue-qi-zong-jie/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<p>既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。</p><p>首先。还是没有找到女朋友，<strong>一 我接触的女生确实不多</strong>，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的是没有男女的情感在里面。于是我拒绝了她，不过好在大家的关系也并没有因此显的很尴尬。<strong>二 我并没有很想谈恋爱</strong> 我有我自己的生活，习惯了一个人做事情，反倒不太习惯两个人。 <strong>三 缺乏勇气</strong>  我必须承认自己是一个缺乏勇气的人，在路上看到有些稍微心动的女生，不敢上去要个微信。也许要了也是白要，我总是这样告诉自己。</p><p>接着。就是保研，这个东西确实是个惊喜吧，也确实有运气成分再里面。 我并不认为自己和优秀能扯上关系，至少在学习方面是这样的。</p><p>然后。自己把三分球慢慢地练出来了，也找到了算是比较合适的训练方法。虽然命中率还是不稳定，有的时候还是比较准的。</p><p>还有。 学着去看书，以前我总觉得看书没啥用，在静下心来去阅读一些书籍的生活，才发现，书真的是跟优秀人交流非常好的方式。如果你的生活中没有一些很厉害的人能和你交流，我觉得看他写的书，多多少少还是有些收获的。那就不能不提我看书最大的一个收获就是:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 因为感觉很多事情，远远比我想象中的要复杂，或者即使它很简单，在执行的过程中依然会遇到各种非常难以解决和调和的问题。 另外就是哲学家真的很厉害，尤其是罗素*–ps 看过&lt;幸福之路&gt;，虽然没记住多少，心灵还是很受震撼的*</p><p>emm。 结交了一个非常优秀的朋友，人长得又高又帅。努力拼搏，对自己未来有规划。不像俺，没啥清晰的目标，还不如人家勤奋。</p><p>最后。 2021年的最后一天去欢乐谷体验了一把大摆锤。就是那种摆上去又把你摆下来的，不得不说，要不是没有我朋友鼓励，我还真的不敢坐。也算是挑战了自己一把，不过我还是暗暗发誓：我再也不做了。</p><p>至于活动方面，参与过学校人大换届选举，也当过核酸检测的志愿者。这些活动也更加证实我从书中获得的收获—:<strong>不要轻易地下结论，无论是对人还是对事。</strong> 动不动就开始吐槽和埋怨，既不利于事情的解决，也容易陷入片面思考的误区。</p><p>至于照片，寒假有空就把自己手机当中的照片整理一下把。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;既然是学期总结，那总得说点自己的进步和值得记忆的事情吧。&lt;/p&gt;
&lt;p&gt;首先。还是没有找到女朋友，&lt;strong&gt;一 我接触的女生确实不多&lt;/strong&gt;，有的时候，我也很纳闷，在接触的女生中就没有一个可以使自己心动的？ 前端时间，一个关系非常好的女同学向我表白，但我真的</summary>
      
    
    
    
    <category term="学期总结" scheme="https://laobameishijia.github.io/category/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>大四上寒假计划</title>
    <link href="https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/"/>
    <id>https://laobameishijia.github.io/2022/01/06/da-si-shang-han-jia-ji-hua/</id>
    <published>2022-01-06T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<p>寒假计划</p><ul><li><input checked="" disabled="" type="checkbox"> 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动</li><li><input disabled="" type="checkbox"> 毕设一定要稳步推进</li><li><input disabled="" type="checkbox"> 学会做更多的菜，尝试去做蛋糕</li><li><input disabled="" type="checkbox"> 多跟着奶奶置办一些年货</li><li><input checked="" disabled="" type="checkbox"> 去走动亲戚，尤其是那种好几年都没回来过的。<strong>不要找一些冠冕堂皇的借口，其实你就是懒！</strong></li><li><input checked="" disabled="" type="checkbox"> 不要跟家里人生气，争取一次都不要</li><li><input checked="" disabled="" type="checkbox"> 再配一副眼镜，去体育公园打打球</li><li><input checked="" disabled="" type="checkbox"> 买到自己想要的新年衣服</li><li><input checked="" disabled="" type="checkbox"> 留意一下家里有没有什么合适的女朋友 😀~~~ (？！我劝你好自为之)</li></ul><p>暂时就是这些，希望寒假回来的时候，能都打上√</p><p>首先是毕设的问题，在自己家真的不是什么适合学习的地方, 但是也不能说啥也没看, 但只是进度非常慢。</p><p>奶奶在家，很多东西其实也是爷爷和奶奶自己做的。有的时候把，我也不是不想帮忙，只是我也不知道自己应该干什么。由于经常去奶奶家吃饭, 做饭这个计划就又搁置啦。~~~</p><p>这个寒假，明显感觉到我对待家里人多了几分耐心。 这也说明，我心性有那么一点点的进步。</p><p>女朋友也确实留意了，虽然我非常不愿意承认自己以貌取人，但是我终究还是没逃过这一点。说到底，咱还是。。。😀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寒假计划&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 力量训练–争取每一次都做到训练的标准，而不是消耗性的运动&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;</summary>
      
    
    
    
    <category term="寒假计划" scheme="https://laobameishijia.github.io/category/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="大四上" scheme="https://laobameishijia.github.io/tag/%E5%A4%A7%E5%9B%9B%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-3</title>
    <link href="https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/"/>
    <id>https://laobameishijia.github.io/2022/01/02/bi-she-fuzz-aflgo-yuan-ma-yue-du-3/</id>
    <published>2022-01-02T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-3"><a href="#毕设-Fuzz-AFLGo源码阅读-3" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-3"></a>毕设-Fuzz-AFLGo源码阅读-3</h1><h2 id="AFL框架"><a href="#AFL框架" class="headerlink" title="AFL框架"></a>AFL框架</h2><h3 id="共享内存中的bitmap结构-amp-amp-forkserver机制"><a href="#共享内存中的bitmap结构-amp-amp-forkserver机制" class="headerlink" title="共享内存中的bitmap结构 &amp;&amp; forkserver机制"></a>共享内存中的bitmap结构 &amp;&amp; forkserver机制</h3><p>不太好描述，就直接放图上来了。  —其他的都写到注释里面了</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220118215515.jpg" alt="共享内存中的bitmap结构&amp;&amp;forkserver机制"></p><h2 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux C"></a>Linux C</h2><h3 id="进程之间的信号是如何进行传递的"><a href="#进程之间的信号是如何进行传递的" class="headerlink" title="进程之间的信号是如何进行传递的"></a>进程之间的信号是如何进行传递的</h3><p>直接看下面的链接把</p><p><a href="https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b">https://www.bookstack.cn/read/linux-c/5016547c13b140cc.md#6b906b</a></p><h3 id="控制台和终端的关系"><a href="#控制台和终端的关系" class="headerlink" title="控制台和终端的关系"></a>控制台和终端的关系</h3><p><a href="https://www.cnblogs.com/sparkdev/p/11460821.html">https://www.cnblogs.com/sparkdev/p/11460821.html</a></p><p>在计算机里，把那套直接连接在电脑上的键盘和显示器就叫做控制台。而终端是通过串口连接上的，不是计算机自身的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。这同样说明，控制台是计算机的基本设备，而终端是附加设备。计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。比如在启动和关闭 Linux 系统时，我们可以在控制台上看到很多的内核信息(下图来自 vSphere Client 中的 “Virtual Machine Console”)</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103170553.png" alt="控制台"></p><p>现在终端和控制台都由硬件概念，逐渐演化成了软件的概念。<strong>简单的说，能直接显示系统消息的那个终端称为控制台，其他的则称为终端(控制台也是一个终端)。或者我们在平时的使用中压根就不区分 Linux 中的终端与控制台。</strong></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220103171552.png" alt="Linux上的终端"></p><h3 id="dev-urandom-dev-null"><a href="#dev-urandom-dev-null" class="headerlink" title="/dev/urandom /dev/null"></a>/dev/urandom /dev/null</h3><p>一个是随机数生成器, 另一个相当于空文件, 所有定向到这个地方的输入都会消失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-3&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-3&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-3&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-2</title>
    <link href="https://laobameishijia.github.io/2021/12/22/bi-she-fuzz-aflgo-yuan-ma-yue-du-2/"/>
    <id>https://laobameishijia.github.io/2021/12/22/bi-she-fuzz-aflgo-yuan-ma-yue-du-2/</id>
    <published>2021-12-22T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毕设-Fuzz-AFLGo源码阅读-2"><a href="#毕设-Fuzz-AFLGo源码阅读-2" class="headerlink" title="毕设-Fuzz-AFLGo源码阅读-2"></a>毕设-Fuzz-AFLGo源码阅读-2</h1><h2 id="AFL框架"><a href="#AFL框架" class="headerlink" title="AFL框架"></a>AFL框架</h2><h3 id="共享内存中的bitmap结构"><a href="#共享内存中的bitmap结构" class="headerlink" title="共享内存中的bitmap结构"></a>共享内存中的bitmap结构</h3><p>TODO</p><h3 id="forkserver机制"><a href="#forkserver机制" class="headerlink" title="forkserver机制"></a>forkserver机制</h3><p>TODO </p><h2 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux C"></a>Linux C</h2><h3 id="read-amp-amp-write"><a href="#read-amp-amp-write" class="headerlink" title="read &amp;&amp; write"></a>read &amp;&amp; write</h3><p>看这个书，这个上面写的很详细</p><p><a href="https://www.bookstack.cn/read/linux-c/c917e635f91d4a4f.md">https://www.bookstack.cn/read/linux-c/c917e635f91d4a4f.md</a></p><h3 id="itimerval"><a href="#itimerval" class="headerlink" title="itimerval"></a>itimerval</h3><p> <a href="https://beachboyy.blog.csdn.net/article/details/35569229?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn">参考</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct itimerval &#123;    struct timeval it_interval; &#x2F;* 计时器重启动的间歇值 *&#x2F;    struct timeval it_value;    &#x2F;* 计时器安装后首先启动的初始值 *&#x2F;&#125;; struct timeval &#123;    long tv_sec;                &#x2F;* 秒 *&#x2F;    long tv_usec;               &#x2F;* 微妙(1&#x2F;1000000) *&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码实现的功能：3秒钟后启动定时器，然后每隔1秒钟向终端打印count的递增值，当count到10时程序退出。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;sys&#x2F;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;  static int count &#x3D; 0;  void set_timer()&#123;struct itimerval itv;  itv.it_value.tv_sec &#x3D; 3;    &#x2F;&#x2F;timer start after 3 seconds lateritv.it_value.tv_usec &#x3D; 0;  itv.it_interval.tv_sec &#x3D; 1;itv.it_interval.tv_usec &#x3D; 0;  setitimer(ITIMER_REAL,&amp;itv,NULL);&#125;  void signal_handler(int m)&#123;count ++;printf(&quot;%d\n&quot;,count);&#125;  int main()&#123;signal(SIGALRM,signal_handler);set_timer();while(count &lt; 10);exit(0);return 0; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="setsid"><a href="#setsid" class="headerlink" title="setsid()"></a>setsid()</h3><p>setsid主要是重新创建一个session,子进程从父进程继承了SessionID、进程组ID和打开的终端,子进程如果要脱离父进程，不受父进程控制，我们可以用这个setsid命令</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211223200534.png" alt="setsid ping 127.0.0.1"></p><p>可以发现即使我们按下<code>ctrl+c</code> ping命令依然在执行，也就是说ping命令脱离了父进程shell的控制。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211223200711.png" alt="ps -ef | grep ping"></p><h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><p>去看csdn这篇博客 <a href="https://blog.csdn.net/silent123go/article/details/71108501">https://blog.csdn.net/silent123go/article/details/71108501</a></p><p>从shell中运行一个进程，默认会有3个文件描述符存在(0、１、2)，0与进程的标准输入相关联，１与进程的标准输出相关联，2与进程的标准错误输出相关联，一个进程当前有哪些打开的文件描述符可以通过/proc/进程ID/fd目录查看。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>很清楚</p><p><a href="https://www.bookstack.cn/read/linux-c/f72a2171d262cc79.md#783frj">https://www.bookstack.cn/read/linux-c/f72a2171d262cc79.md#783frj</a></p><h3 id="builtin-expect"><a href="#builtin-expect" class="headerlink" title="__builtin_expect"></a>__builtin_expect</h3><p>链接：<a href="https://www.jianshu.com/p/2684613a300f">https://www.jianshu.com/p/2684613a300f</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define likely(x) __builtin_expect(!!(x), 1) &#x2F;&#x2F;x很可能为真       #define unlikely(x) __builtin_expect(!!(x), 0) &#x2F;&#x2F;x很可能为假if(likely(value))  &#x2F;&#x2F;等价于 if(value)if(unlikely(value))  &#x2F;&#x2F;也等价于 if(value)example上面的代码中 gcc 编译的指令会预先读取 y &#x3D; -1 这条指令，这适合 x 的值大于 0 的概率比较小的情况。如果 x 的值在大部分情况下是大于 0 的，就应该用 likely(x &gt; 0)，这样编译出的指令是预先读取 y &#x3D; 1 这条指令了。这样系统在运行时就会减少重新取指了int x, y; if(unlikely(x &gt; 0))    y &#x3D; 1; else     y &#x3D; -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211224190553.png" alt="fprintf"></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="零碎的知识"><a href="#零碎的知识" class="headerlink" title="零碎的知识"></a>零碎的知识</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20220102144443.png" alt="mov指令"></p><p><a href="https://www.cnblogs.com/lsgxeva/p/11176000.html">深入浅出GNU X86-64 汇编</a></p><p><a href="https://www.cnblogs.com/yanghong-hnu/p/4705755.html">bss段，data段、text段、堆(heap)和栈(stack)</a></p><h3 id="XMM寄存器组"><a href="#XMM寄存器组" class="headerlink" title="XMM寄存器组"></a>XMM寄存器组</h3><p>除了我们已经讨论过的寄存器，现代处理器还有一些扩展。这些扩展体现在电路上，指令集上，有时候也会扩展一些很有用的寄存器。比较著名的扩展叫作 SSE (Streaming SIMD Extensions)，该扩展加入了新的 xmm 寄存器集合：xmm0，xmm1，…，xmm15。这些寄存器为 128 位宽，常用于两种任务：</p><ul><li>浮点数运算；以及</li><li>SIMD 指令集(这种指令一条指令可以操作多条数据)<br>常用的 mov 指令没有办法操作 xmm 寄存器。movq 指令可以代替用来拷贝 xmm 寄存器的低位(128 位中的低 64 位)，操作数的其中一个可以也是 xmm 寄存器，或者通用寄存器，或者内存(也得是 64 位)。</li></ul><p>为了填满 xmm 寄存器，你有两个选择：movdqa 和 movdqu。前者可以解释为“ move aligned double quad word”，移动两个对齐的 qword。后者是未对齐的版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毕设-Fuzz-AFLGo源码阅读-2&quot;&gt;&lt;a href=&quot;#毕设-Fuzz-AFLGo源码阅读-2&quot; class=&quot;headerlink&quot; title=&quot;毕设-Fuzz-AFLGo源码阅读-2&quot;&gt;&lt;/a&gt;毕设-Fuzz-AFLGo源码阅读-2&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
  <entry>
    <title>毕设-Fuzz-AFLGo源码阅读-1</title>
    <link href="https://laobameishijia.github.io/2021/12/15/bi-she-fuzz-aflgo-yuan-ma-yue-du-1/"/>
    <id>https://laobameishijia.github.io/2021/12/15/bi-she-fuzz-aflgo-yuan-ma-yue-du-1/</id>
    <published>2021-12-15T09:25:00.000Z</published>
    <updated>2022-03-16T10:16:03.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFLGo源码阅读-1"><a href="#AFLGo源码阅读-1" class="headerlink" title="AFLGo源码阅读-1"></a>AFLGo源码阅读-1</h1><p>首先还是要从基础的C语言语句开始补起。</p><h2 id="AFL-代码覆盖率及其相关概念"><a href="#AFL-代码覆盖率及其相关概念" class="headerlink" title="AFL-代码覆盖率及其相关概念"></a>AFL-代码覆盖率及其相关概念</h2><p>原文：<a href="https://www.freebuf.com/vuls/197672.html">https://www.freebuf.com/vuls/197672.html</a></p><h3 id="1-代码覆盖率（Code-Coverage）"><a href="#1-代码覆盖率（Code-Coverage）" class="headerlink" title="1. 代码覆盖率（Code Coverage）"></a>1. 代码覆盖率（Code Coverage）</h3><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的官方文档。</p><h3 id="2-基本块（Basic-Block）"><a href="#2-基本块（Basic-Block）" class="headerlink" title="2. 基本块（Basic Block）"></a>2. 基本块（Basic Block）</h3><p>缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征：</p><ul><li>只有一个入口点，BB中的指令不是任何跳转指令的目标。</li><li>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</li></ul><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151025.png" alt="基本块"></p><h3 id="3-边（edge）"><a href="#3-边（edge）" class="headerlink" title="3. 边（edge）"></a>3. 边（edge）</h3><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151136.png" alt="CFG"></p><h3 id="4-元组（tuple）"><a href="#4-元组（tuple）" class="headerlink" title="4. 元组（tuple）"></a>4. 元组（tuple）</h3><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录当前基本块 + 前一基本块 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cur_location <span class="token operator">=</span> <span class="token operator">&lt;</span>COMPILE_TIME_RANDOM<span class="token operator">></span><span class="token punctuation">;</span>           <span class="token comment">//用一个随机数标记当前基本块</span>shared_mem<span class="token punctuation">[</span>cur_location <span class="token operator">^</span> prev_location<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//将当前块和前一块异或保存到shared_mem[]</span>prev_location <span class="token operator">=</span> cur_location <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">//cur_location右移1位区分从当前块到当前块的转跳</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx/rcx，然后调用__afl_maybe_log，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211222151618.png" alt="IDA中的汇编代码"></p><blockquote><p>关于这个过程后续肯定要弄的非常清楚才行， 因为要添加一个基于基本块覆盖率的模拟退火算法，这样的扩展应该加在什么地方，以及怎么实现都需要把这个过程弄清楚。</p></blockquote><h2 id="C-知识"><a href="#C-知识" class="headerlink" title="C 知识"></a>C 知识</h2><h3 id="C-预处理"><a href="#C-预处理" class="headerlink" title="C 预处理"></a>C 预处理</h3><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p><p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211215211258.png" alt="预处理指令列表"></p><p>其他的详见菜鸟教程。<br><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">https://www.runoob.com/cprogramming/c-preprocessors.html</a></p><h3 id="C-C-中-volatile-关键字详解"><a href="#C-C-中-volatile-关键字详解" class="headerlink" title="C/C++ 中 volatile 关键字详解"></a>C/C++ 中 volatile 关键字详解</h3><p>C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。这是 BS 在 “The C++ Programming Language” 对 volatile 修饰词的说明：</p><blockquote><p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p></blockquote><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">volatile</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><span class="token keyword">int</span> b <span class="token operator">=</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而<strong>优化</strong>做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说<strong>volatile 可以保证对特殊地址的稳定访问</strong>。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="程序处理中的控制流图和调用图"><a href="#程序处理中的控制流图和调用图" class="headerlink" title="程序处理中的控制流图和调用图"></a>程序处理中的控制流图和调用图</h3><h4 id="控制流图–Control-Flow-Graph"><a href="#控制流图–Control-Flow-Graph" class="headerlink" title="控制流图–Control Flow Graph"></a>控制流图–Control Flow Graph</h4><p>控制流图(Control Flow Graph, CFG)也叫控制流程图，是一个过程或程序的抽象表现，是用在编译器中的一个抽象数据结构，由编译器在内部维护，代表了一个程序执行过程中会遍历到的所有路径。它用图的形式表示一个过程内所有基本块执行的可能流向, 也能反映一个过程的实时执行过程。Frances E. Allen于1970年提出控制流图的概念。此后，控制流图成为了编译器优化和静态分析的重要工具。</p><p>原文：<br>In a control-flow graph each node in the graph represents a basic block, i.e. a straight-line piece of code without any jumps or jump targets; jump targets start a block, and jumps end a block. Directed edges are used to represent jumps in the control flow. There are, in most presentations, two specially designated blocks: the entry block, through which control enters into the flow graph, and the exit block, through which all control flow leaves.<br>译文：<br>在控制流图中，图中的每个节点代表一个基本块，即一段没有任何跳转或跳转目标的直线代码；跳转目标开始一个块，而跳转结束一个块。有向边用来表示控制流中的跳转。在大多数演示中，有两个特别指定的块：入口块，控制通过它进入流程图；出口块，所有控制流通过它离开。</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211219105935.png" alt="控制流图的几种结构"></p><p><strong>特点</strong>:</p><ul><li>控制流程图是过程导向的</li><li>控制流程图显示了程序执行过程中可以遍历的所有路径</li><li>控制流程图是一个有向图</li><li>CFG 中的边描述控制流路径，节点描述基本块</li><li>每个控制流图都存在2个指定的块：Entry Block(输入块)，Exit Block(输出块)</li></ul><h4 id="函数调用图-Function-Call-Graph"><a href="#函数调用图-Function-Call-Graph" class="headerlink" title="函数调用图 Function Call Graph"></a>函数调用图 Function Call Graph</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211219111655.png" alt="函数调用图"></p><h3 id="插桩怎么实现"><a href="#插桩怎么实现" class="headerlink" title="插桩怎么实现"></a>插桩怎么实现</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="make-和-make-install-的区别"><a href="#make-和-make-install-的区别" class="headerlink" title="make 和 make install 的区别"></a>make 和 make install 的区别</h3><p>简单来说，make 是编译，make install 是安装。</p><p>总结：linux编译安装中configure、make和make install各自的作用</p><p>./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p><p>make是用来编译的，它从Makefile中读取指令，然后编译。</p><p>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>1、configure</p><p>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr上面的意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin.同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><p>2、make</p><p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或Python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。<br>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。一般情况下，他所使用的 Makefile 控制代码，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><p>3、make install</p><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）</p><blockquote><p>作者：cuteximi_1995 链接：<a href="https://www.jianshu.com/p/c70afbbf5172">https://www.jianshu.com/p/c70afbbf5172</a> 来源：简书</p></blockquote><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>Makefile给我的感觉，就好像是另一种编程语言一样。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFLGo源码阅读-1&quot;&gt;&lt;a href=&quot;#AFLGo源码阅读-1&quot; class=&quot;headerlink&quot; title=&quot;AFLGo源码阅读-1&quot;&gt;&lt;/a&gt;AFLGo源码阅读-1&lt;/h1&gt;&lt;p&gt;首先还是要从基础的C语言语句开始补起。&lt;/p&gt;
&lt;h2 id=&quot;AF</summary>
      
    
    
    
    <category term="毕设" scheme="https://laobameishijia.github.io/category/%E6%AF%95%E8%AE%BE/"/>
    
    
    <category term="Fuzz" scheme="https://laobameishijia.github.io/tag/Fuzz/"/>
    
    <category term="AFLGo" scheme="https://laobameishijia.github.io/tag/AFLGo/"/>
    
  </entry>
  
</feed>
