<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老叭美食家</title>
  
  <subtitle>永远热爱生活</subtitle>
  <link href="https://laobameishijia.github.io/atom.xml" rel="self"/>
  
  <link href="https://laobameishijia.github.io/"/>
  <updated>2021-10-13T13:02:31.497Z</updated>
  <id>https://laobameishijia.github.io/</id>
  
  <author>
    <name>老叭美食家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言学习-数据处理的两个基本问题</title>
    <link href="https://laobameishijia.github.io/2021/10/13/hui-bian-yu-yan-xue-xi-shu-ju-chu-li-de-liang-ge-ji-ben-wen-ti/"/>
    <id>https://laobameishijia.github.io/2021/10/13/hui-bian-yu-yan-xue-xi-shu-ju-chu-li-de-liang-ge-ji-ben-wen-ti/</id>
    <published>2021-10-13T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>还是画这样的图，感觉思路清晰一些。新的东西并不多,大多感觉还是对以往问题的一个总结。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102156.png" alt="思维导图"></p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><p>编程,将data段中的数据按如下格式写入到table段中,并计算21年中的人均收入(取整),结果也按照下面的格式保存在table段中。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102611.png" alt="题干1"><br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013102632.png" alt="题干2"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  具体的思路就是,利用内外循环,大循环循环00-10H-20H这样每一行的数据,小循环循环每个数据项</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>中具体的字节\字。同时利用idata和si</p><pre class=" language-text"><code class="language-text">assume cs:codesg,ds:datadata segment    ;0    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'    db '1993','1994','1995'    ;54H    dd 16,22,382,1356,2390,8000,160000,24486,50065,97479,140417,197514    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5973000        ;A8H    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226    dw 11542,14430,15257,17800data endstable segment    db 21 dup ('year summ ne ?? ')table endscodesg segment;正好印证了两个重点的地方 1.数据在什么地方 2.数据的大小;算人均收入的那个还没有写--------------------------------------------------------start:    mov ax,data    mov ds,ax        mov ax,table    mov es,ax;这里经常把ax写成table了    mov bx,0;bx定位data段,bx year和收入都是四个字节可以公用,但是雇员数是两个字节的没办法公用    mov bp,0;bp定位es段    mov di,0;di用来在循环中服务于雇员数,因为它是两个字节,没办法跟year和outcome公用一个递增寄存器    mov cx,21    overall:        push cx        mov cx,2        mov si,0        year:            ;年份的4字节---两个字            mov ax,ds:[bx+si]            mov es:[bp+si],ax            add si,2            loop year        mov cx,2        mov si,0        outcome:            ;收入的4字节---两个字            mov ax,ds:[bx+54H+si]            mov es:[bp+5H+si],ax            add si,2            loop outcome        ;雇员数---一个字        mov ax,ds:[di+0A8H]        mov es:[bp+0AH],ax        ;计算人均收入        mov ax,es:[bp+5H];计算人均收入的,要用es的定位,那偏移量就得按照es的来。最开始写成ds的定位了[bx+54H]了        mov dx,es:[bp+5H+2]        div word ptr es:[bp+0AH]        mov es:[bp+0DH],ax        ;所有的空格        ;第一次没有考虑到空格是一个字节,这里不应该用16位的,应该用8位的        mov al,' '        mov es:[bp+4H],al        mov es:[bp+9H],al        mov es:[bp+0FH],al        pop cx        add di,2        add bx,4        add bp,16        loop overall    ;计算收入    mov ax,4c00h    int 21hcodesg endsend start</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;&lt;a href=&quot;#数据处理的两个基本问题&quot; class=&quot;headerlink&quot; title=&quot;数据处理的两个基本问题&quot;&gt;&lt;/a&gt;数据处理的两个基本问题&lt;/h1&gt;&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-转移指令原理</title>
    <link href="https://laobameishijia.github.io/2021/10/13/hui-bian-yu-yan-xue-xi-zhuan-yi-zhi-ling-yuan-li/"/>
    <id>https://laobameishijia.github.io/2021/10/13/hui-bian-yu-yan-xue-xi-zhuan-yi-zhi-ling-yuan-li/</id>
    <published>2021-10-13T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令原理"><a href="#转移指令原理" class="headerlink" title="转移指令原理"></a>转移指令原理</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013193650.png" alt="思维导图"></p><h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><p>在对应的机器码中不包含转移的目的地址,而包含的是到目的地址的位移。这种设计,方便了程序段在内存中的浮动装配。使程序装在内存中的不同位置都可正确执行,因为在执行时,只涉及到位移,而不是地址。如果是地址的话,程序没有装载到对应的位置,就会造成程序没有办法正确执行。</p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><h3 id="实验8-分析一个奇怪的程序"><a href="#实验8-分析一个奇怪的程序" class="headerlink" title="实验8 分析一个奇怪的程序"></a>实验8 分析一个奇怪的程序</h3><p>分析下面的程序,在运行前思考:这个程序可以正确返回吗？</p><pre class=" language-text"><code class="language-text">assume cs:codesgcodesg segment    mov ax,4c00h    int 21h;反正就是刚好利用了jmp 的相对位移的特性.short 8位位移 = 标号处的地址-jmp指令后的第一个字节地址start:    mov ax,0s:    nop    nop    mov di,offset s    mov si,offset s2    mov ax,cs:[si]    mov cs:[di],axs0:    jmp short ss1:    mov ax,0    int 21h    mov ax,0s2:    jmp short s1    nopcodesg endsend start</code></pre><p>可以正确返回,刚好利用了jmp 的相对位移的特性.short 8位位移 = 标号处的地址-jmp指令后的第一个字节地址。当程序再次跳回到s标号处执行时,其第一条指令为 EBF6,就刚好是往上面跳到了 <code>mov ax,4c00h</code></p><h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013194841.png" alt="实验8"></p><h3 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h3><p>在屏幕中间分别显示绿色\绿底红色\白底蓝色的字符串”welcome to masm!”.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>感觉这个没用到这章讲的东西啊??!!，还是因为我水平不行？？</p><p><strong>我是真的憨憨,第一开始没有注意到题目中说的是要在屏幕中间显示</strong></p><h5 id="改进前-写了三个循环"><a href="#改进前-写了三个循环" class="headerlink" title="改进前,写了三个循环"></a>改进前,写了三个循环</h5><pre class=" language-text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'datasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov ax,0B800H    mov es,ax;1        mov bx,6E0H    mov si,0    mov di,80    mov cx,16s:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],02H    add di,2    add si,1    loop s;2    mov bx,780H    mov si,0    mov di,80    mov cx,16s1:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],24H    add di,2    add si,1    loop s1;3    mov bx,820H    mov si,0    mov di,80    mov cx,16s2:      mov al,ds:[si]    mov es:[bx+di],al    mov byte ptr es:[bx+di+1],71H    add di,2    add si,1    loop s2    mov ax,4c00h    int 21hcodesg endsend start</code></pre><h5 id="改进后-写成了一个循环"><a href="#改进后-写成了一个循环" class="headerlink" title="改进后,写成了一个循环"></a>改进后,写成了一个循环</h5><pre class=" language-text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'    db 02H,24H,71Hdatasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov ax,0B800H    mov es,ax;1        mov bx,6E0H    mov cx,3    mov bp,0all:    push cx    mov si,0    mov di,80    mov cx,16    s:          mov al,ds:[si]        mov es:[bx+di],al        mov al,ds:[bp+16]        mov es:[bx+di+1],al        add di,2        add si,1        loop s    add bp,1    add bx,160    pop cx    loop all; ;2;     mov bx,780H;     mov si,0;     mov di,80;     mov cx,16; s1:  ;     mov al,ds:[si];     mov es:[bx+di],al;     mov byte ptr es:[bx+di+1],24H;     add di,2;     add si,1;     loop s1; ;3;     mov bx,820H;     mov si,0;     mov di,80;     mov cx,16; s2:  ;     mov al,ds:[si];     mov es:[bx+di],al;     mov byte ptr es:[bx+di+1],71H;     add di,2;     add si,1;     loop s2    mov ax,4c00h    int 21hcodesg endsend start</code></pre><h4 id="运行截图-1"><a href="#运行截图-1" class="headerlink" title="运行截图"></a>运行截图</h4><p>这个运行结果，怎么有的时候行有的时候不行？之前运行的时候，第一行的welcome 显示成了 celcome或是1/4elcome很奇怪。但是后面就又正常了<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013201157.png" alt="实验九"></p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211013205518.png" alt="改正后"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;转移指令原理&quot;&gt;&lt;a href=&quot;#转移指令原理&quot; class=&quot;headerlink&quot; title=&quot;转移指令原理&quot;&gt;&lt;/a&gt;转移指令原理&lt;/h1&gt;&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-更灵活的定位内存地址的方法</title>
    <link href="https://laobameishijia.github.io/2021/10/11/hui-bian-yu-yan-xue-xi-geng-ling-huo-de-ding-wei-nei-cun-di-zhi-de-fang-fa/"/>
    <id>https://laobameishijia.github.io/2021/10/11/hui-bian-yu-yan-xue-xi-geng-ling-huo-de-ding-wei-nei-cun-di-zhi-de-fang-fa/</id>
    <published>2021-10-11T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="编程1-将datasg段中每个单词的前四个字母改为大写字母"><a href="#编程1-将datasg段中每个单词的前四个字母改为大写字母" class="headerlink" title="编程1 将datasg段中每个单词的前四个字母改为大写字母"></a>编程1 将datasg段中每个单词的前四个字母改为大写字母</h2><pre class=" language-text"><code class="language-text">assume cs:codesg,ss:stacksg,ds:datasgstacksg segment    dw 0,0,0,0,0,0,0,0stacksg endsdatasg segment    db '1. display      '    db '2. brows        '    db '3. replace      '    db '4. modify       'datasg endscodesg segmentstart:    mov ax,stacksg    mov ss,ax    mov sp,16;初始化栈段        mov ax,datasg    mov ds,ax;初始化数据段        mov bx,0    mov cx,4s:    push cx    mov cx,4    mov si,0s0:    mov al,ds:[bx+3+si];这个地方必须要是 bx+(si/di)+(idata)这样的形式,()为可选内容    and al,11011111B;01100100 01000100--44      mov ds:[bx+3+si],al    inc si    loop s0    pop cx    add bx,16    loop s        mov ax,4c00h    int 21hcodesg endsend start</code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011200251.png" alt="运行截图"></p><h3 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li><code>and al,11011111b</code>少打了一个1</li></ul><h2 id="编程2-将datasg中的第一个字符串转换成大写-第二个字符串转成小写"><a href="#编程2-将datasg中的第一个字符串转换成大写-第二个字符串转成小写" class="headerlink" title="编程2 将datasg中的第一个字符串转换成大写,第二个字符串转成小写"></a>编程2 将datasg中的第一个字符串转换成大写,第二个字符串转成小写</h2><pre class=" language-text"><code class="language-text">assume cs:codesg,ds:datasgdatasg segment    db 'BaSiC'    db 'iNfOrMaTiOn'datasg endscodesg segment    start:        mov ax,datasg        mov ds,ax                mov bx,1        mov cx,2    s:        mov al,ds:[bx]        and al,11011111b        mov ds:[bx],al        add bx,2        loop s                mov bx,6;这个bx要定位到 第二个字符串的第一个大写字母啊        mov cx,5    s0:        mov al,ds:[bx]        or al,00100000b        mov ds:[bx],al                add bx,2        loop s0        mov ax,4c00h        int 21hcodesg endsend start</code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011203022.png" alt="运行截图"></p><h3 id="出现的错误-1"><a href="#出现的错误-1" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li>第二个字符串定位是要在<code>第一个大写字母N</code></li></ul><h2 id="编程3-用si和di实现将字母串”welcome-to-masm-”复制到它后面的数据区中"><a href="#编程3-用si和di实现将字母串”welcome-to-masm-”复制到它后面的数据区中" class="headerlink" title="编程3 用si和di实现将字母串”welcome to masm!”复制到它后面的数据区中"></a>编程3 用si和di实现将字母串”welcome to masm!”复制到它后面的数据区中</h2><pre class=" language-text"><code class="language-text">assume  cs:codesg,ds:datasgdatasg segment    db 'welcome to masm!'    db '................'datasg endscodesg segmentstart:    mov ax,datasg    mov ds,ax    mov si,0    mov di,10h    mov bx,0    mov cx,8 s:     mov ax,ds:[bx+si]    mov ds:[bx+di],ax        add si,2    add di,2        loop s    mov ax,4c00h    int 21hcodesg endsend start</code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211011204256.png" alt="运行截图"></p><h3 id="出现的错误-2"><a href="#出现的错误-2" class="headerlink" title="出现的错误"></a>出现的错误</h3><ul><li><code>assume codesg</code> 和<code>code segment</code> 不匹配</li><li>di寄存器写成bi</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章中,我们主要讲解了更为灵活的寻址方式的应用和一些编程方法,主要的内容有：</p><ul><li>寻址方式 [bx]–编程2[bx+idata] [bx+si]–编程3[bx+si+idata]–编程1</li><li>二重循环问题的处理,处理两个循环loop都使用cx寄存器的时候,会出现冲突的问题.解决的最佳方式就是将cx的值暂时存储到栈空间中,等到再次回到外层循环的时候,再将其出栈,以此实现将互不影响.这里也能体现处在<code>调用函数</code>掉用<code>被调用函数</code>的时候,将各个寄存器的值入栈,等到<code>被调用函数</code>返回时,再将各个寄存器的值初始化到调用<code>被调用函数</code>之前,这样就可以继续执行<code>调用函数</code>,而不产生影响.</li><li>栈的应用</li><li>大小写转换的方法<br>小写转大写 <code>and al,11011111b</code><br>大写转小写 <code>or al,00100000b</code></li><li>and | or 指令</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h1&gt;&lt;h2 id=&quot;编程1-将datasg段中每个单词的前四个字母改为大写字母&quot;&gt;&lt;a href=&quot;#编程1-将datasg段中每个单词的前四个字母改</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-[bx]和loop指令</title>
    <link href="https://laobameishijia.github.io/2021/10/10/hui-bian-yu-yan-xue-xi-bx-he-loop-zhi-ling/"/>
    <id>https://laobameishijia.github.io/2021/10/10/hui-bian-yu-yan-xue-xi-bx-he-loop-zhi-ling/</id>
    <published>2021-10-10T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h2><p><code>mov ax,[bx]</code>, bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中,将SA:EA处的数据送入ax中,<strong>注意这里是字型数据哦！</strong> 即:<code>ax = ds*16 + bx</code></p><p>建议以后再写汇编语言程序的时候,把[bx]前面的段寄存器显式地标注出来,也就是所谓的<strong>段前缀</strong>。</p><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop 指令就是一个循环指令，注意cx循环次数,和bx在循环过程中的变化。</p><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>计算ffff:0-ffff:b单元中的数据的和,结果存储在dx中</p><h3 id="数据相加的问题"><a href="#数据相加的问题" class="headerlink" title="数据相加的问题"></a>数据相加的问题</h3><ul><li>dx = dx + 内存中的8位数据 类型不匹配</li><li>dl = dl + 内存中的8位数据 结果越界</li></ul><p>解决方案：利用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器ax中<strong>高八位要初始化为0</strong>,再将ax中的数据加到dx上,从而使两个运算对象的类型匹配并且结果不会超界。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-and-2"><a href="#1-and-2" class="headerlink" title="1 and 2"></a>1 and 2</h3><p>编程 ,向内存 0:200<del>0:23F依次传送数据0</del>63</p><pre class=" language-text"><code class="language-text">  assume cs:codeseg  codeseg segment  start: mov ax,0200H    ;这里第一次写成0H了 心里想的确实是0200 不知道怎么弄成0了        mov ds,ax              mov bx,0H        mov cx,40H        s:  mov ds:[bx],bl      inc bx      loop s            mov ax,4c00H      int 21h  codeseg ends  end start  end</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>将”mov ax,4c00h”之前的指令复制到内存0:200h处,补全程序,上机调试,跟踪运行结果.</p><pre class=" language-text"><code class="language-text">  assume cs:codeseg  codeseg segment  start: mov ax,cs      mov ds,ax      mov ax,0020h      mov es,ax      mov bx,0      mov cx,17h;第一次写的21(10进制),看网上有说18的，感觉不对呀，我17的话就刚刚好是可以复制完的      ;还有view里面cpu指令前面的地址是该指令的起始地址 你还要加上这个指令的大小,才算是下一条指令的相对地址,而且别忽略了最初的地址是从零开始算的  s:  mov al,ds:[bx];标签表示的是相对于段定义起始位置的位置      mov es:[bx],al      inc bx      loop s      mov ax,4c00h      int 21h  codeseg ends  end start  end</code></pre><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211010160654.png" alt="运行结果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;h2 id=&quot;bx&quot;&gt;&lt;a href=&quot;#bx&quot; class=&quot;headerlink&quot; title=&quot;[bx]&quot;&gt;&lt;/a&gt;[bx]&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-包含多个段的程序</title>
    <link href="https://laobameishijia.github.io/2021/10/10/hui-bian-yu-yan-xue-xi-bao-han-duo-ge-duan-de-cheng-xu/"/>
    <id>https://laobameishijia.github.io/2021/10/10/hui-bian-yu-yan-xue-xi-bao-han-duo-ge-duan-de-cheng-xu/</id>
    <published>2021-10-10T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h1><p>代码结构</p><pre class=" language-text"><code class="language-text">assume cs:codecode segment      ··      ··      数据      ··      ··start:      ··      ··      代码      ··      ··code endsend start</code></pre><h1 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h1><p>代码结构跟上面的差不多,就是要在start中初始化段指针(SS\SP)</p><h1 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h1><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><pre class=" language-text"><code class="language-text">assume cs:code, ds:data, ss:stackdata segment    ··data endsstack segment    ··stack endscode segmentstart:      ··      ··      代码      ··      ··code endsend start</code></pre><p>结构是这个结构,但是在代码段中,仍然需要使用初始化指令来将相应的ds\ss\sp寄存器初始化才可以。总而言之，cpu到底如何处理我们定义的段的中的内容,是当作指令执行，还是当作数据访问，还是当作栈空间,完全是靠程序中具体的汇编指令,和汇编指令对cs:ip、ss:sp、ds等寄存器的设置来决定的。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>前面几个都是给出程序来调试观察的。就不列举出来了</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>编写code总的代码段,将a段和b段中的数据依次相加,将结果保存在c段中。</p><pre class=" language-text"><code class="language-text">  assume cs:code  a segment      db 1,2,3,4,5,6,7,8  a ends  b segment      db 1,2,3,4,5,6,7,8  b ends  c segment      db 0,0,0,0,0,0,0,0  c ends  ;把a 、b段中的数据相加，结果存储到c段当中  code segment  start: mov ax,a      mov ds,ax            mov ax,b      mov es,ax    mov ax,c    mov ss,ax    mov sp,8            mov bx,0      mov cx,7 ;方法1  ; 这样的话解决不了最后08+08的情况, 栈顶指针刚好是0001-> FFFF 这样10放高地址就恰好被溢出了。  ; 所以我觉得,还有一种方式是最后一个元素，用al，其他的用ah, 按照栈元素来说，这样做的是对的  ; 代做: 这样做很麻烦倒是,更好的方式应该是分别计算两个字节的，然后组成一个字，同时push进去，这样的话就不用处理最后一个栈顶元素的问题了  ; 方法1-------是个错误的方法，解决不了栈顶最初始的元素  s: mov ah,ds:[bx]    add ah,es:[bx]    push ax    add sp,1  ;    mov c:[bx],al    inc bx    loop s  ;处理最后一个元素      mov al,ds:[bx]      add al,es:[bx]      push ax  ;方法二------推荐--正确      ; mov cx,4 ;方法2  ; s: mov ah,ds:[bx]  ;    add ah,es:[bx]  ;    add bx,1     ;    mov al,ds:[bx]  ;    add al,es:[bx]  ;    add bx,1  ;    push ax  ;    loop s      mov ax,4c00h      int 21h  code ends  end start</code></pre><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>编写code中的代码,用push指令将a段中的前八个字型数据,逆序存储到b段中。</p><pre class=" language-text"><code class="language-text">  assume cs:code  a segment      dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh  a ends  b segment      dw 0,0,0,0,0,0,0,0  b ends  code segment  start: mov ax,b      mov ss,ax      mov sp,10h;8个字型数据,栈顶指针的大小应该是10h哦！            mov ax,a      mov es,ax            mov bx,0      mov cx,8  s: push es:[bx]      add bx,2;bx这里要自增2哦！      loop s      mov ax,4c00h      int 21h  code ends  end start</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在代码段中使用数据&quot;&gt;&lt;a href=&quot;#在代码段中使用数据&quot; class=&quot;headerlink&quot; title=&quot;在代码段中使用数据&quot;&gt;&lt;/a&gt;在代码段中使用数据&lt;/h1&gt;&lt;p&gt;代码结构&lt;/p&gt;
&lt;pre class=&quot; language-text&quot;&gt;&lt;code</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-第一个程序-1</title>
    <link href="https://laobameishijia.github.io/2021/10/06/hui-bian-yu-yan-xue-xi-di-yi-ge-cheng-xu-1/"/>
    <id>https://laobameishijia.github.io/2021/10/06/hui-bian-yu-yan-xue-xi-di-yi-ge-cheng-xu-1/</id>
    <published>2021-10-06T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于汇编程序的执行问题"><a href="#关于汇编程序的执行问题" class="headerlink" title="关于汇编程序的执行问题"></a>关于汇编程序的执行问题</h1><p>在DOS中,可执行文件中的程序P1若要运行，必须有一个正在运行的程序p2,将p1从可执行文件中加载入内存,将CPU的控制权交给它.p1才能够运行,当p1运行完毕后,应该将cpu的控制权交还给使她得以运行的程序p2</p><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul><li>在提示符<code>C:\masm</code>后面输入可执行文件的名字”1”,按下回车enter键，这时，思考问题4.1</li><li>1.exe运行</li><li>运行结束后，返回。再次显示提示符<code>C:masm</code>.思考问题4.2</li></ul><h3 id="4-1-此时-有一个正在运行的程序将1-exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？"><a href="#4-1-此时-有一个正在运行的程序将1-exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？" class="headerlink" title="4.1 此时,有一个正在运行的程序将1.exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？"></a>4.1 此时,有一个正在运行的程序将1.exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？</h3><p>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个成为shell的程序，用户使用这个程序来操作计算机系统进行工作。</p><p>DOS中有一个程序command.com，这个程序在DOS中成为命令解释器，也就是DOS系统的shell。</p><p>DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他相关的任务后，在屏幕上显示出当前盘符和当前路径组成的提示符，等待用户输入。</p><p>用户可以输入所要执行的命令，如：cd、dir、type等，这些命令由command执行，command执行完这些命令后，再次显示由当前盘符和当前路径组成的提示符，等待用户输入。</p><p>如果用户要执行一个程序，则输入该程序的可执行文件的名称，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载到内存中，设置CS:IP指向程序的入口。此后command暂时停止运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示出由当前盘符和当前路径组成的提示符，等待用户输入。</p><p>在DOS中，command处理各种输入：命令或要执行的程序的文件名。我们就是用过command来进行工作的。</p><h3 id="4-2-程序运行结束后，返回到了哪里？"><a href="#4-2-程序运行结束后，返回到了哪里？" class="headerlink" title="4.2 程序运行结束后，返回到了哪里？"></a>4.2 程序运行结束后，返回到了哪里？</h3><p>程序运行结束后，返回到了command中。</p><h4 id="汇编程序从写出到执行的过程"><a href="#汇编程序从写出到执行的过程" class="headerlink" title="汇编程序从写出到执行的过程"></a>汇编程序从写出到执行的过程</h4><p>编程 -&gt; 1.asm -&gt; 编译 -&gt; 1.obj -&gt; 链接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行</p><h2 id="观察下面程序执行过程中，寄存器和栈顶元素的变化"><a href="#观察下面程序执行过程中，寄存器和栈顶元素的变化" class="headerlink" title="观察下面程序执行过程中，寄存器和栈顶元素的变化"></a>观察下面程序执行过程中，寄存器和栈顶元素的变化</h2><pre class=" language-text"><code class="language-text">assume cs:codesegcodeseg segmentstart:  mov ax,2000H        mov ss,ax        mov sp,0        pop ax        pop bx        push ax        push bx        pop ax        pop bx        mov ax,4c00H    int 21hcodeseg endsend startend</code></pre><p>ax bx 各出入栈。IP和SP指针在变化，其余寄存器没看到变化。栈顶元素最后还是变化到跟初始状态下一致了</p><p>PSP的头两个字节时CD20,其中的内容为</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211006115030.png" alt="PSP"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于汇编程序的执行问题&quot;&gt;&lt;a href=&quot;#关于汇编程序的执行问题&quot; class=&quot;headerlink&quot; title=&quot;关于汇编程序的执行问题&quot;&gt;&lt;/a&gt;关于汇编程序的执行问题&lt;/h1&gt;&lt;p&gt;在DOS中,可执行文件中的程序P1若要运行，必须有一个正在运行的程序</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-寄存器-3</title>
    <link href="https://laobameishijia.github.io/2021/10/04/hui-bian-yu-yan-xue-xi-ji-cun-qi-3/"/>
    <id>https://laobameishijia.github.io/2021/10/04/hui-bian-yu-yan-xue-xi-ji-cun-qi-3/</id>
    <published>2021-10-04T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="基本指令-1-PUSH"><a href="#基本指令-1-PUSH" class="headerlink" title="基本指令 1 PUSH"></a>基本指令 1 PUSH</h2><p>对于push指令的执行</p><ul><li>SP = SP - 2, SS:SP指向当前栈顶前面的单元,以当前栈顶前面的单元为新的栈顶;</li><li>将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶</li></ul><p>具体的图就不画了</p><h2 id="基本指令-2-POP"><a href="#基本指令-2-POP" class="headerlink" title="基本指令 2 POP"></a>基本指令 2 POP</h2><p>关于pop指令的执行</p><ul><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP = SP + 2, SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li></ul><p><strong>注意</strong>: 栈里面的单元是以字为单位的(2个字节),字单元的地址是两个字节地址中的低地址</p><h2 id="栈顶的超界问题"><a href="#栈顶的超界问题" class="headerlink" title="栈顶的超界问题"></a>栈顶的超界问题</h2><p>对于8086CPU不保证对栈的操作不会越界。也就是说,8086CPU只知道栈顶在何出(由SS:SP指示),而不知道我们安排的栈空间有多大。这点好像CPU只知道执行的指令在何出(由CS:IP指示),而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU的工作机理,它只<code>考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条</code></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="寄存器清零"><a href="#寄存器清零" class="headerlink" title="寄存器清零"></a>寄存器清零</h3><p>两种方式:</p><ul><li>sub ax,ax 机器码为2个字节</li><li>mov ax,0 机器码为3个字节</li></ul><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>一段内存,可以既是代码的存储空间,又是数据的存储空间,还可以是栈空间,也可以什么也不是.关键在于CPU中寄存器的设置，即CS\IP\SS\SP\DS的指向。</p><p>我们可以用一个段来此存放数据,将它定义为 数据段 </p><p>我们可以用一个段来此存放代码,将它定义为 代码段 </p><p>我们可以用一个段来此存放栈,将它定义为 栈段</p><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p><p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就能指向我们定义的代码段中的指令。</p><p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，就将我们定义的栈段当作栈空间来操作。</p><p>比如我们将10000H - 1001FH 安排为代码段，并在里面存储如下代码：</p><pre class=" language-text"><code class="language-text">mov ax, 1000Hmov ss, axmov sp, 0020Hmov ax, csmov ds, axmov ax, [0]add ax, [2]mov bx, [4]add bx, [6]push axpush bxpop axpop bx</code></pre><p>设置CS = 10000H,IP=0。这段代码将得到执行，可以看到，在这段代码中，我们又将10000H - 1001FH 安排为栈段和数据段。10000H - 1001FH 这段内存，既是代码段，又是栈段和数据段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h2 id=&quot;基本指令-1-PUSH&quot;&gt;&lt;a href=&quot;#基本指令-1-PUSH&quot; class=&quot;headerlink&quot; title=&quot;基本指令 1 </summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-寄存器-2</title>
    <link href="https://laobameishijia.github.io/2021/10/02/hui-bian-yu-yan-xue-xi-ji-cun-qi-2/"/>
    <id>https://laobameishijia.github.io/2021/10/02/hui-bian-yu-yan-xue-xi-ji-cun-qi-2/</id>
    <published>2021-10-02T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器-2"></a>寄存器-2</h1><h2 id="字的存储"><a href="#字的存储" class="headerlink" title="字的存储"></a>字的存储</h2><p>字的存储没什么好说的，注意下低地址就行了</p><h2 id="指令操作单元之间的关系"><a href="#指令操作单元之间的关系" class="headerlink" title="指令操作单元之间的关系"></a>指令操作单元之间的关系</h2><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>  8086CPU不支持将数据直接送入段寄存器的操作。<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002102608.png" alt="mov指令数据流向"></p><h3 id="sub、add指令"><a href="#sub、add指令" class="headerlink" title="sub、add指令"></a>sub、add指令</h3><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002102642.png" alt="指令数据流向"></p><h2 id="jmp指令跳转后，cs-code-segment-会发生变化"><a href="#jmp指令跳转后，cs-code-segment-会发生变化" class="headerlink" title="jmp指令跳转后，cs code segment 会发生变化"></a>jmp指令跳转后，cs <code>code segment</code> 会发生变化</h2><p>  初始情况下 CS=2000H，IP=0，DS=1000H, AX=0, BX=0</p><pre class=" language-text"><code class="language-text">20000H-20002H mov ax,6222H20003H-20007H jmp 0ff0:010020008H-20009H mov bx,ax10000H-10002H mov ax,2000H10003H-10004H mov ds,ax10005H-10007H mov ax,[0008]10008H-1000AH mov ax,[0002]</code></pre><p>  想说的就是，在执行完<code>jmp 0ff0:0100</code>时 <code>CS 2000H-&gt;0FF0H</code> , <code>IP 0003H-&gt; 0100H</code>,而且执行到<code>mov ax,[0002]</code>后不会再跳回来</p><p><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211002104344.png" alt="汇编执行图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寄存器-2&quot;&gt;&lt;a href=&quot;#寄存器-2&quot; class=&quot;headerlink&quot; title=&quot;寄存器-2&quot;&gt;&lt;/a&gt;寄存器-2&lt;/h1&gt;&lt;h2 id=&quot;字的存储&quot;&gt;&lt;a href=&quot;#字的存储&quot; class=&quot;headerlink&quot; title=&quot;字的存储&quot;</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习-寄存器</title>
    <link href="https://laobameishijia.github.io/2021/10/01/hui-bian-yu-yan-xue-xi-ji-cun-qi/"/>
    <id>https://laobameishijia.github.io/2021/10/01/hui-bian-yu-yan-xue-xi-ji-cun-qi/</id>
    <published>2021-10-01T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><ol><li><p><strong>使用debug指令，将上面的程序段写入内存，逐条执行，观察每条指令执行后，CPU中相关寄存器中的内容变化。</strong></p><p> 输入指令<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001094702.png" alt="20211001094702"></p><p> 修改cs ip 使用r指令<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001094920.png" alt="20211001094920"></p><p> 执行程序 使用t指令<br> <code>具体的过程就不截图了，是ax bx ip 三个寄存器之间值的变化</code></p></li><li><p><strong>利用了三条指令计算2的八次方</strong></p><pre class=" language-text"><code class="language-text">mov ax,1add ax,axjmp 2000:0003</code></pre><p>也是通过t 命令运行程序并观察寄存器中值的变化。</p></li><li><p><strong>查看内存中的内容</strong><br>查看主板上面的内容，我是没看见。不知道是不是因为使用的是DOSbox的原因<br> <img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001102449.png" alt="20211001102449"></p></li><li><p><strong>向内存从B8100H 开始的单元中填写数据</strong></p><p>我盲猜，作者想让读者观察到的显示是有的内存地址(ROM)不能写，有的内存地址可以写</p><p>按照书上面写的8086PC机内存地址的空间分配图来说，b8100属于显存地址空间。<br>我输入过程中的感觉很奇怪，这里面的数据会自己变化</p><p>这里按道理来说b810:0000这个存储单元中存放的应该是20H才对，不知道为什么为了30H<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001103438.png" alt="20211001103438"></p><p>同样都是使用d指令来查询内存中的内容，按道理来说1和2处显示的应该一样才对，3和4就刚好是一样的？？？<br><img src="https://laoba-1304292449.cos.ap-chengdu.myqcloud.com/img/20211001103918.png" alt="20211001103918"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言&quot;&gt;&lt;a href=&quot;#汇编语言&quot; class=&quot;headerlink&quot; title=&quot;汇编语言&quot;&gt;&lt;/a&gt;汇编语言&lt;/h1&gt;&lt;h2 id=&quot;第二章-寄存器&quot;&gt;&lt;a href=&quot;#第二章-寄存器&quot; class=&quot;headerlink&quot; title=&quot;第二章</summary>
      
    
    
    
    <category term="研究生预备学习" scheme="https://laobameishijia.github.io/category/%E7%A0%94%E7%A9%B6%E7%94%9F%E9%A2%84%E5%A4%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="汇编" scheme="https://laobameishijia.github.io/tag/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>更新博客主题</title>
    <link href="https://laobameishijia.github.io/2021/09/30/geng-xin-bo-ke-zhu-ti/"/>
    <id>https://laobameishijia.github.io/2021/09/30/geng-xin-bo-ke-zhu-ti/</id>
    <published>2021-09-30T09:25:00.000Z</published>
    <updated>2021-10-13T13:02:31.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更新博客主题"><a href="#更新博客主题" class="headerlink" title="更新博客主题"></a>更新博客主题</h1><p>保研之后，除了规划一下下一步的研究生学习生活，在无意中逛其他大神的博客的时候，无意间发现了这个非常好看的主题。于是就抽空更换了一下，因为之前自己在<code>GitHub page</code>上搭建过一次，这次遇到的困难并不算多。</p><h2 id="遇到的问题以及待办"><a href="#遇到的问题以及待办" class="headerlink" title="遇到的问题以及待办"></a>遇到的问题以及待办</h2><ul><li><p>长时间不写markdown了，以至于很多插件都不太会用了，</p></li><li><p>之前文章中的代码高亮问题，也不知道是因为插件bug的原因，就是代码块好像必须要用小写才行。也懒得改之前的了，<code>后面的文章一定要按照小写的来</code>。</p></li><li><p>之前文章中的目录就不需要了，这个主题有方便的目录</p></li></ul><h3 id="计划继续完善的东西"><a href="#计划继续完善的东西" class="headerlink" title="计划继续完善的东西"></a>计划继续完善的东西</h3><ul><li><input disabled="" type="checkbox"> 在gitee上面搭建一份一样的博客</li><li><input disabled="" type="checkbox"> 还是希望深入接触一下hexo博客，后面还是希望能增添一些属于自己的东西，毕竟是自己的博客嘛</li><li><input disabled="" type="checkbox"> 这段时间反正也是比较闲，就尽量把每天学到的内容总结一下，写上来把，也算是督促自己了</li><li><input disabled="" type="checkbox"> 主页当中的图片大小会影响到下面博客文章的展示排版</li><li><input disabled="" type="checkbox"> 主页轮播图中有的图片不显示，因为他直接把md文章前面写的那些img文件拼接到cdn后面了。后面有机会看着改一下。</li><li><input disabled="" type="checkbox"> 友情链接，那几个图片显示不了，也不知道是不是跨域问题。</li><li><input checked="" disabled="" type="checkbox"> 不知道他这个目录是怎么显示的，有的有，有的没有。搞清楚一下。<strong>文章TOC设置</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;更新博客主题&quot;&gt;&lt;a href=&quot;#更新博客主题&quot; class=&quot;headerlink&quot; title=&quot;更新博客主题&quot;&gt;&lt;/a&gt;更新博客主题&lt;/h1&gt;&lt;p&gt;保研之后，除了规划一下下一步的研究生学习生活，在无意中逛其他大神的博客的时候，无意间发现了这个非常好看的主题</summary>
      
    
    
    
    <category term="瞎搞" scheme="https://laobameishijia.github.io/category/%E7%9E%8E%E6%90%9E/"/>
    
    
    <category term="博客主题" scheme="https://laobameishijia.github.io/tag/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
    
    <category term="待办" scheme="https://laobameishijia.github.io/tag/%E5%BE%85%E5%8A%9E/"/>
    
  </entry>
  
</feed>
